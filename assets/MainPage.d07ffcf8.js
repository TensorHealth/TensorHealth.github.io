var BR=Object.defineProperty,zR=Object.defineProperties;var UR=Object.getOwnPropertyDescriptors;var Zv=Object.getOwnPropertySymbols;var VR=Object.prototype.hasOwnProperty,GR=Object.prototype.propertyIsEnumerable;var Jv=(n,e,t)=>e in n?BR(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,vi=(n,e)=>{for(var t in e||(e={}))VR.call(e,t)&&Jv(n,t,e[t]);if(Zv)for(var t of Zv(e))GR.call(e,t)&&Jv(n,t,e[t]);return n},eh=(n,e)=>zR(n,UR(e));import{f as Hb,a as kc,c as Bi,h as bc,g as Wb,p as HR,s as WR,aa as jR,r as vr,w as cs,n as Qa,a9 as qR,M as Qv,k as XR,o as jb,A as Mc,B as sd,C as qb,d as _d,ab as YR,y as KR,q as e0,ac as ZR,ad as Fs,ae as JR,af as QR}from"./index.d757ef05.js";import{h as eI,Q as sp}from"./QBtn.549e9b00.js";import{u as tI,a as nI,b as iI,c as rI,f as t0,d as sI,e as oI,g as aI,h as lI,Q as cI}from"./QSelect.e2ef8181.js";function Xb(n,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(i){if(i!=="default"&&!(i in n)){var r=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:function(){return t[i]}})}})}),Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}var uI=Hb({name:"QPage",props:{padding:Boolean,styleFn:Function},setup(n,{slots:e}){const{proxy:{$q:t}}=Wb(),i=kc(HR);kc(WR,()=>{console.error("QPage needs to be child of QPageContainer")});const r=Bi(()=>{const o=(i.header.space===!0?i.header.size:0)+(i.footer.space===!0?i.footer.size:0);if(typeof n.styleFn=="function"){const a=i.isContainer.value===!0?i.containerHeight.value:t.screen.height;return n.styleFn(o,a)}return{minHeight:i.isContainer.value===!0?i.containerHeight.value-o+"px":t.screen.height===0?o!==0?`calc(100vh - ${o}px)`:"100vh":t.screen.height-o+"px"}}),s=Bi(()=>`q-page ${n.padding===!0?" q-layout-padding":""}`);return()=>bc("main",{class:s.value,style:r.value},eI(e.default))}});function hI(){return kc(jR)}var It=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function Yb(n){if(n.__esModule)return n;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach(function(t){var i=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,i.get?i:{enumerable:!0,get:function(){return n[t]}})}),e}var dI={};(function(){var n;function e(x){var C=0;return function(){return C<x.length?{done:!1,value:x[C++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(x,C,A){return x==Array.prototype||x==Object.prototype||(x[C]=A.value),x};function i(x){x=[typeof globalThis=="object"&&globalThis,x,typeof window=="object"&&window,typeof self=="object"&&self,typeof It=="object"&&It];for(var C=0;C<x.length;++C){var A=x[C];if(A&&A.Math==Math)return A}throw Error("Cannot find global object")}var r=i(this);function s(x,C){if(C)e:{var A=r;x=x.split(".");for(var D=0;D<x.length-1;D++){var q=x[D];if(!(q in A))break e;A=A[q]}x=x[x.length-1],D=A[x],C=C(D),C!=D&&C!=null&&t(A,x,{configurable:!0,writable:!0,value:C})}}s("Symbol",function(x){function C(ee){if(this instanceof C)throw new TypeError("Symbol is not a constructor");return new A(D+(ee||"")+"_"+q++,ee)}function A(ee,Z){this.g=ee,t(this,"description",{configurable:!0,writable:!0,value:Z})}if(x)return x;A.prototype.toString=function(){return this.g};var D="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",q=0;return C}),s("Symbol.iterator",function(x){if(x)return x;x=Symbol("Symbol.iterator");for(var C="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),A=0;A<C.length;A++){var D=r[C[A]];typeof D=="function"&&typeof D.prototype[x]!="function"&&t(D.prototype,x,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return x});function o(x){return x={next:x},x[Symbol.iterator]=function(){return this},x}function a(x){var C=typeof Symbol!="undefined"&&Symbol.iterator&&x[Symbol.iterator];return C?C.call(x):{next:e(x)}}function l(x){if(!(x instanceof Array)){x=a(x);for(var C,A=[];!(C=x.next()).done;)A.push(C.value);x=A}return x}var c=typeof Object.create=="function"?Object.create:function(x){function C(){}return C.prototype=x,new C},u;if(typeof Object.setPrototypeOf=="function")u=Object.setPrototypeOf;else{var h;e:{var d={a:!0},f={};try{f.__proto__=d,h=f.a;break e}catch{}h=!1}u=h?function(x,C){if(x.__proto__=C,x.__proto__!==C)throw new TypeError(x+" is not extensible");return x}:null}var p=u;function m(x,C){if(x.prototype=c(C.prototype),x.prototype.constructor=x,p)p(x,C);else for(var A in C)if(A!="prototype")if(Object.defineProperties){var D=Object.getOwnPropertyDescriptor(C,A);D&&Object.defineProperty(x,A,D)}else x[A]=C[A];x.ea=C.prototype}function y(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function g(x){if(x.l)throw new TypeError("Generator is already running");x.l=!0}y.prototype.o=function(x){this.h=x};function v(x,C){x.j={U:C,V:!0},x.g=x.m||x.s}y.prototype.return=function(x){this.j={return:x},this.g=this.s};function _(x,C,A){return x.g=A,{value:C}}function b(x){this.g=new y,this.h=x}function S(x,C){g(x.g);var A=x.g.i;return A?w(x,"return"in A?A.return:function(D){return{value:D,done:!0}},C,x.g.return):(x.g.return(C),T(x))}function w(x,C,A,D){try{var q=C.call(x.g.i,A);if(!(q instanceof Object))throw new TypeError("Iterator result "+q+" is not an object");if(!q.done)return x.g.l=!1,q;var ee=q.value}catch(Z){return x.g.i=null,v(x.g,Z),T(x)}return x.g.i=null,D.call(x.g,ee),T(x)}function T(x){for(;x.g.g;)try{var C=x.h(x.g);if(C)return x.g.l=!1,{value:C.value,done:!1}}catch(A){x.g.h=void 0,v(x.g,A)}if(x.g.l=!1,x.g.j){if(C=x.g.j,x.g.j=null,C.V)throw C.U;return{value:C.return,done:!0}}return{value:void 0,done:!0}}function R(x){this.next=function(C){return g(x.g),x.g.i?C=w(x,x.g.i.next,C,x.g.o):(x.g.o(C),C=T(x)),C},this.throw=function(C){return g(x.g),x.g.i?C=w(x,x.g.i.throw,C,x.g.o):(v(x.g,C),C=T(x)),C},this.return=function(C){return S(x,C)},this[Symbol.iterator]=function(){return this}}function M(x){function C(D){return x.next(D)}function A(D){return x.throw(D)}return new Promise(function(D,q){function ee(Z){Z.done?D(Z.value):Promise.resolve(Z.value).then(C,A).then(ee,q)}ee(x.next())})}function P(x){return M(new R(new b(x)))}s("Promise",function(x){function C(Z){this.h=0,this.i=void 0,this.g=[],this.o=!1;var de=this.j();try{Z(de.resolve,de.reject)}catch(ae){de.reject(ae)}}function A(){this.g=null}function D(Z){return Z instanceof C?Z:new C(function(de){de(Z)})}if(x)return x;A.prototype.h=function(Z){if(this.g==null){this.g=[];var de=this;this.i(function(){de.l()})}this.g.push(Z)};var q=r.setTimeout;A.prototype.i=function(Z){q(Z,0)},A.prototype.l=function(){for(;this.g&&this.g.length;){var Z=this.g;this.g=[];for(var de=0;de<Z.length;++de){var ae=Z[de];Z[de]=null;try{ae()}catch(Ce){this.j(Ce)}}}this.g=null},A.prototype.j=function(Z){this.i(function(){throw Z})},C.prototype.j=function(){function Z(Ce){return function(We){ae||(ae=!0,Ce.call(de,We))}}var de=this,ae=!1;return{resolve:Z(this.C),reject:Z(this.l)}},C.prototype.C=function(Z){if(Z===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(Z instanceof C)this.F(Z);else{e:switch(typeof Z){case"object":var de=Z!=null;break e;case"function":de=!0;break e;default:de=!1}de?this.v(Z):this.m(Z)}},C.prototype.v=function(Z){var de=void 0;try{de=Z.then}catch(ae){this.l(ae);return}typeof de=="function"?this.G(de,Z):this.m(Z)},C.prototype.l=function(Z){this.s(2,Z)},C.prototype.m=function(Z){this.s(1,Z)},C.prototype.s=function(Z,de){if(this.h!=0)throw Error("Cannot settle("+Z+", "+de+"): Promise already settled in state"+this.h);this.h=Z,this.i=de,this.h===2&&this.D(),this.A()},C.prototype.D=function(){var Z=this;q(function(){if(Z.B()){var de=r.console;typeof de!="undefined"&&de.error(Z.i)}},1)},C.prototype.B=function(){if(this.o)return!1;var Z=r.CustomEvent,de=r.Event,ae=r.dispatchEvent;return typeof ae=="undefined"?!0:(typeof Z=="function"?Z=new Z("unhandledrejection",{cancelable:!0}):typeof de=="function"?Z=new de("unhandledrejection",{cancelable:!0}):(Z=r.document.createEvent("CustomEvent"),Z.initCustomEvent("unhandledrejection",!1,!0,Z)),Z.promise=this,Z.reason=this.i,ae(Z))},C.prototype.A=function(){if(this.g!=null){for(var Z=0;Z<this.g.length;++Z)ee.h(this.g[Z]);this.g=null}};var ee=new A;return C.prototype.F=function(Z){var de=this.j();Z.J(de.resolve,de.reject)},C.prototype.G=function(Z,de){var ae=this.j();try{Z.call(de,ae.resolve,ae.reject)}catch(Ce){ae.reject(Ce)}},C.prototype.then=function(Z,de){function ae(Qe,Fe){return typeof Qe=="function"?function(lt){try{Ce(Qe(lt))}catch(wt){We(wt)}}:Fe}var Ce,We,ft=new C(function(Qe,Fe){Ce=Qe,We=Fe});return this.J(ae(Z,Ce),ae(de,We)),ft},C.prototype.catch=function(Z){return this.then(void 0,Z)},C.prototype.J=function(Z,de){function ae(){switch(Ce.h){case 1:Z(Ce.i);break;case 2:de(Ce.i);break;default:throw Error("Unexpected state: "+Ce.h)}}var Ce=this;this.g==null?ee.h(ae):this.g.push(ae),this.o=!0},C.resolve=D,C.reject=function(Z){return new C(function(de,ae){ae(Z)})},C.race=function(Z){return new C(function(de,ae){for(var Ce=a(Z),We=Ce.next();!We.done;We=Ce.next())D(We.value).J(de,ae)})},C.all=function(Z){var de=a(Z),ae=de.next();return ae.done?D([]):new C(function(Ce,We){function ft(lt){return function(wt){Qe[lt]=wt,Fe--,Fe==0&&Ce(Qe)}}var Qe=[],Fe=0;do Qe.push(void 0),Fe++,D(ae.value).J(ft(Qe.length-1),We),ae=de.next();while(!ae.done)})},C});function L(x,C){x instanceof String&&(x+="");var A=0,D=!1,q={next:function(){if(!D&&A<x.length){var ee=A++;return{value:C(ee,x[ee]),done:!1}}return D=!0,{done:!0,value:void 0}}};return q[Symbol.iterator]=function(){return q},q}var $=typeof Object.assign=="function"?Object.assign:function(x,C){for(var A=1;A<arguments.length;A++){var D=arguments[A];if(D)for(var q in D)Object.prototype.hasOwnProperty.call(D,q)&&(x[q]=D[q])}return x};s("Object.assign",function(x){return x||$}),s("Object.is",function(x){return x||function(C,A){return C===A?C!==0||1/C===1/A:C!==C&&A!==A}}),s("Array.prototype.includes",function(x){return x||function(C,A){var D=this;D instanceof String&&(D=String(D));var q=D.length;for(A=A||0,0>A&&(A=Math.max(A+q,0));A<q;A++){var ee=D[A];if(ee===C||Object.is(ee,C))return!0}return!1}}),s("String.prototype.includes",function(x){return x||function(C,A){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(C instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(C,A||0)!==-1}}),s("Array.prototype.keys",function(x){return x||function(){return L(this,function(C){return C})}});var O=this||self;function I(x,C){x=x.split(".");var A=O;x[0]in A||typeof A.execScript=="undefined"||A.execScript("var "+x[0]);for(var D;x.length&&(D=x.shift());)x.length||C===void 0?A[D]&&A[D]!==Object.prototype[D]?A=A[D]:A=A[D]={}:A[D]=C}function N(x){O.setTimeout(function(){throw x},0)}function V(x){N(x)}function X(x,C){V(Error("Invalid wire type: "+x+" (at position "+C+")"))}function J(){V(Error("Failed to read varint, encoding is invalid."))}function W(x,C){return C=String.fromCharCode.apply(null,C),x==null?C:x+C}var Q,re=typeof TextDecoder!="undefined",xe,Ae=typeof TextEncoder!="undefined";function $e(x){if(Ae)x=(xe||(xe=new TextEncoder)).encode(x);else{var C=void 0;C=C===void 0?!1:C;for(var A=0,D=new Uint8Array(3*x.length),q=0;q<x.length;q++){var ee=x.charCodeAt(q);if(128>ee)D[A++]=ee;else{if(2048>ee)D[A++]=ee>>6|192;else{if(55296<=ee&&57343>=ee){if(56319>=ee&&q<x.length){var Z=x.charCodeAt(++q);if(56320<=Z&&57343>=Z){ee=1024*(ee-55296)+Z-56320+65536,D[A++]=ee>>18|240,D[A++]=ee>>12&63|128,D[A++]=ee>>6&63|128,D[A++]=ee&63|128;continue}else q--}if(C)throw Error("Found an unpaired surrogate");ee=65533}D[A++]=ee>>12|224,D[A++]=ee>>6&63|128}D[A++]=ee&63|128}}x=D.subarray(0,A)}return x}var se={},ht=null;function Ie(x){var C;C===void 0&&(C=0),it(),C=se[C];for(var A=Array(Math.floor(x.length/3)),D=C[64]||"",q=0,ee=0;q<x.length-2;q+=3){var Z=x[q],de=x[q+1],ae=x[q+2],Ce=C[Z>>2];Z=C[(Z&3)<<4|de>>4],de=C[(de&15)<<2|ae>>6],ae=C[ae&63],A[ee++]=Ce+Z+de+ae}switch(Ce=0,ae=D,x.length-q){case 2:Ce=x[q+1],ae=C[(Ce&15)<<2]||D;case 1:x=x[q],A[ee]=C[x>>2]+C[(x&3)<<4|Ce>>4]+ae+D}return A.join("")}function at(x){var C=x.length,A=3*C/4;A%3?A=Math.floor(A):"=.".indexOf(x[C-1])!=-1&&(A="=.".indexOf(x[C-2])!=-1?A-2:A-1);var D=new Uint8Array(A),q=0;return je(x,function(ee){D[q++]=ee}),D.subarray(0,q)}function je(x,C){function A(ae){for(;D<x.length;){var Ce=x.charAt(D++),We=ht[Ce];if(We!=null)return We;if(!/^[\s\xa0]*$/.test(Ce))throw Error("Unknown base64 encoding at char: "+Ce)}return ae}it();for(var D=0;;){var q=A(-1),ee=A(0),Z=A(64),de=A(64);if(de===64&&q===-1)break;C(q<<2|ee>>4),Z!=64&&(C(ee<<4&240|Z>>2),de!=64&&C(Z<<6&192|de))}}function it(){if(!ht){ht={};for(var x="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),C=["+/=","+/","-_=","-_.","-_"],A=0;5>A;A++){var D=x.concat(C[A].split(""));se[A]=D;for(var q=0;q<D.length;q++){var ee=D[q];ht[ee]===void 0&&(ht[ee]=q)}}}}var qe=typeof Uint8Array=="function",ce;function ve(x){if(this.g=x,x!==null&&x.length===0)throw Error("ByteString should be constructed with non-empty values")}ve.prototype.toJSON=function(){if(this.g==null)var x="";else x=this.g,x=this.g=x==null||typeof x=="string"?x:qe&&x instanceof Uint8Array?Ie(x):null;return x};var be=typeof Uint8Array.prototype.slice=="function";function Oe(x,C,A){return C===A?ce||(ce=new Uint8Array(0)):be?x.slice(C,A):new Uint8Array(x.subarray(C,A))}var _e=0,z=0;function F(x){if(x.constructor===Uint8Array)return x;if(x.constructor===ArrayBuffer)return new Uint8Array(x);if(x.constructor===Array)return new Uint8Array(x);if(x.constructor===String)return at(x);if(x.constructor===ve){if(x.g==null)var C=ce||(ce=new Uint8Array(0));else{C=Uint8Array;var A=x.g;A=A==null||qe&&A!=null&&A instanceof Uint8Array?A:typeof A=="string"?at(A):null,x=x.g=A,C=new C(x)}return C}if(x instanceof Uint8Array)return new Uint8Array(x.buffer,x.byteOffset,x.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")}function me(x,C){C=C===void 0?{}:C,C=C.u===void 0?!1:C.u,this.h=null,this.g=this.i=this.l=0,this.j=!1,this.u=C,x&&le(this,x)}function le(x,C){x.h=F(C),x.l=0,x.i=x.h.length,x.g=x.l}me.prototype.reset=function(){this.g=this.l};function j(x){x.g>x.i&&(x.j=!0,V(Error("Tried to read past the end of the data "+x.g+" > "+x.i)))}function pe(x){var C=x.h,A=C[x.g],D=A&127;return 128>A?(x.g+=1,j(x),D):(A=C[x.g+1],D|=(A&127)<<7,128>A?(x.g+=2,j(x),D):(A=C[x.g+2],D|=(A&127)<<14,128>A?(x.g+=3,j(x),D):(A=C[x.g+3],D|=(A&127)<<21,128>A?(x.g+=4,j(x),D):(A=C[x.g+4],D|=(A&15)<<28,128>A?(x.g+=5,j(x),D>>>0):(x.g+=5,128<=C[x.g++]&&128<=C[x.g++]&&128<=C[x.g++]&&128<=C[x.g++]&&128<=C[x.g++]?(x.j=!0,J(),D):(j(x),D))))))}var Se=[];function De(){this.g=new Uint8Array(64),this.h=0}function ye(x,C){if(!(x.h+1<x.g.length)){var A=x.g;x.g=new Uint8Array(Math.ceil(1+2*x.g.length)),x.g.set(A)}x.g[x.h++]=C}De.prototype.length=function(){return this.h},De.prototype.end=function(){var x=this.g,C=this.h;return this.h=0,Oe(x,0,C)};function Pe(x,C){for(;127<C;)ye(x,C&127|128),C>>>=7;ye(x,C)}function Be(x){var C={},A=C.N===void 0?!1:C.N;this.m={u:C.u===void 0?!1:C.u},this.N=A,C=this.m,Se.length?(A=Se.pop(),C&&(A.u=C.u),x&&le(A,x),x=A):x=new me(x,C),this.g=x,this.l=this.g.g,this.h=this.i=-1,this.j=!1}Be.prototype.reset=function(){this.g.reset(),this.h=this.i=-1};function Ke(x){var C=x.g;if((C=C.g==C.i)||(C=x.j)||(C=x.g,C=C.j||0>C.g||C.g>C.i),C)return!1;x.l=x.g.g;var A=pe(x.g);return C=A>>>3,A&=7,0<=A&&5>=A?(x.i=C,x.h=A,!0):(x.j=!0,X(A,x.l),!1)}function H(x){switch(x.h){case 0:if(x.h!=0)H(x);else e:{x=x.g;for(var C=x.g,A=0;10>A;A++){if((x.h[C]&128)===0){x.g=C+1,j(x);break e}C++}x.j=!0,J()}break;case 1:x=x.g,x.g+=8,j(x);break;case 2:x.h!=2?H(x):(C=pe(x.g),x=x.g,x.g+=C,j(x));break;case 5:x=x.g,x.g+=4,j(x);break;case 3:C=x.i;do{if(!Ke(x)){x.j=!0,V(Error("Unmatched start-group tag: stream EOF"));break}if(x.h==4){x.i!=C&&(x.j=!0,V(Error("Unmatched end-group tag")));break}H(x)}while(1);break;default:x.j=!0,X(x.h,x.l)}}function ue(x,C,A){x.N||(x=Oe(x.g.h,A,x.g.g),(A=C.m)?A.push(x):C.m=[x])}var Je=[];function yt(){this.h=[],this.i=0,this.g=new De}function pn(x,C){C.length!==0&&(x.h.push(C),x.i+=C.length)}function sr(x,C,A){Pe(x.g,8*C+2),Pe(x.g,A.length),pn(x,x.g.end()),pn(x,A)}var Di=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol(void 0):void 0;function yo(x,C){Object.isFrozen(x)||(Di?x[Di]|=C:x.g!==void 0?x.g|=C:Object.defineProperties(x,{g:{value:C,configurable:!0,writable:!0,enumerable:!1}}))}function Rn(x){if(!x)return 0;var C;return Di?C=x[Di]:C=x.g,C==null?0:C}function In(x){return Array.isArray(x)&&yo(x,1),x}function ws(x){if(!Array.isArray(x))throw Error("cannot mark non-array as immutable");yo(x,2)}function tc(x){return x!==null&&typeof x=="object"&&x.constructor===Object}function Zu(x){switch(typeof x){case"number":return isFinite(x)?x:String(x);case"object":return qe&&x!=null&&x instanceof Uint8Array?Ie(x):x;default:return x}}function nc(x,C){if(x!=null)return Array.isArray(x)||tc(x)?ki(x,C):C(x)}function ki(x,C){if(Array.isArray(x)){for(var A=Array(x.length),D=0;D<x.length;D++)A[D]=nc(x[D],C);return Rn(x)&1&&In(A),A}A={};for(D in x)A[D]=nc(x[D],C);return A}var ic;function li(x,C,A){var D=ic;ic=null,x||(x=D),D=this.constructor.ca,x||(x=D?[D]:[]),this.j=(D?0:-1)-(this.constructor.aa||0),this.i=null,this.g=x;e:{if(D=this.g.length,x=D-1,D&&(D=this.g[x],tc(D))){this.l=x-this.j,this.h=D;break e}C!==void 0&&-1<C?(this.l=Math.max(C,x+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(A)for(C=0;C<A.length;C++)x=A[C],x<this.l?(x+=this.j,(D=this.g[x])?In(D):this.g[x]=Ea):(B(this),(D=this.h[x])?In(D):this.h[x]=Ea)}var Ea=Object.freeze(In([]));function B(x){var C=x.l+x.j;x.g[C]||(x.h=x.g[C]={})}function ie(x,C,A){return C===-1?null:(A===void 0?0:A)||C>=x.l?x.h?x.h[C]:void 0:x.g[C+x.j]}function te(x,C,A){A=A===void 0?!0:A;var D=D===void 0?!1:D,q=ie(x,C,D);return q==null&&(q=Ea),q===Ea?(q=In([]),ge(x,C,q,D)):A&&Array.isArray(q)&&Rn(q)&2&&(q=q.slice(),ge(x,C,q,D)),q}function oe(x,C,A){return x=ie(x,C),x=x==null?x:+x,x==null?A===void 0?0:A:x}function ge(x,C,A,D){(D===void 0?0:D)||C>=x.l?(B(x),x.h[C]=A):x.g[C+x.j]=A}function ct(x,C,A){x.i||(x.i={});var D=x.i[A];if(!D){var q=te(x,A,!1);D=[];for(var ee=Array.isArray(q)?!!(Rn(q)&2):!1,Z=0;Z<q.length;Z++)D[Z]=new C(q[Z]),ee&&ws(D[Z].g);ee&&(ws(D),Object.freeze(D)),x.i[A]=D}return D}function rt(x,C,A,D,q){var ee=ct(x,D,C);A=A||new D,x=te(x,C),q!=null?(ee.splice(q,0,A),x.splice(q,0,st(A))):(ee.push(A),x.push(st(A)))}li.prototype.toJSON=function(){var x=st(this);return ki(x,Zu)};function st(x){if(x.i)for(var C in x.i){var A=x.i[C];if(Array.isArray(A))for(var D=0;D<A.length;D++)A[D]&&st(A[D]);else A&&st(A)}return x.g}li.prototype.toString=function(){return st(this).toString()};function ot(x,C){return x=ie(x,C),x==null?0:x}function Jt(x,C){return x=ie(x,C),x==null?"":x}function Xt(x,C){if(x=x.m){pn(C,C.g.end());for(var A=0;A<x.length;A++)pn(C,x[A])}}function tt(x){var C=x[0];switch(x.length){case 2:var A=x[1];return function(ae,Ce,We){return C(ae,Ce,We,A)};case 3:var D=x[1],q=x[2];return function(ae,Ce,We){return C(ae,Ce,We,D,q)};case 4:var ee=x[1],Z=x[2],de=x[3];return function(ae,Ce,We){return C(ae,Ce,We,ee,Z,de)};default:throw Error("unsupported number of parameters, expected [2-4], got "+x.length)}}function vt(x,C,A){for(;Ke(C)&&C.h!=4;){var D=C.i,q=A[D];if(q){if(Array.isArray(q)&&(q=A[D]=tt(q)),!q(C,x,D)){D=C,q=x;var ee=D.l;H(D),ue(D,q,ee)}}else D=C,q=x,ee=D.l,H(D),ue(D,q,ee)}return x}function yi(x,C){var A=new yt;if(C(x,A),x=A.i+A.g.length(),x===0)A=new Uint8Array(0);else{x=new Uint8Array(x);for(var D=A.h,q=D.length,ee=C=0;ee<q;ee++){var Z=D[ee];Z.length!==0&&(x.set(Z,C),C+=Z.length)}D=A.g,q=D.h,q!==0&&(x.set(D.g.subarray(0,q),C),D.h=0),A.h=[x],A=x}return A}function Nt(x,C,A){if(Je.length){var D=Je.pop();x&&(le(D.g,x),D.i=-1,D.h=-1),x=D}else x=new Be(x);try{return A(new C,x)}finally{C=x.g,C.h=null,C.l=0,C.i=0,C.g=0,C.j=!1,C.u=!1,x.i=-1,x.h=-1,x.j=!1,100>Je.length&&Je.push(x)}}function mn(x,C,A){if(C=ie(C,A),C!=null){Pe(x.g,8*A+5),x=x.g;var D=C;D=(A=0>D?1:0)?-D:D,D===0?0<1/D?_e=z=0:(z=0,_e=2147483648):isNaN(D)?(z=0,_e=2147483647):34028234663852886e22<D?(z=0,_e=(A<<31|2139095040)>>>0):11754943508222875e-54>D?(D=Math.round(D/Math.pow(2,-149)),z=0,_e=(A<<31|D)>>>0):(C=Math.floor(Math.log(D)/Math.LN2),D*=Math.pow(2,-C),D=Math.round(8388608*D),16777216<=D&&++C,z=0,_e=(A<<31|C+127<<23|D&8388607)>>>0),A=_e,ye(x,A>>>0&255),ye(x,A>>>8&255),ye(x,A>>>16&255),ye(x,A>>>24&255)}}function At(x,C,A){if(x.h!==5)return!1;x=x.g;var D=x.h[x.g],q=x.h[x.g+1],ee=x.h[x.g+2],Z=x.h[x.g+3];return x.g+=4,j(x),q=(D<<0|q<<8|ee<<16|Z<<24)>>>0,x=2*(q>>31)+1,D=q>>>23&255,q&=8388607,ge(C,A,D==255?q?NaN:1/0*x:D==0?x*Math.pow(2,-149)*q:x*Math.pow(2,D-150)*(q+Math.pow(2,23))),!0}function rc(x,C,A){if(x.h!==0)return!1;for(var D=x.g,q=128,ee=0,Z=x=0;4>Z&&128<=q;Z++)q=D.h[D.g++],ee|=(q&127)<<7*Z;if(128<=q&&(q=D.h[D.g++],ee|=(q&127)<<28,x|=(q&127)>>4),128<=q)for(Z=0;5>Z&&128<=q;Z++)q=D.h[D.g++],x|=(q&127)<<7*Z+3;return 128>q?(D=ee>>>0,q=x>>>0,(x=q&2147483648)&&(D=~D+1>>>0,q=~q>>>0,D==0&&(q=q+1>>>0)),D=4294967296*q+(D>>>0),x=x?-D:D):(D.j=!0,J(),x=void 0),ge(C,A,x),!0}function $n(x,C,A){return x.h!==0?!1:(ge(C,A,pe(x.g)),!0)}function Ss(x,C,A){if(x.h!==2)return!1;var D=pe(x.g);x=x.g;var q=x.g;x.g+=D,j(x),x=x.h;var ee;if(re)(ee=Q)||(ee=Q=new TextDecoder("utf-8",{fatal:!1})),ee=ee.decode(x.subarray(q,q+D));else{D=q+D;for(var Z=[],de=null,ae,Ce,We;q<D;)ae=x[q++],128>ae?Z.push(ae):224>ae?q>=D?Z.push(65533):(Ce=x[q++],194>ae||(Ce&192)!==128?(q--,Z.push(65533)):Z.push((ae&31)<<6|Ce&63)):240>ae?q>=D-1?Z.push(65533):(Ce=x[q++],(Ce&192)!==128||ae===224&&160>Ce||ae===237&&160<=Ce||((ee=x[q++])&192)!==128?(q--,Z.push(65533)):Z.push((ae&15)<<12|(Ce&63)<<6|ee&63)):244>=ae?q>=D-2?Z.push(65533):(Ce=x[q++],(Ce&192)!==128||(ae<<28)+(Ce-144)>>30!==0||((ee=x[q++])&192)!==128||((We=x[q++])&192)!==128?(q--,Z.push(65533)):(ae=(ae&7)<<18|(Ce&63)<<12|(ee&63)<<6|We&63,ae-=65536,Z.push((ae>>10&1023)+55296,(ae&1023)+56320))):Z.push(65533),8192<=Z.length&&(de=W(de,Z),Z.length=0);ee=W(de,Z)}return ge(C,A,ee),!0}function Yr(x,C,A,D,q){if(x.h!==2)return!1;var ee=new D,Z=x.g.i,de=pe(x.g),ae=x.g.g+de;if(x.g.i=ae,q(ee,x),q=ae-x.g.g,q!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+(de+" bytes, instead read "+(de-q)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return x.g.g=ae,x.g.i=Z,rt(C,A,ee,D,void 0),!0}function or(x){li.call(this,x)}var zv;m(or,li);function mR(x,C){var A=ie(x,1);if(A!=null&&A!=null){Pe(C.g,8);var D=C.g;if(0<=A)Pe(D,A);else{for(var q=0;9>q;q++)ye(D,A&127|128),A>>=7;ye(D,1)}}mn(C,x,2),D=ie(x,3),D!=null&&sr(C,3,$e(D)),D=ie(x,4),D!=null&&sr(C,4,$e(D)),Xt(x,C)}function gR(x,C){return vt(x,C,zv||(zv={1:$n,2:At,3:Ss,4:Ss}))}function ep(x){li.call(this,x,-1,vR)}var Uv;m(ep,li),ep.prototype.addClassification=function(x,C){return rt(this,1,x,or,C),this};function yR(x,C){return vt(x,C,Uv||(Uv={1:[Yr,or,gR]}))}var vR=[1];function Ju(x){li.call(this,x)}var Vv;m(Ju,li);function xR(x,C){mn(C,x,1),mn(C,x,2),mn(C,x,3),mn(C,x,4),mn(C,x,5),Xt(x,C)}function _R(x,C){return vt(x,C,Vv||(Vv={1:At,2:At,3:At,4:At,5:At}))}function Gv(x){li.call(this,x,-1,wR)}var Hv;m(Gv,li);function bR(x,C){return vt(x,C,Hv||(Hv={1:[Yr,Ju,_R]}))}var wR=[1];function tp(x){li.call(this,x)}var Wv;m(tp,li);function SR(x,C){mn(C,x,1),mn(C,x,2),mn(C,x,3),mn(C,x,4),mn(C,x,5);var A=ie(x,6);if(A!=null&&A!=null){Pe(C.g,48);var D=C.g,q=A;A=0>q,q=Math.abs(q);var ee=q>>>0;for(q=Math.floor((q-ee)/4294967296),q>>>=0,A&&(q=~q>>>0,ee=(~ee>>>0)+1,4294967295<ee&&(ee=0,q++,4294967295<q&&(q=0))),_e=ee,z=q,A=_e,ee=z;0<ee||127<A;)ye(D,A&127|128),A=(A>>>7|ee<<25)>>>0,ee>>>=7;ye(D,A)}Xt(x,C)}function TR(x,C){return vt(x,C,Wv||(Wv={1:At,2:At,3:At,4:At,5:At,6:rc}))}function jv(x,C,A){if(A=x.createShader(A===0?x.VERTEX_SHADER:x.FRAGMENT_SHADER),x.shaderSource(A,C),x.compileShader(A),!x.getShaderParameter(A,x.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+x.getShaderInfoLog(A));return A}function ER(x){return ct(x,or,1).map(function(C){return{index:ot(C,1),X:oe(C,2),label:ie(C,3)!=null?Jt(C,3):void 0,displayName:ie(C,4)!=null?Jt(C,4):void 0}})}function CR(x){return{x:oe(x,1),y:oe(x,2),z:oe(x,3),visibility:ie(x,4)!=null?oe(x,4):void 0}}function np(x){return ct(Nt(x,Gv,bR),Ju,1).map(CR)}function ip(x,C){this.h=x,this.g=C,this.l=0}function qv(x,C,A){return MR(x,C),typeof x.g.canvas.transferToImageBitmap=="function"?Promise.resolve(x.g.canvas.transferToImageBitmap()):A?Promise.resolve(x.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(x.g.canvas):(x.i===void 0&&(x.i=document.createElement("canvas")),new Promise(function(D){x.i.height=x.g.canvas.height,x.i.width=x.g.canvas.width,x.i.getContext("2d",{}).drawImage(x.g.canvas,0,0,x.g.canvas.width,x.g.canvas.height),D(x.i)}))}function MR(x,C){var A=x.g;if(x.m===void 0){var D=jv(A,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),q=jv(A,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),ee=A.createProgram();if(A.attachShader(ee,D),A.attachShader(ee,q),A.linkProgram(ee),!A.getProgramParameter(ee,A.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+A.getProgramInfoLog(ee));D=x.m=ee,A.useProgram(D),q=A.getUniformLocation(D,"sampler0"),x.j={I:A.getAttribLocation(D,"aVertex"),H:A.getAttribLocation(D,"aTex"),da:q},x.s=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,x.s),A.enableVertexAttribArray(x.j.I),A.vertexAttribPointer(x.j.I,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),x.o=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,x.o),A.enableVertexAttribArray(x.j.H),A.vertexAttribPointer(x.j.H,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),A.uniform1i(q,0)}D=x.j,A.useProgram(x.m),A.canvas.width=C.width,A.canvas.height=C.height,A.viewport(0,0,C.width,C.height),A.activeTexture(A.TEXTURE0),x.h.bindTexture2d(C.glName),A.enableVertexAttribArray(D.I),A.bindBuffer(A.ARRAY_BUFFER,x.s),A.vertexAttribPointer(D.I,2,A.FLOAT,!1,0,0),A.enableVertexAttribArray(D.H),A.bindBuffer(A.ARRAY_BUFFER,x.o),A.vertexAttribPointer(D.H,2,A.FLOAT,!1,0,0),A.bindFramebuffer(A.DRAW_FRAMEBUFFER?A.DRAW_FRAMEBUFFER:A.FRAMEBUFFER,null),A.clearColor(0,0,0,0),A.clear(A.COLOR_BUFFER_BIT),A.colorMask(!0,!0,!0,!0),A.drawArrays(A.TRIANGLE_FAN,0,4),A.disableVertexAttribArray(D.I),A.disableVertexAttribArray(D.H),A.bindBuffer(A.ARRAY_BUFFER,null),x.h.bindTexture2d(0)}function AR(x){this.g=x}var RR=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function IR(x,C){return C+x}function Xv(x,C){window[x]=C}function PR(x){var C=document.createElement("script");return C.setAttribute("src",x),C.setAttribute("crossorigin","anonymous"),new Promise(function(A){C.addEventListener("load",function(){A()},!1),C.addEventListener("error",function(){A()},!1),document.body.appendChild(C)})}function NR(){return P(function(x){switch(x.g){case 1:return x.m=2,_(x,WebAssembly.instantiate(RR),4);case 4:x.g=3,x.m=0;break;case 2:return x.m=0,x.j=null,x.return(!1);case 3:return x.return(!0)}})}function rp(x){if(this.g=x,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=x&&x.locateFile||IR,typeof window=="object")var C=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location!="undefined")C=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=C,x.options){C=a(Object.keys(x.options));for(var A=C.next();!A.done;A=C.next()){A=A.value;var D=x.options[A].default;D!==void 0&&(this.j[A]=typeof D=="function"?D():D)}}}n=rp.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function LR(x){var C,A,D,q,ee,Z,de,ae,Ce,We,ft;return P(function(Qe){switch(Qe.g){case 1:return x.R?(C=x.g.files===void 0?[]:typeof x.g.files=="function"?x.g.files(x.j):x.g.files,_(Qe,NR(),2)):Qe.return();case 2:if(A=Qe.h,typeof window=="object")return Xv("createMediapipeSolutionsWasm",{locateFile:x.locateFile}),Xv("createMediapipeSolutionsPackedAssets",{locateFile:x.locateFile}),Z=C.filter(function(Fe){return Fe.data!==void 0}),de=C.filter(function(Fe){return Fe.data===void 0}),ae=Promise.all(Z.map(function(Fe){var lt=Qu(x,Fe.url);if(Fe.path!==void 0){var wt=Fe.path;lt=lt.then(function(Yt){return x.overrideFile(wt,Yt),Promise.resolve(Yt)})}return lt})),Ce=Promise.all(de.map(function(Fe){return Fe.simd===void 0||Fe.simd&&A||!Fe.simd&&!A?PR(x.locateFile(Fe.url,x.S)):Promise.resolve()})).then(function(){var Fe,lt,wt;return P(function(Yt){if(Yt.g==1)return Fe=window.createMediapipeSolutionsWasm,lt=window.createMediapipeSolutionsPackedAssets,wt=x,_(Yt,Fe(lt),2);wt.h=Yt.h,Yt.g=0})}),We=function(){return P(function(Fe){return x.g.graph&&x.g.graph.url?Fe=_(Fe,Qu(x,x.g.graph.url),0):(Fe.g=0,Fe=void 0),Fe})}(),_(Qe,Promise.all([Ce,ae,We]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return D=C.filter(function(Fe){return Fe.simd===void 0||Fe.simd&&A||!Fe.simd&&!A}).map(function(Fe){return x.locateFile(Fe.url,x.S)}),importScripts.apply(null,l(D)),q=x,_(Qe,createMediapipeSolutionsWasm(Module),6);case 6:q.h=Qe.h,x.l=new OffscreenCanvas(1,1),x.h.canvas=x.l,ee=x.h.GL.createContext(x.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext!="undefined"?2:1}),x.h.GL.makeContextCurrent(ee),Qe.g=4;break;case 7:if(x.l=document.createElement("canvas"),ft=x.l.getContext("webgl2",{}),!ft&&(ft=x.l.getContext("webgl",{}),!ft))return alert("Failed to create WebGL canvas context when passing video frame."),Qe.return();x.D=ft,x.h.canvas=x.l,x.h.createContext(x.l,!0,!0,{});case 4:x.i=new x.h.SolutionWasm,x.R=!1,Qe.g=0}})}function DR(x){var C,A,D,q,ee,Z,de,ae;return P(function(Ce){if(Ce.g==1){if(x.g.graph&&x.g.graph.url&&x.P===x.g.graph.url)return Ce.return();if(x.o=!0,!x.g.graph||!x.g.graph.url){Ce.g=2;return}return x.P=x.g.graph.url,_(Ce,Qu(x,x.g.graph.url),3)}for(Ce.g!=2&&(C=Ce.h,x.i.loadGraph(C)),A=a(Object.keys(x.B)),D=A.next();!D.done;D=A.next())q=D.value,x.i.overrideFile(q,x.B[q]);if(x.B={},x.g.listeners)for(ee=a(x.g.listeners),Z=ee.next();!Z.done;Z=ee.next())de=Z.value,$R(x,de);ae=x.j,x.j={},x.setOptions(ae),Ce.g=0})}n.reset=function(){var x=this;return P(function(C){x.i&&(x.i.reset(),x.m={},x.s={}),C.g=0})},n.setOptions=function(x,C){var A=this;if(C=C||this.g.options){for(var D=[],q=[],ee={},Z=a(Object.keys(x)),de=Z.next();!de.done;ee={K:ee.K,L:ee.L},de=Z.next()){var ae=de.value;ae in this.j&&this.j[ae]===x[ae]||(this.j[ae]=x[ae],de=C[ae],de!==void 0&&(de.onChange&&(ee.K=de.onChange,ee.L=x[ae],D.push(function(Ce){return function(){var We;return P(function(ft){if(ft.g==1)return _(ft,Ce.K(Ce.L),2);We=ft.h,We===!0&&(A.o=!0),ft.g=0})}}(ee))),de.graphOptionXref&&(ae={valueNumber:de.type===1?x[ae]:0,valueBoolean:de.type===0?x[ae]:!1,valueString:de.type===2?x[ae]:""},de=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),de.graphOptionXref),ae),q.push(de))))}(D.length!==0||q.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(q),this.v=(this.v===void 0?[]:this.v).concat(D))}};function kR(x){var C,A,D,q,ee,Z,de;return P(function(ae){switch(ae.g){case 1:if(!x.o)return ae.return();if(!x.v){ae.g=2;break}C=a(x.v),A=C.next();case 3:if(A.done){ae.g=5;break}return D=A.value,_(ae,D(),4);case 4:A=C.next(),ae.g=3;break;case 5:x.v=void 0;case 2:if(x.A){for(q=new x.h.GraphOptionChangeRequestList,ee=a(x.A),Z=ee.next();!Z.done;Z=ee.next())de=Z.value,q.push_back(de);x.i.changeOptions(q),q.delete(),x.A=void 0}x.o=!1,ae.g=0}})}n.initialize=function(){var x=this;return P(function(C){return C.g==1?_(C,LR(x),2):C.g!=3?_(C,DR(x),3):_(C,kR(x),0)})};function Qu(x,C){var A,D;return P(function(q){return C in x.F?q.return(x.F[C]):(A=x.locateFile(C,""),D=fetch(A).then(function(ee){return ee.arrayBuffer()}),x.F[C]=D,q.return(D))})}n.overrideFile=function(x,C){this.i?this.i.overrideFile(x,C):this.B[x]=C},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(x,C){var A=this,D,q,ee,Z,de,ae,Ce,We,ft;return P(function(Qe){switch(Qe.g){case 1:return A.g.inputs?(D=1e3*(C==null?performance.now():C),_(Qe,A.C,2)):Qe.return();case 2:return _(Qe,A.initialize(),3);case 3:for(q=new A.h.PacketDataList,ee=a(Object.keys(x)),Z=ee.next();!Z.done;Z=ee.next())if(de=Z.value,ae=A.g.inputs[de]){e:{var Fe=x[de];switch(ae.type){case"video":var lt=A.m[ae.stream];if(lt||(lt=new ip(A.h,A.D),A.m[ae.stream]=lt),lt.l===0&&(lt.l=lt.h.createTexture()),typeof HTMLVideoElement!="undefined"&&Fe instanceof HTMLVideoElement)var wt=Fe.videoWidth,Yt=Fe.videoHeight;else typeof HTMLImageElement!="undefined"&&Fe instanceof HTMLImageElement?(wt=Fe.naturalWidth,Yt=Fe.naturalHeight):(wt=Fe.width,Yt=Fe.height);Yt={glName:lt.l,width:wt,height:Yt},wt=lt.g,wt.canvas.width=Yt.width,wt.canvas.height=Yt.height,wt.activeTexture(wt.TEXTURE0),lt.h.bindTexture2d(lt.l),wt.texImage2D(wt.TEXTURE_2D,0,wt.RGBA,wt.RGBA,wt.UNSIGNED_BYTE,Fe),lt.h.bindTexture2d(0),lt=Yt;break e;case"detections":for(lt=A.m[ae.stream],lt||(lt=new AR(A.h),A.m[ae.stream]=lt),lt.data||(lt.data=new lt.g.DetectionListData),lt.data.reset(Fe.length),Yt=0;Yt<Fe.length;++Yt){wt=Fe[Yt];var Ut=lt.data,Pn=Ut.setBoundingBox,Oi=Yt,ci=wt.T,Ct=new tp;if(ge(Ct,1,ci.Y),ge(Ct,2,ci.Z),ge(Ct,3,ci.height),ge(Ct,4,ci.width),ge(Ct,5,ci.rotation),ge(Ct,6,ci.W),ci=yi(Ct,SR),Pn.call(Ut,Oi,ci),wt.O)for(Ut=0;Ut<wt.O.length;++Ut){Ct=wt.O[Ut];var gn=!!Ct.visibility;Pn=lt.data,Oi=Pn.addNormalizedLandmark,ci=Yt,Ct=Object.assign(Object.assign({},Ct),{visibility:gn?Ct.visibility:0}),gn=new Ju,ge(gn,1,Ct.x),ge(gn,2,Ct.y),ge(gn,3,Ct.z),Ct.visibility&&ge(gn,4,Ct.visibility),Ct=yi(gn,xR),Oi.call(Pn,ci,Ct)}if(wt.M)for(Ut=0;Ut<wt.M.length;++Ut)Pn=lt.data,Oi=Pn.addClassification,ci=Yt,Ct=wt.M[Ut],gn=new or,ge(gn,2,Ct.X),Ct.index&&ge(gn,1,Ct.index),Ct.label&&ge(gn,3,Ct.label),Ct.displayName&&ge(gn,4,Ct.displayName),Ct=yi(gn,mR),Oi.call(Pn,ci,Ct)}lt=lt.data;break e;default:lt={}}}switch(Ce=lt,We=ae.stream,ae.type){case"video":q.pushTexture2d(Object.assign(Object.assign({},Ce),{stream:We,timestamp:D}));break;case"detections":ft=Ce,ft.stream=We,ft.timestamp=D,q.pushDetectionList(ft);break;default:throw Error("Unknown input config type: '"+ae.type+"'")}}return A.i.send(q),_(Qe,A.C,4);case 4:q.delete(),Qe.g=0}})};function OR(x,C,A){var D,q,ee,Z,de,ae,Ce,We,ft,Qe,Fe,lt,wt,Yt;return P(function(Ut){switch(Ut.g){case 1:if(!A)return Ut.return(C);for(D={},q=0,ee=a(Object.keys(A)),Z=ee.next();!Z.done;Z=ee.next())de=Z.value,ae=A[de],typeof ae!="string"&&ae.type==="texture"&&C[ae.stream]!==void 0&&++q;1<q&&(x.G=!1),Ce=a(Object.keys(A)),Z=Ce.next();case 2:if(Z.done){Ut.g=4;break}if(We=Z.value,ft=A[We],typeof ft=="string")return wt=D,Yt=We,_(Ut,FR(x,We,C[ft]),14);if(Qe=C[ft.stream],ft.type==="detection_list"){if(Qe){for(var Pn=Qe.getRectList(),Oi=Qe.getLandmarksList(),ci=Qe.getClassificationsList(),Ct=[],gn=0;gn<Pn.size();++gn){var Ts=Nt(Pn.get(gn),tp,TR);Ts={T:{Y:oe(Ts,1),Z:oe(Ts,2),height:oe(Ts,3),width:oe(Ts,4),rotation:oe(Ts,5,0),W:ot(Ts,6)},O:np(Oi.get(gn)),M:ER(Nt(ci.get(gn),ep,yR))},Ct.push(Ts)}Pn=Ct}else Pn=[];D[We]=Pn,Ut.g=7;break}if(ft.type==="proto_list"){if(Qe){for(Pn=Array(Qe.size()),Oi=0;Oi<Qe.size();Oi++)Pn[Oi]=Qe.get(Oi);Qe.delete()}else Pn=[];D[We]=Pn,Ut.g=7;break}if(Qe===void 0){Ut.g=3;break}if(ft.type==="float_list"){D[We]=Qe,Ut.g=7;break}if(ft.type==="proto"){D[We]=Qe,Ut.g=7;break}if(ft.type!=="texture")throw Error("Unknown output config type: '"+ft.type+"'");return Fe=x.s[We],Fe||(Fe=new ip(x.h,x.D),x.s[We]=Fe),_(Ut,qv(Fe,Qe,x.G),13);case 13:lt=Ut.h,D[We]=lt;case 7:ft.transform&&D[We]&&(D[We]=ft.transform(D[We])),Ut.g=3;break;case 14:wt[Yt]=Ut.h;case 3:Z=Ce.next(),Ut.g=2;break;case 4:return Ut.return(D)}})}function FR(x,C,A){var D;return P(function(q){return typeof A=="number"||A instanceof Uint8Array||A instanceof x.h.Uint8BlobList?q.return(A):A instanceof x.h.Texture2dDataOut?(D=x.s[C],D||(D=new ip(x.h,x.D),x.s[C]=D),q.return(qv(D,A,x.G))):q.return(void 0)})}function $R(x,C){for(var A=C.name||"$",D=[].concat(l(C.wants)),q=new x.h.StringList,ee=a(C.wants),Z=ee.next();!Z.done;Z=ee.next())q.push_back(Z.value);ee=x.h.PacketListener.implement({onResults:function(de){for(var ae={},Ce=0;Ce<C.wants.length;++Ce)ae[D[Ce]]=de.get(Ce);var We=x.listeners[A];We&&(x.C=OR(x,ae,C.outs).then(function(ft){ft=We(ft);for(var Qe=0;Qe<C.wants.length;++Qe){var Fe=ae[D[Qe]];typeof Fe=="object"&&Fe.hasOwnProperty&&Fe.hasOwnProperty("delete")&&Fe.delete()}ft&&(x.C=ft)}))}}),x.i.attachMultiListener(q,ee),q.delete()}n.onResults=function(x,C){this.listeners[C||"$"]=x},I("Solution",rp),I("OptionType",{BOOL:0,NUMBER:1,$:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Yv(x){switch(x===void 0&&(x=0),x){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Kv(x){var C=this;x=x||{},this.g=new rp({locateFile:x.locateFile,files:function(A){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Yv(A.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:np},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:np},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(A){var D,q,ee;return P(function(Z){return Z.g==1?(D=Yv(A),q="third_party/mediapipe/modules/pose_landmark/"+D,_(Z,Qu(C.g,D),2)):(ee=Z.h,C.g.overrideFile(q,ee),Z.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Kv.prototype,n.reset=function(){this.g.reset()},n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(x){this.g.onResults(x)},n.initialize=function(){var x=this;return P(function(C){return _(C,x.g.initialize(),0)})},n.send=function(x,C){var A=this;return P(function(D){return _(D,A.g.send(x,C),0)})},n.setOptions=function(x){this.g.setOptions(x)},I("Pose",Kv),I("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),I("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),I("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),I("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),I("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),I("VERSION","0.5.1635988162")}).call(It);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fI=1e-7,pI=1e-4;class mI{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Kb{refCount(e){return xi("refCount")}incRef(e){return xi("incRef")}timerAvailable(){return!0}time(e){return xi("time")}read(e){return xi("read")}readSync(e){return xi("readSync")}readToGPU(e,t){return xi("readToGPU")}numDataIds(){return xi("numDataIds")}disposeData(e,t){return xi("disposeData")}write(e,t,i){return xi("write")}move(e,t,i,r,s){return xi("move")}memory(){return xi("memory")}floatPrecision(){return xi("floatPrecision")}epsilon(){return this.floatPrecision()===32?fI:pI}dispose(){return xi("dispose")}}function xi(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bd(n,e,t){return Math.max(n,Math.min(e,t))}function Zb(n){return n%2===0?n:n+1}function sc(n,e,t){const i=n[e];n[e]=n[t],n[t]=i}function gI(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function G(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Rr(n,e,t=""){G(ln(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function ly(n){G(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function fl(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||zr(n)&&!t)for(let i=0;i<n.length;++i)fl(n[i],e,t);else e.push(n);return e}function we(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function ln(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Oc(n){return n%1===0}function Mm(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function al(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function n0(n,e=i=>0,t){return new Promise((i,r)=>{let s=0;const o=()=>{if(n()){i();return}s++;const a=e(s);if(t!=null&&s>=t){r();return}setTimeout(o,a)};o()})}function yI(n,e){let t=1,i=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)t*=n[s];else if(n[s]===-1){if(i!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${s}`);i=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(i===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[i]=e/t,r}function Mn(n,e){const t=e.length;return n=n==null?e.map((i,r)=>r):[].concat(n),G(n.every(i=>i>=-t&&i<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),G(n.every(i=>Oc(i)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(i=>i<0?t+i:i)}function ho(n,e){const t=[],i=[],r=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||r?null:Mn(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[o]==null||s[o]>a)&&n[a]===1&&(t.push(n[a]),i.push(a)),s[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),i.push(a))}return{newShape:t,keptDims:i}}function Js(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Gi(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function vI(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${e} being uploaded contains ${i}.`)}}function xI(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function _I(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function zr(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function Am(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function bI(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Sf(n){return typeof n=="string"||n instanceof String}function wI(n){return typeof n=="boolean"}function SI(n){return typeof n=="number"}function Tf(n){return Array.isArray(n)?Tf(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":SI(n)?"float32":Sf(n)?"string":wI(n)?"bool":"float32"}function i0(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Rm(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function kn(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let i=e-3;i>=0;--i)t[i]=t[i+1]*n[i+1];return t}function Jb(n,e,t,i=!1){const r=new Array;if(e.length===1){const s=e[0]*(i?2:1);for(let o=0;o<s;o++)r[o]=t[n+o]}else{const s=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(i?2:1);for(let l=0;l<s;l++)r[l]=Jb(n+l*a,o,t,i)}return r}function Im(n,e,t=!1){if(n.length===0)return e[0];const i=n.reduce((r,s)=>r*s)*(t?2:1);if(i===0)return[];if(i!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Jb(0,n,e,t)}function Qb(n,e){const t=Qs(n,e);for(let i=0;i<t.length;i++)t[i]=1;return t}function Qs(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function e1(n){n.forEach(e=>{G(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Pm(n,e,t){if(e===0)return 0;if(e===1)return n[0];let i=n[n.length-1];for(let r=0;r<n.length-1;++r)i+=t[r]*n[r];return i}function t1(n,e,t){if(e===0)return[];if(e===1)return[n];const i=new Array(e);for(let r=0;r<i.length-1;++r)i[r]=Math.floor(n/t[r]),n-=i[r]*t[r];return i[i.length-1]=n,i}function pl(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r0="tfjsflags";class TI{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=EI,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ne().getBool("IS_TEST")||ne().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,i){if(this.flagRegistry[e]={evaluationFn:t,setHook:i},this.urlFlags[e]!=null){const r=this.urlFlags[e];ne().getBool("IS_TEST")||ne().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(pl(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);r0 in e&&e[r0].split(",").forEach(i=>{const[r,s]=i.split(":");this.urlFlags[r]=MI(r,s)})}}function EI(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...i)=>(CI(e,i[0],i[1]),i.join("="))),e}function CI(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function MI(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function ne(){return n1}let n1=null;function AI(n){n1=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let op;function i1(){if(op==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");op=n}return op}function RI(){const n=i1();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function cy(n,e){const t=RI();if(t.has(n))return t.get(n);{const i=e();return t.set(n,i),t.get(n)}}const r1="Abs",s1="Acos",o1="Acosh",uy="Add",a1="AddN",l1="All",c1="Any",u1="ArgMax",h1="ArgMin",d1="Asin",f1="Asinh",p1="Atan",m1="Atanh",g1="Atan2",y1="AvgPool",II="AvgPoolGrad",v1="AvgPool3D",PI="AvgPool3DGrad",x1="BatchMatMul",_1="BatchToSpaceND",b1="Bincount",w1="BroadcastArgs",hy="Cast",S1="Ceil",T1="ClipByValue",E1="Complex",C1="ComplexAbs",M1="Concat",A1="Conv2D",R1="Conv2DBackpropFilter",I1="Conv2DBackpropInput",P1="Conv3D",NI="Conv3DBackpropFilterV2",LI="Conv3DBackpropInputV2",N1="Cos",L1="Cosh",D1="Cumprod",k1="Cumsum",O1="CropAndResize",F1="DenseBincount",$1="DepthToSpace",B1="DepthwiseConv2dNative",z1="DepthwiseConv2dNativeBackpropFilter",U1="DepthwiseConv2dNativeBackpropInput",DI="Diag",V1="Dilation2D",G1="RealDiv",H1="Einsum",W1="Elu",kI="EluGrad",j1="Erf",q1="Equal",X1="Exp",Y1="ExpandDims",K1="Expm1",Z1="FFT",J1="Fill",Q1="FlipLeftRight",ew="Floor",tw="FloorDiv",nw="FusedBatchNorm",iw="GatherV2",rw="GatherNd",sw="Greater",ow="GreaterEqual",dy="Identity",aw="IFFT",lw="Imag",OI="IsFinite",FI="IsInf",cw="IsNan",uw="LeakyRelu",hw="Less",dw="LessEqual",fw="LinSpace",pw="Log",mw="Log1p",gw="LogicalAnd",yw="LogicalNot",vw="LogicalOr",xw="LRN",$I="LRNGrad",_w="Max",bw="Maximum",ww="MaxPool",BI="MaxPoolGrad",Sw="MaxPool3D",zI="MaxPool3DGrad",Tw="MaxPoolWithArgmax",Ew="Mean",Cw="Min",Mw="Minimum",Aw="MirrorPad",Rw="Mod",Iw="Multinomial",Pw="Multiply",Nw="Neg",Lw="NotEqual",Dw="NonMaxSuppressionV3",kw="NonMaxSuppressionV4",Ow="NonMaxSuppressionV5",Fw="OnesLike",$w="OneHot",Bw="Pack",zw="PadV2",Uw="Pow",Vw="Prelu",Gw="Prod",Hw="Range",Ww="Real",jw="Reciprocal",qw="Relu",Xw="Reshape",Yw="ResizeNearestNeighbor",UI="ResizeNearestNeighborGrad",Kw="ResizeBilinear",VI="ResizeBilinearGrad",Zw="Relu6",Jw="Reverse",Qw="Round",eS="Rsqrt",tS="ScatterNd",nS="SearchSorted",iS="Select",rS="Selu",sS="Slice",oS="Sin",aS="Sinh",lS="Sign",cS="Sigmoid",uS="Softplus",hS="Sqrt",dS="Sum",fS="SpaceToBatchND",pS="SplitV",mS="Softmax",gS="SparseFillEmptyRows",yS="SparseReshape",vS="SparseSegmentMean",xS="SparseSegmentSum",_S="SparseToDense",bS="SquaredDifference",GI="Square",wS="StridedSlice",SS="StringNGrams",TS="StringSplit",ES="StringToHashBucketFast",CS="Sub",MS="Tan",AS="Tanh",fy="Tile",RS="TopK",IS="Transform",od="Transpose",PS="Unique",NS="Unpack",HI="UnsortedSegmentSum",LS="ZerosLike",DS="Step",Nm="FromPixels",kS="RotateWithOffset",Lm="_FusedMatMul",Dm="FusedConv2D",km="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(...n){ne().getBool("IS_TEST")||ne().getBool("PROD")||console.warn(...n)}function WI(...n){ne().getBool("IS_TEST")||ne().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wd=cy("kernelRegistry",()=>new Map),jI=cy("gradRegistry",()=>new Map);function Om(n,e){const t=OS(n,e);return wd.get(t)}function s0(n){return jI.get(n)}function o0(n){const e=wd.entries(),t=[];for(;;){const{done:i,value:r}=e.next();if(i)break;const[s,o]=r,[a]=s.split("_");a===n&&t.push(o)}return t}function qI(n){const{kernelName:e,backendName:t}=n,i=OS(e,t);wd.has(i)&&xr(`The kernel '${e}' for backend '${t}' is already registered`),wd.set(i,n)}function OS(n,e){return`${e}_${n}`}var Fm=Ht,Hi=null;try{Hi=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Ht(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Ht.prototype.__isLong__;Object.defineProperty(Ht.prototype,"__isLong__",{value:!0});function gi(n){return(n&&n.__isLong__)===!0}Ht.isLong=gi;var a0={},l0={};function ga(n,e){var t,i,r;return e?(n>>>=0,(r=0<=n&&n<256)&&(i=l0[n],i)?i:(t=Wt(n,(n|0)<0?-1:0,!0),r&&(l0[n]=t),t)):(n|=0,(r=-128<=n&&n<128)&&(i=a0[n],i)?i:(t=Wt(n,n<0?-1:0,!1),r&&(a0[n]=t),t))}Ht.fromInt=ga;function Wi(n,e){if(isNaN(n))return e?ko:ji;if(e){if(n<0)return ko;if(n>=FS)return zS}else{if(n<=-u0)return hi;if(n+1>=u0)return BS}return n<0?Wi(-n,e).neg():Wt(n%ml|0,n/ml|0,e)}Ht.fromNumber=Wi;function Wt(n,e,t){return new Ht(n,e,t)}Ht.fromBits=Wt;var Sd=Math.pow;function py(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return ji;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var i;if((i=n.indexOf("-"))>0)throw Error("interior hyphen");if(i===0)return py(n.substring(1),e,t).neg();for(var r=Wi(Sd(t,8)),s=ji,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=Wi(Sd(t,a));s=s.mul(c).add(Wi(l))}else s=s.mul(r),s=s.add(Wi(l))}return s.unsigned=e,s}Ht.fromString=py;function Ir(n,e){return typeof n=="number"?Wi(n,e):typeof n=="string"?py(n,e):Wt(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Ht.fromValue=Ir;var c0=1<<16,XI=1<<24,ml=c0*c0,FS=ml*ml,u0=FS/2,h0=ga(XI),ji=ga(0);Ht.ZERO=ji;var ko=ga(0,!0);Ht.UZERO=ko;var il=ga(1);Ht.ONE=il;var $S=ga(1,!0);Ht.UONE=$S;var $m=ga(-1);Ht.NEG_ONE=$m;var BS=Wt(-1,2147483647,!1);Ht.MAX_VALUE=BS;var zS=Wt(-1,-1,!0);Ht.MAX_UNSIGNED_VALUE=zS;var hi=Wt(0,-2147483648,!1);Ht.MIN_VALUE=hi;var Te=Ht.prototype;Te.toInt=function(){return this.unsigned?this.low>>>0:this.low};Te.toNumber=function(){return this.unsigned?(this.high>>>0)*ml+(this.low>>>0):this.high*ml+(this.low>>>0)};Te.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(hi)){var t=Wi(e),i=this.div(t),r=i.mul(t).sub(this);return i.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Wi(Sd(e,6),this.unsigned),o=this,a="";;){var l=o.div(s),c=o.sub(l.mul(s)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};Te.getHighBits=function(){return this.high};Te.getHighBitsUnsigned=function(){return this.high>>>0};Te.getLowBits=function(){return this.low};Te.getLowBitsUnsigned=function(){return this.low>>>0};Te.getNumBitsAbs=function(){if(this.isNegative())return this.eq(hi)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};Te.isZero=function(){return this.high===0&&this.low===0};Te.eqz=Te.isZero;Te.isNegative=function(){return!this.unsigned&&this.high<0};Te.isPositive=function(){return this.unsigned||this.high>=0};Te.isOdd=function(){return(this.low&1)===1};Te.isEven=function(){return(this.low&1)===0};Te.equals=function(e){return gi(e)||(e=Ir(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Te.eq=Te.equals;Te.notEquals=function(e){return!this.eq(e)};Te.neq=Te.notEquals;Te.ne=Te.notEquals;Te.lessThan=function(e){return this.comp(e)<0};Te.lt=Te.lessThan;Te.lessThanOrEqual=function(e){return this.comp(e)<=0};Te.lte=Te.lessThanOrEqual;Te.le=Te.lessThanOrEqual;Te.greaterThan=function(e){return this.comp(e)>0};Te.gt=Te.greaterThan;Te.greaterThanOrEqual=function(e){return this.comp(e)>=0};Te.gte=Te.greaterThanOrEqual;Te.ge=Te.greaterThanOrEqual;Te.compare=function(e){if(gi(e)||(e=Ir(e)),this.eq(e))return 0;var t=this.isNegative(),i=e.isNegative();return t&&!i?-1:!t&&i?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Te.comp=Te.compare;Te.negate=function(){return!this.unsigned&&this.eq(hi)?hi:this.not().add(il)};Te.neg=Te.negate;Te.add=function(e){gi(e)||(e=Ir(e));var t=this.high>>>16,i=this.high&65535,r=this.low>>>16,s=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,d=0,f=0;return f+=s+c,d+=f>>>16,f&=65535,d+=r+l,h+=d>>>16,d&=65535,h+=i+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,Wt(d<<16|f,u<<16|h,this.unsigned)};Te.subtract=function(e){return gi(e)||(e=Ir(e)),this.add(e.neg())};Te.sub=Te.subtract;Te.multiply=function(e){if(this.isZero())return ji;if(gi(e)||(e=Ir(e)),Hi){var t=Hi.mul(this.low,this.high,e.low,e.high);return Wt(t,Hi.get_high(),this.unsigned)}if(e.isZero())return ji;if(this.eq(hi))return e.isOdd()?hi:ji;if(e.eq(hi))return this.isOdd()?hi:ji;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(h0)&&e.lt(h0))return Wi(this.toNumber()*e.toNumber(),this.unsigned);var i=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,d=0,f=0,p=0;return p+=o*u,f+=p>>>16,p&=65535,f+=s*u,d+=f>>>16,f&=65535,f+=o*c,d+=f>>>16,f&=65535,d+=r*u,h+=d>>>16,d&=65535,d+=s*c,h+=d>>>16,d&=65535,d+=o*l,h+=d>>>16,d&=65535,h+=i*u+r*c+s*l+o*a,h&=65535,Wt(f<<16|p,h<<16|d,this.unsigned)};Te.mul=Te.multiply;Te.divide=function(e){if(gi(e)||(e=Ir(e)),e.isZero())throw Error("division by zero");if(Hi){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Hi.div_u:Hi.div_s)(this.low,this.high,e.low,e.high);return Wt(t,Hi.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ko:ji;var i,r,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ko;if(e.gt(this.shru(1)))return $S;s=ko}else{if(this.eq(hi)){if(e.eq(il)||e.eq($m))return hi;if(e.eq(hi))return il;var o=this.shr(1);return i=o.div(e).shl(1),i.eq(ji)?e.isNegative()?il:$m:(r=this.sub(e.mul(i)),s=i.add(r.div(e)),s)}else if(e.eq(hi))return this.unsigned?ko:ji;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=ji}for(r=this;r.gte(e);){i=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(i)/Math.LN2),l=a<=48?1:Sd(2,a-48),c=Wi(i),u=c.mul(e);u.isNegative()||u.gt(r);)i-=l,c=Wi(i,this.unsigned),u=c.mul(e);c.isZero()&&(c=il),s=s.add(c),r=r.sub(u)}return s};Te.div=Te.divide;Te.modulo=function(e){if(gi(e)||(e=Ir(e)),Hi){var t=(this.unsigned?Hi.rem_u:Hi.rem_s)(this.low,this.high,e.low,e.high);return Wt(t,Hi.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Te.mod=Te.modulo;Te.rem=Te.modulo;Te.not=function(){return Wt(~this.low,~this.high,this.unsigned)};Te.and=function(e){return gi(e)||(e=Ir(e)),Wt(this.low&e.low,this.high&e.high,this.unsigned)};Te.or=function(e){return gi(e)||(e=Ir(e)),Wt(this.low|e.low,this.high|e.high,this.unsigned)};Te.xor=function(e){return gi(e)||(e=Ir(e)),Wt(this.low^e.low,this.high^e.high,this.unsigned)};Te.shiftLeft=function(e){return gi(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Wt(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Wt(0,this.low<<e-32,this.unsigned)};Te.shl=Te.shiftLeft;Te.shiftRight=function(e){return gi(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Wt(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Wt(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Te.shr=Te.shiftRight;Te.shiftRightUnsigned=function(e){if(gi(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var i=this.low;return Wt(i>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Wt(t,0,this.unsigned):Wt(t>>>e-32,0,this.unsigned)};Te.shru=Te.shiftRightUnsigned;Te.shr_u=Te.shiftRightUnsigned;Te.toSigned=function(){return this.unsigned?Wt(this.low,this.high,!1):this};Te.toUnsigned=function(){return this.unsigned?this:Wt(this.low,this.high,!0)};Te.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Te.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Te.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Ht.fromBytes=function(e,t,i){return i?Ht.fromBytesLE(e,t):Ht.fromBytesBE(e,t)};Ht.fromBytesLE=function(e,t){return new Ht(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Ht.fromBytesBE=function(e,t){return new Ht(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};var YI=Xb({__proto__:null,default:Fm},[Fm]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po=Fm||YI;function Ef(n){return Po.fromString(n,!0,16)}const US=Ef("c3a5c85c97cb3127"),Ao=Ef("b492b66fbe98f273"),Hn=Ef("9ae16a3b2f90404f");function Bm(n){return n.xor(n.shru(47))}function VS(n,e,t){const i=n.slice(e,e+t);return Po.fromBytes(Array.from(i),!0,!0)}function zt(n,e){return VS(n,e,8)}function d0(n,e){return VS(n,e,4)}function _n(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Hs(n,e,t=Ef("9ddfea08eb382d69")){let i=n.xor(e).mul(t);i=i.xor(i.shru(47));let r=e.xor(i).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function KI(n,e,t,i,r,s){r=r.add(n),s=_n(s.add(r).add(i),21);const o=r;return r=r.add(e),r=r.add(t),s=s.add(_n(r,44)),[r.add(i),s.add(o)]}function th(n,e,t,i){return KI(zt(n,e),zt(n,e+8),zt(n,e+16),zt(n,e+24),t,i)}function ZI(n,e=n.length){if(e>=8){const t=Hn.add(e*2),i=zt(n,0).add(Hn),r=zt(n,e-8),s=_n(r,37).mul(t).add(i),o=_n(i,25).add(r).mul(t);return Hs(s,o,t)}if(e>=4){const t=Hn.add(e*2),i=d0(n,0);return Hs(i.shl(3).add(e),d0(n,e-4),t)}if(e>0){const t=n[0],i=n[e>>1],r=n[e-1],s=t+(i<<8),o=e+(r<<2);return Bm(Hn.mul(s).xor(US.mul(o))).mul(Hn)}return Hn}function JI(n,e=n.length){const t=Hn.add(e*2),i=zt(n,0).mul(Ao),r=zt(n,8),s=zt(n,e-8).mul(t),o=zt(n,e-16).mul(Hn);return Hs(_n(i.add(r),43).add(_n(s,30)).add(o),i.add(_n(r.add(Hn),18)).add(s),t)}function QI(n,e=n.length){const t=Hn.add(e*2),i=zt(n,0).mul(Hn),r=zt(n,8),s=zt(n,e-8).mul(t),o=zt(n,e-16).mul(Hn),a=_n(i.add(r),43).add(_n(s,30)).add(o),l=Hs(a,i.add(_n(r.add(Hn),18)).add(s),t),c=zt(n,16).mul(t),u=zt(n,24),h=a.add(zt(n,e-32)).mul(t),d=l.add(zt(n,e-24)).mul(t);return Hs(_n(c.add(u),43).add(_n(h,30)).add(d),c.add(_n(u.add(i),18)).add(h),t)}function eP(n,e=n.length){const t=Po.fromNumber(81,!0);if(e<=32)return e<=16?ZI(n,e):JI(n,e);if(e<=64)return QI(n,e);let i=t,r=t.mul(Ao).add(113),s=Bm(r.mul(Hn).add(113)).mul(Hn),o=[Po.UZERO,Po.UZERO],a=[Po.UZERO,Po.UZERO];i=i.mul(Hn).add(zt(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do i=_n(i.add(r).add(o[0]).add(zt(n,l+8)),37).mul(Ao),r=_n(r.add(o[1]).add(zt(n,l+48)),42).mul(Ao),i=i.xor(a[1]),r=r.add(o[0]).add(zt(n,l+40)),s=_n(s.add(a[0]),33).mul(Ao),o=th(n,l,o[1].mul(Ao),i.add(a[0])),a=th(n,l+32,s.add(a[1]),r.add(zt(n,l+16))),[s,i]=[i,s],l+=64;while(l!==c);const h=Ao.add(s.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),i=_n(i.add(r).add(o[0]).add(zt(n,l+8)),37).mul(h),r=_n(r.add(o[1]).add(zt(n,l+48)),42).mul(h),i=i.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(zt(n,l+40))),s=_n(s.add(a[0]),33).mul(h),o=th(n,l,o[1].mul(h),i.add(a[0])),a=th(n,l+32,s.add(a[1]),r.add(zt(n,l+16))),[s,i]=[i,s],Hs(Hs(o[0],a[0],h).add(Bm(r).mul(US)).add(s),Hs(o[1],a[1],h).add(i),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(n,e){return e==="string"?Go(n):my([n],e)}function tP(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function my(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=fl(n)),ne().getBool("DEBUG")&&vI(n,e),tP(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let i=0;i<t.length;++i)Math.round(n[i])!==0&&(t[i]=1);return t}else throw new Error(`Unknown data type ${e}`)}function mr(){return ne().platform.now()}function Go(n,e="utf-8"){return e=e||"utf-8",ne().platform.encode(n,e)}function gl(n,e="utf-8"){return e=e||"utf-8",ne().platform.decode(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nP{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new rP)}profileKernel(e,t,i){let r;const s=()=>{r=i()};let o;const a=mr();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:mr()-a})}if(ne().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const u=r[c];u.data().then(h=>{iP(h,u.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:i,timeMs:r,inputs:s,extraInfo:o}=e;i.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],s,l[2])})})}}function iP(n,e,t){if(e!=="float32")return!1;for(let i=0;i<n.length;i++){const r=n[i];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class rP{logKernelProfile(e,t,i,r,s,o){const a=typeof r=="number"?al(`${r}ms`,9):r.error,l=al(e,25),c=t.rank,u=t.size,h=al(t.shape.toString(),14);let d="";for(const f in s){const p=s[f];if(p!=null){const m=p.shape||t.shape,y=m.length;d+=`${f}: ${y}D ${y>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sP(n,e,t){const i={},r={};for(let l=0;l<e.length;l++)i[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const d=u[h];let f=!1;for(let p=0;p<e.length;p++)if(i[d.id]){c.outputs.forEach(m=>i[m.id]=!0),f=!0,r[c.id]=!0;break}if(f)break}}const s={};s[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(s[c.outputs[h].id]){for(const d in u)s[u[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&o[c.id]){const u={};for(const d in c.inputs){const f=c.inputs[d];i[f.id]&&(u[d]=f)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function oP(n,e,t,i){for(let r=e.length-1;r>=0;r--){const s=e[r],o=[];if(s.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=s.inputs[l];if(!ln(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=i(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0=20,oc=3,ap=7;function aP(n,e,t,i){const r=kn(e),s=lP(n,e,t,r),o=e.length,a=ad(n,e,t,r,s),l=["Tensor"];return i&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function lP(n,e,t,i){const r=we(e),s=i[i.length-1],o=new Array(s).fill(0),a=e.length,l=t==="complex64"?Sc(n):n;if(a>1)for(let c=0;c<r/s;c++){const u=c*s;for(let h=0;h<s;h++)o[h]=Math.max(o[h],wc(l[u+h],0,t).length)}return o}function wc(n,e,t){let i;return Array.isArray(n)?i=`${parseFloat(n[0].toFixed(ap))} + ${parseFloat(n[1].toFixed(ap))}j`:Sf(n)?i=`'${n}'`:t==="bool"?i=GS(n):i=parseFloat(n.toFixed(ap)).toString(),al(i,e)}function GS(n){return n===0?"false":"true"}function ad(n,e,t,i,r,s=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=Sc(n);return[wc(m[0],0,t)]}return t==="bool"?[GS(n[0])]:[n[0].toString()]}if(l===1){if(a>f0){const y=oc*o;let g=Array.from(n.slice(0,y)),v=Array.from(n.slice((a-oc)*o,a*o));return t==="complex64"&&(g=Sc(g),v=Sc(v)),["["+g.map((_,b)=>wc(_,r[b],t)).join(", ")+", ..., "+v.map((_,b)=>wc(_,r[a-oc+b],t)).join(", ")+"]"]}const m=t==="complex64"?Sc(n):Array.from(n);return["["+m.map((y,g)=>wc(y,r[g],t)).join(", ")+"]"]}const c=e.slice(1),u=i.slice(1),h=i[0]*o,d=[];if(a>f0){for(let m=0;m<oc;m++){const y=m*h,g=y+h;d.push(...ad(n.slice(y,g),c,t,u,r,!1))}d.push("...");for(let m=a-oc;m<a;m++){const y=m*h,g=y+h;d.push(...ad(n.slice(y,g),c,t,u,r,m===a-1))}}else for(let m=0;m<a;m++){const y=m*h,g=y+h;d.push(...ad(n.slice(y,g),c,t,u,r,m===a-1))}const f=l===2?",":"";d[0]="["+d[0]+f;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+f;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":p),d}function Sc(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fc{constructor(e,t,i){if(this.dtype=t,this.shape=e.slice(),this.size=we(e),i!=null){const r=i.length;G(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=i||Gi(t,this.size),this.strides=kn(e)}set(e,...t){t.length===0&&(t=[0]),G(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const i=this.locToIndex(t);this.values[i]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let i=e[e.length-1];for(let r=0;r<e.length-1;++r)i+=this.strides[r]*e[r];return this.values[i]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let i=0;i<e.length-1;++i)t+=this.strides[i]*e[i];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let i=0;i<t.length-1;++i)t[i]=Math.floor(e/this.strides[i]),e-=t[i]*this.strides[i];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return gr().makeTensor(this.values,this.shape,this.dtype)}}let gr=null,el=null;function cP(n){gr=n}function uP(n){el=n}class dn{constructor(e,t,i,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=we(e),this.strides=kn(e),this.dataId=i,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return el.buffer(this.shape,this.dtype,e)}bufferSync(){return el.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Im(this.shape,e,this.dtype==="complex64")}arraySync(){return Im(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=gr().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(i=>gl(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),gr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=gr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>gl(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await gr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(gr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return el.print(this,e)}clone(){return this.throwIfDisposed(),el.clone(this)}toString(e=!1){const t=this.dataSync();return aP(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),el.cast(this,e)}variable(e=!0,t,i){return this.throwIfDisposed(),gr().makeVariable(this,e,t,i)}}Object.defineProperty(dn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function hP(){return cy("Tensor",()=>dn)}hP();class zm extends dn{constructor(e,t,i,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=i}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ln(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);gr().disposeTensor(this),this.dataId=e.dataId,gr().incRef(this,null)}dispose(){gr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(zm,Symbol.hasInstance,{value:n=>n instanceof dn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var p0;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(p0||(p0={}));var Um;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Um||(Um={}));var Vm;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Vm||(Vm={}));var Gm;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Gm||(Gm={}));var Hm;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Hm||(Hm={}));const dP={float32:Gm,int32:Um,bool:Vm,complex64:Hm};function Ur(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return dP[n][e]}function gy(n){return Ur(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tn(n,e){if(n.dtype===e.dtype)return[n,e];const t=Ur(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function HS(n){const e=[];return WS(n,e,new Set),e}function WS(n,e,t){if(n==null)return;if(n instanceof dn){e.push(n);return}if(!fP(n))return;const i=n;for(const r in i){const s=i[r];t.has(s)||(t.add(s),WS(s,e,t))}}function fP(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lp(n){return n.kernelName!=null}class m0{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class yl{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new m0}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const i=e[t];if(await this.initializeBackend(i).success){await this.setBackend(i);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,i=1){return e in this.registryFactory?(xr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:i},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:i}=this.initializeBackend(e);if(!(i?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new nP(this.backendInstance),!0}setupRegisteredKernels(){o0(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){o0(e).forEach(i=>{i.disposeFunc!=null&&i.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const i=t.factory();if(i&&!(i instanceof Kb)&&typeof i.then=="function"){const r=++this.pendingBackendInitId,s=i.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,xr(`Initialization of backend ${e} failed`),xr(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=i,{success:!0,asyncInit:!1}}catch(i){return xr(`Initialization of backend ${e} failed`),xr(i.stack||i.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const i=e[t],{success:r,asyncInit:s}=this.initializeBackend(i);if(s||r)return{name:i,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const i=this.state.tensorInfo.get(t),r=i.backend,s=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),i.backend=e,e.move(t,s,i.shape,i.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let i=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=e}let r;return this.scopedRun(()=>this.startScope(i),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,i){e();try{const r=i();return t(),r}catch(r){throw t(),r}}nextTensorId(){return yl.nextTensorId++}nextVariableId(){return yl.nextVariableId++}clone(e){const t=Y.runKernel(dy,{x:e}),i={x:e},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return Y.runKernel(hy,l,c)}}),s=[];return this.addTapeNode(this.state.activeScope.name,i,[t],r,s,{}),t}runKernel(e,t,i){if(this.backendName==null&&this.backend,!(Om(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:i})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,i){const r=this.backend.numDataIds();let s=0;i.forEach(l=>{s+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,i=[];const r=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=lp(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(lp(e)){const{kernelName:p,inputs:m,attrs:y}=e;this.backendName==null&&this.backend;const g=Om(p,this.backendName);G(g!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const v=this.backend.numDataIds();l=g.kernelFunc({inputs:m,attrs:y,backend:this.backend});const _=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,v,_);const b=_.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(r){const S=this.getTensorsForGradient(p,m,b);i=this.saveTensorsForBackwardMode(S)}return b}}else{const{forwardFunc:p}=e,m=y=>{!r||(i=y.map(g=>this.keep(this.clone(g))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const g=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,g),g}}const{inputs:u,attrs:h}=e,d=lp(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(f=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),r&&this.addTapeNode(c,u,t,d,i,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(i=>this.keep(this.clone(i)))}getTensorsForGradient(e,t,i){const r=s0(e);if(r!=null){const s=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(G(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=s.map(c=>t[c]);const l=i.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,i,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");i=i||"float32",r=r||this.backend;let s=e;i==="string"&&Sf(e[0])&&(s=e.map(l=>Go(l)));const o=r.write(s,t,i),a=new dn(t,i,o,this.nextTensorId());if(this.trackTensor(a,r),i==="string"){const l=this.state.tensorInfo.get(o),c=bI(s);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,i,r){i=i||"float32";const s={dataId:e,shape:t,dtype:i};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:i,shape:r,dtype:s}=e,o=new dn(r,s,i,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,i,r){i=i||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const s=new zm(e,t,i,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let i=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(i=e.size*Am(e.dtype)),this.state.numBytes+=i,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:i})),e instanceof zm||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const i=e.size*Am(e.dtype);this.state.numBytes-=i}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,i=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-i;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,i,r,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:i,saved:s},l=s0(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const d=i[h],f=Qs(d.size,d.dtype);return this.makeTensor(f,d.shape,d.dtype)}return u}),r(c.length>1?c:c[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=HS(e),i=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!i.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(e,t,i,r=!1){if(G(t.length>0,()=>"gradients() received an empty list of xs."),i!=null&&i.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${i.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));G(s instanceof dn,()=>"The result y returned by f() must be a tensor.");const o=sP(this.state.activeTape,t,s);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[s.id]=i==null?pP(s.shape):i,oP(a,o,c=>this.tidy(c),mP);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return G(i0(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{G(t.every(a=>a instanceof dn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let i;const r={};t.forEach((a,l)=>{r[l]=a});const s=(a,l)=>(i=e(...t,l),G(i.value instanceof dn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),G(i0(i.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),i.value),o=(a,l)=>{const c=i.gradFunc(a,l),u=Array.isArray(c)?c:[c];G(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),G(u.every(d=>d instanceof dn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,f)=>{h[f]=()=>d}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=mr(),i=await this.backend.time(e);return i.wallMs=mr()-t,i}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new m0;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}yl.nextTensorId=0;yl.nextVariableId=0;function pP(n){const e=Qb(we(n),"float32");return Y.makeTensor(e,n,"float32")}function jS(){const n=i1();if(n._tfengine==null){const e=new TI(n);n._tfengine=new yl(e)}return AI(n._tfengine.ENV),cP(()=>n._tfengine),n._tfengine}const Y=jS();function mP(n,e){const t={a:n,b:e};return Y.runKernel(uy,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gP(){return typeof navigator!="undefined"&&navigator!=null}function qS(n){if(n||gP()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function XS(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yi=ne();Yi.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Yi.registerFlag("IS_BROWSER",()=>XS());Yi.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Yi.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Yi.registerFlag("PROD",()=>!1);Yi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Yi.getBool("DEBUG"));Yi.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Yi.registerFlag("IS_TEST",()=>!1);Yi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Yi.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Yi.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(n,e){let t=n;if(zr(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const i=[];for(;Array.isArray(t)||zr(t)&&e!=="string";)i.push(t.length),t=t[0];return Array.isArray(n)&&ne().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&YS(n,i,[]),i}function YS(n,e,t){if(t=t||[],!Array.isArray(n)&&!zr(n)){G(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}G(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),G(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const i=e.slice(1);for(let r=0;r<n.length;++r)YS(n[r],i,t.concat(r))}function g0(n,e,t,i){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${i}' must be ${n} tensor, but got ${e} tensor`)}}function U(n,e,t,i="numeric"){if(n instanceof dn)return g0(i,n.dtype,e,t),n;let r=Tf(n);if(r!=="string"&&["bool","int32","float32"].indexOf(i)>=0&&(r=i),g0(i,r,e,t),n==null||!zr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const s=Mu(n,r);!zr(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?my(n,r):fl(n,[],!0);return Y.makeTensor(a,s,r)}function KS(n,e,t,i="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,o)=>U(s,`${e}[${o}]`,t,i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP="__op";function K(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const i=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+yP;const r=(...s)=>{Y.startScope(t);try{const o=i(...s);return pl(o)&&console.error("Cannot return a Promise inside of tidy."),Y.endScope(o),o}catch(o){throw Y.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(n,e){const t=U(n,"real","complex"),i=U(e,"imag","complex");Rr(t.shape,i.shape,`real and imag shapes, ${t.shape} and ${i.shape}, must match in call to tf.complex().`);const r={real:t,imag:i};return Y.runKernel(E1,r)}const eo=K({complex_:vP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(n,e,t,i){if(i==null&&(i=Tf(n)),i==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!zr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){e1(e);const r=we(e),s=we(t);G(r===s,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${s}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==we(e.slice(o)):!0;G(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!zr(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=i!=="string"?my(n,i):fl(n,[],!0),Y.makeTensor(n,e,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(n,e,t){const i=Mu(n,t);return Au(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0=4;function xP(n,e){const t={};let i,r=0;for(const s of e){const o=s.name,a=s.dtype,l=s.shape,c=we(l);let u;if("quantization"in s){const h=s.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${s.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=y0[h.dtype],f=n.slice(r,r+c*d),p=h.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){u=new Float32Array(p.length);for(let m=0;m<p.length;m++){const y=p[m];u[m]=y*h.scale+h.min}}else if(h.dtype==="float16")i===void 0&&(i=MP()),u=i(p);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(a==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);u=new Int32Array(p.length);for(let m=0;m<p.length;m++){const y=p[m];u[m]=Math.round(y*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*d}else if(a==="string"){const h=we(s.shape);u=[];for(let d=0;d<h;d++){const f=new Uint32Array(n.slice(r,r+v0))[0];r+=v0;const p=new Uint8Array(n.slice(r,r+f));u.push(p),r+=f}}else{const h=y0[a],d=n.slice(r,r+c*h);if(a==="float32")u=new Float32Array(d);else if(a==="int32")u=new Int32Array(d);else if(a==="bool")u=new Uint8Array(d);else if(a==="complex64"){u=new Float32Array(d);const f=new Float32Array(u.length/2),p=new Float32Array(u.length/2);for(let g=0;g<f.length;g++)f[g]=u[g*2],p[g]=u[g*2+1];const m=Ws(f,l,"float32"),y=Ws(p,l,"float32");t[o]=eo(m,y),m.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*h}a!=="complex64"&&(t[o]=Ws(u,l,a))}return t}const yy=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function x0(n){return yy?Buffer.byteLength(n):new Blob([n]).size}function _P(n){if(yy)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let i=0,r=e.length;i<r;i++)t+=String.fromCharCode(e[i]);return btoa(t)}function bP(n){if(yy){const i=Buffer.from(n,"base64");return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let i=0;i<e.length;++i)t.set([e.charCodeAt(i)],i);return t.buffer}function wP(n){if(n.length===1)return n[0];let e=0;n.forEach(r=>{e+=r.byteLength});const t=new Uint8Array(e);let i=0;return n.forEach(r=>{t.set(new Uint8Array(r),i),i+=r.byteLength}),t.buffer}function ZS(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}async function SP(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),n.weightsManifest!=null){const[i,r]=await e(n.weightsManifest);t.weightSpecs=i,t.weightData=r}return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),t}function Cf(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:x0(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:x0(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function TP(){const n=t=>{let i=t<<13,r=0;for(;(i&8388608)===0;)r-=8388608,i<<=1;return i&=-8388609,r+=947912704,i|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function EP(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function CP(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function MP(){const n=TP(),e=EP(),t=CP();return i=>{const r=new ArrayBuffer(4*i.length),s=new Uint32Array(r);for(let o=0;o<i.length;o++){const a=i[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];s[o]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return hn.instance==null&&(hn.instance=new hn),hn.instance}static registerSaveRouter(e){hn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){hn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return hn.getHandlers(e,"save")}static getLoadHandlers(e,t){return hn.getHandlers(e,"load",t)}static getHandlers(e,t,i){const r=[];return(t==="load"?hn.getInstance().loadRouters:hn.getInstance().saveRouters).forEach(o=>{const a=o(e,i);a!==null&&r.push(a)}),r}}const AP=n=>hn.getSaveHandlers(n),RP=(n,e)=>hn.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wm="tensorflowjs",jm=1,Oo="models_store",Bs="model_info_store";function JS(){if(!ne().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window=="undefined"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function qm(n){const e=n.result;e.createObjectStore(Oo,{keyPath:"modelPath"}),e.createObjectStore(Bs,{keyPath:"modelPath"})}class Ko{constructor(e){if(this.indexedDB=JS(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((i,r)=>{const s=this.indexedDB.open(Wm,jm);s.onupgradeneeded=()=>qm(s),s.onsuccess=()=>{const o=s.result;if(t==null){const a=o.transaction(Oo,"readonly"),c=a.objectStore(Oo).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));i(c.result.modelArtifacts)},c.onerror=u=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{const a=Cf(t),l=o.transaction(Bs,"readwrite");let c=l.objectStore(Bs);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;u.onsuccess=()=>{h=o.transaction(Oo,"readwrite");const f=h.objectStore(Oo).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});f.onsuccess=()=>i({modelArtifactsInfo:a}),f.onerror=p=>{c=l.objectStore(Bs);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),r(f.error)),m.onerror=y=>(o.close(),r(f.error))}},u.onerror=d=>(o.close(),r(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},s.onerror=o=>r(s.error)})}}Ko.URL_SCHEME="indexeddb://";const QS=n=>ne().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ko.URL_SCHEME)?IP(n.slice(Ko.URL_SCHEME.length)):null;hn.registerSaveRouter(QS);hn.registerLoadRouter(QS);function IP(n){return new Ko(n)}function PP(n){return n.startsWith(Ko.URL_SCHEME)?n.slice(Ko.URL_SCHEME.length):n}class NP{constructor(){this.indexedDB=JS()}async listModels(){return new Promise((e,t)=>{const i=this.indexedDB.open(Wm,jm);i.onupgradeneeded=()=>qm(i),i.onsuccess=()=>{const r=i.result,s=r.transaction(Bs,"readonly"),a=s.objectStore(Bs).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},i.onerror=r=>t(i.error)})}async removeModel(e){return e=PP(e),new Promise((t,i)=>{const r=this.indexedDB.open(Wm,jm);r.onupgradeneeded=()=>qm(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(Bs,"readwrite"),a=o.objectStore(Bs),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return s.close(),i(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=s.transaction(Oo,"readwrite");const f=c.objectStore(Oo).delete(e);f.onsuccess=()=>t(l.result.modelArtifactsInfo),f.onerror=p=>i(l.error)};u.onsuccess=h,u.onerror=d=>(h(),s.close(),i(l.error))}},l.onerror=u=>(s.close(),i(l.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}},r.onerror=s=>i(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const as="/",tl="tensorflowjs_models",eT="info",LP="model_topology",DP="weight_specs",kP="weight_data",OP="model_metadata";function tT(n){return{info:[tl,n,eT].join(as),topology:[tl,n,LP].join(as),weightSpecs:[tl,n,DP].join(as),weightData:[tl,n,kP].join(as),modelMetadata:[tl,n,OP].join(as)}}function nT(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function FP(n){const e=n.split(as);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(as)}function $P(n){return n.startsWith(Zo.URL_SCHEME)?n.slice(Zo.URL_SCHEME.length):n}class Zo{constructor(e){if(!ne().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=tT(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),r=Cf(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,i),this.LS.setItem(this.keys.weightData,_P(e.weightData));const s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw nT(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},i=JSON.parse(this.LS.getItem(this.keys.topology));if(i==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=i;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=bP(o),t}}Zo.URL_SCHEME="localstorage://";const iT=n=>ne().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Zo.URL_SCHEME)?BP(n.slice(Zo.URL_SCHEME.length)):null;hn.registerSaveRouter(iT);hn.registerLoadRouter(iT);function BP(n){return new Zo(n)}class zP{constructor(){G(ne().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),G(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=tl+as,i=as+eT;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(i)){const o=FP(s);e[o]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=$P(e);const t=tT(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const i=JSON.parse(this.LS.getItem(t.info));return nT(t),i}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0="://";class $s{constructor(){this.managers={}}static getInstance(){return $s.instance==null&&($s.instance=new $s),$s.instance}static registerManager(e,t){G(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(_0)&&(e=e.slice(0,e.indexOf(_0))),G(e.length>0,()=>"scheme must not be an empty string.");const i=$s.getInstance();G(i.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),i.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UP{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(ne().get("IS_BROWSER")){ne().setPlatform("browser",new UP);try{$s.registerManager(Zo.URL_SCHEME,new zP)}catch{}try{$s.registerManager(Ko.URL_SCHEME,new NP)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VP={importFetch:()=>require("node-fetch")};let cp;class GP{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ne().global.fetch!=null?ne().global.fetch(e,t):(cp==null&&(cp=VP.importFetch()),cp(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}ne().get("IS_NODE")&&!ne().get("IS_BROWSER")&&ne().setPlatform("node",new GP);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(n,e="float32",t){return e=e||"float32",e1(n),new Fc(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HP(n,e){const t=U(n,"x","cast");if(!xI(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const i={x:t},r={dtype:e};return Y.runKernel(hy,i,r)}const Ft=K({cast_:HP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(n){const t={x:U(n,"x","clone","string_or_numeric")};return Y.runKernel(dy,t)}const Ho=K({clone_:WP});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jS();const qP={buffer:cn,cast:Ft,clone:Ho,print:jP};uP(qP);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XP="model",YP=".json",KP=".weights.bin";function b0(n){return new Promise(e=>setTimeout(e)).then(n)}class Jo{constructor(e){if(!ne().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Jo.URL_SCHEME)&&(e=e.slice(Jo.URL_SCHEME.length)),(e==null||e.length===0)&&(e=XP),this.modelJsonFileName=e+YP,this.weightDataFileName=e+KP}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=ZS(e,i),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await b0(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await b0(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Cf(e)}}}}Jo.URL_SCHEME="downloads://";const ZP=n=>ne().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Jo.URL_SCHEME)?JP(n.slice(Jo.URL_SCHEME.length)):null;hn.registerSaveRouter(ZP);function JP(n="model"){return new Jo(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0(n,e,t,i){o(n),t=t==null?0:t,i=i==null?1:i,a(t,i);let r=0;const s=l=>(l.then(c=>{const u=t+ ++r/n.length*(i-t);return e(u),c}),l);function o(l){G(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){G(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),G(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),G(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function QP(n,e){e==null&&(e={});const t=e.fetchFunc==null?ne().platform.fetch:e.fetchFunc,i=n.map(h=>t(h,e.requestInit,{isBinary:!0})),r=0,s=.5,a=(e.onProgress==null?await Promise.all(i):await w0(i,e.onProgress,r,s)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await w0(a,e.onProgress,l,c)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eN="application/octet-stream",tN="application/json";class vy{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(G(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ne().platform.fetch,G(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&G(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const i=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=ZS(e,i);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:tN}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:eN}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Cf(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const i=t.modelTopology,r=t.weightsManifest;if(i==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return SP(t,s=>this.loadWeights(s))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[i,r]=nN(t),s=this.weightPathPrefix||i,o=[];for(const u of e)o.push(...u.weights);const a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(s+h+r);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await QP(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,wP(c)]}}vy.URL_SCHEME_REGEX=/^https?:\/\//;function nN(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),i=n.substring(0,e),r=t>e?n.substring(t):"";return[i+"/",r]}function S0(n){return n.match(vy.URL_SCHEME_REGEX)!=null}const rT=(n,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(i=>S0(i)):t=S0(n),t)return sT(n,e)}return null};hn.registerSaveRouter(rT);hn.registerLoadRouter(rT);function sT(n,e){return new vy(n,e)}function T0(n,e){return sT(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(n,e,t=!1,i=!1){let r=U(n,"a","matMul"),s=U(e,"b","matMul");[r,s]=tn(r,s);const o={a:r,b:s},a={transposeA:t,transposeB:i};return Y.runKernel(x1,o,a)}const xn=K({matMul_:iN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n,e,t=1,i=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:U(n,"indices","oneHot","int32")},o={depth:e,onValue:t,offValue:i};return Y.runKernel($w,s,o)}const sN=K({oneHot_:rN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(){return Y}function nt(n,e){return Y.tidy(n,e)}function Gn(n){HS(n).forEach(t=>t.dispose())}function zs(n){return Y.keep(n)}function oN(n){return Y.setBackend(n)}function Td(){return Y.backendName}function aN(n){Y.removeBackend(n)}function lN(n){return Y.findBackendFactory(n)}function oT(n,e,t=1){return Y.registerBackend(n,e,t)}function cN(){return Y.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(n){const t={input:U(n,"input","imag")};return Y.runKernel(lw,t)}const Mf=K({imag_:uN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n){const t={x:U(n,"x","neg")};return Y.runKernel(Nw,t)}const Ol=K({neg_:hN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(n){const t={input:U(n,"input","real")};return Y.runKernel(Ww,t)}const $c=K({real_:dN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(n,e,t){const i=U(n,"x","transpose");if(e==null&&(e=i.shape.map((o,a)=>a).reverse()),G(i.rank===e.length,()=>`Error in transpose: rank of input ${i.rank} must match length of perm ${e}.`),e.forEach(o=>{G(o>=0&&o<i.rank,()=>`All entries in 'perm' must be between 0 and ${i.rank-1} but got ${e}`)}),i.rank<=1)return i.clone();const r={x:i},s={perm:e};return i.dtype==="complex64"?nt(()=>{let o=$c(i),a=Mf(i);return o=Y.runKernel(od,{x:o},s),a=Y.runKernel(od,{x:a},s),t&&(a=Ol(a)),eo(o,a)}):Y.runKernel(od,r,s)}const Xm=K({transpose_:fN});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n,e){const t=n.length,i=[];for(let r=0;r<t;r++){const s=t-1-r,o=n[s]||1;(e[e.length-1-r]||1)>1&&o===1&&i.unshift(s)}return i}function aT(n,e){const t=[];for(let i=0;i<e.length;i++){const r=n[n.length-i-1],s=e.length-i-1,o=e[s];(r==null||r===1&&o>1)&&t.unshift(s)}return t}function Et(n,e){const t=[],i=Math.max(n.length,e.length);for(let r=0;r<i;r++){let s=n[n.length-r-1];s==null&&(s=1);let o=e[e.length-r-1];if(o==null&&(o=1),s===1)t.unshift(o);else if(o===1)t.unshift(s);else if(s!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else t.unshift(s)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(n,e,t){if(ly(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const i=Mu(n,t);if(i.length!==3&&i.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Au(n,e,i,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vo;function mN(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,i=!1,r=!1,s=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)i=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)s=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(r&&r&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(Om(Nm,Y.backendName)!=null){const p={pixels:n},m={numChannels:e};return Y.runKernel(Nm,p,m)}const[c,u]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(i||t)h=n.data;else if(s||r||a){if(vo==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")vo=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else vo=document.createElement("canvas").getContext("2d");vo.canvas.width=c,vo.canvas.height=u,vo.drawImage(n,0,0,c,u),h=vo.getImageData(0,0,c,u).data}let d;if(e===4)d=new Int32Array(h);else{const p=c*u;d=new Int32Array(p*e);for(let m=0;m<p;m++)for(let y=0;y<e;++y)d[m*e+y]=h[m*4+y]}return pN(d,[u,c,e],"int32")}async function xy(n,e){let t=U(n,"img","toPixels");if(!(n instanceof dn)){const c=t;t=Ft(c,"int32"),c.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[i,r]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*i*4);for(let c=0;c<i*r;++c){const u=[0,0,0,255];for(let d=0;d<s;d++){const f=o[c*s+d];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(u[0]=f*a,u[1]=f*a,u[2]=f*a):u[d]=f*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){e.width=r,e.height=i;const c=e.getContext("2d"),u=new ImageData(l,r,i);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}const lT=K({fromPixels_:mN});function cT(n,e){const t=n.shape.length,i=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[i-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[i-1]} vs. ${t}`);if(we(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,s=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=n.shape,l=r.slice();l.pop();let c=1;for(let h=s;h<t;++h)c*=a[h],l.push(a[h]);const u=[...kn(n.shape).map(h=>h/c),1].slice(0,s);return[l,o,c,u]}function uT(n,e,t){const i=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${i}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(s+` update.rank < ${r}. `);if(n.length<i+(t.rank-r))throw new Error(s+` Output shape length < ${i+(t.rank-r)}`);if(t.rank!==r+n.length-i)throw new Error(s+` update.rank != ${r+n.length-i}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+i])throw new Error(s+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function hT(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}uT(t,e,n)}function _y(n,e,t){const i=e.shape.length,r=i>1?e.shape[i-1]:1,s=t.length;let o=1;for(let h=r;h<s;++h)o*=t[h];const a=r<1?1:r,l=we(e.shape)/a,c=[...kn(t.slice(0,r)),1],u=we(t);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ym=-2,gN=-1;function dT(n,e,t){const i=n.shape.length;G(i===e.length,()=>`Error in slice${i}D: Length of begin ${e} must match the rank of the array (${i}).`),G(i===t.length,()=>`Error in slice${i}D: Length of size ${t} must match the rank of the array (${i}).`);for(let r=0;r<i;++r)G(e[r]+t[r]<=n.shape[r],()=>`Error in slice${i}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function yN(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function fT(n,e,t){const i=[];for(let r=0;r<n.length;r++)i[r]=Math.ceil((e[r]-n[r])/t[r]);return i}function pT(n,e,t,i){const r=[...n];for(let s=r.length;s<i.length;s++)r.push(1);for(let s=0;s<t;s++)s===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function mT(n,e,t){return t<=n?t:t-(e-1)}function gT(n,e){const t=[];for(let i=0;i<n;i++)t.push(e+i);return t}function vN(n,e,t,i,r,s,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&t>0){const f=e[0],p=t+1;u=yT(o,f,p,i,n),h=vT(a,f,p,r,n),d=pT(s,f,p,n)}else for(let f=0;f<c;f++)u[f]=_T(o,i,s,n,f,l),h[f]=bT(a,r,s,n,f,l),d[f]=xT(s,f,l);return{begin:u,end:h,strides:d}}function yT(n,e,t,i,r){const s=[...r],o=gT(t,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const l=mT(e,t,a);let c=i[l];n&1<<l&&(c=0),s[a]=c}return s}function vT(n,e,t,i,r){const s=[...r],o=gT(t,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const l=mT(e,t,a);let c=i[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[a]=c}for(let a=0;a<s.length;a++){const l=r[a];s[a]<0&&(s[a]+=l),s[a]=bd(0,s[a],r[a])}return s}function xT(n,e,t){let i=n[e];return(t&1<<e||i==null)&&(i=1),i}function _T(n,e,t,i,r,s){let o=e[r];const a=t[r]||1;(n&1<<r||s&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),o=bd(0,o,l-1),o}function bT(n,e,t,i,r,s){let o=e[r];const a=t[r]||1;(n&1<<r||s&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),a>0?o=bd(0,o,l):o=bd(-1,o,l-1),o}function by(n,e,t){let i=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){i=r;break}for(let r=i+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function wy(n,e){let t=n.length>0?n[n.length-1]:1;for(let i=0;i<n.length-1;i++)t+=n[i]*e[i];return t}function wT(n,e,t){let i;const r=n.shape.length;typeof e=="number"?i=[e,...new Array(r-1).fill(0)]:e.length<r?i=e.concat(new Array(r-e.length).fill(0)):i=e.slice(),i.forEach(o=>{G(o!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(r).fill(-1):typeof t=="number"?s=[t,...new Array(r-1).fill(-1)]:t.length<r?s=t.concat(new Array(r-t.length).fill(-1)):s=t,s=s.map((o,a)=>o>=0?o:(G(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-i[a])),[i,s]}function ST(n,e,t,i,r,s,o,a,l){let c;if(i==null?(c=new Array(e.length),c.fill(1)):c=i,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<h.dims;_++)u&&(1<<_&a)!==0&&h.numAddAxisAfterEllipsis++,1<<_&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};xN(h,d);let f=!0,p=!0,m=!0;const y=[],g=[];for(let _=0;_<n.length;++_){if(d.strides[_]===0)throw Error(`strides[${_}] must be non-zero`);const b=!!(d.shrinkAxisMask&1<<_),S=n[_];if(S===-1){y.push(b?1:-1);continue}const w=[d.beginMask&1<<_,d.endMask&1<<_],T=[d.strides[_]>0?0:-1,d.strides[_]>0?S:S-1];if(b&&d.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[_]===1;const R=!!(d.beginMask&1<<_&&d.endMask&1<<_);if(d.beginValid&&d.endValid){if(b){const $=d.begin[_]<0?S+d.begin[_]:d.begin[_];if(d.begin[_]=$,d.end[_]=d.begin[_]+1,$<0||$>=S)throw Error(`slice index ${d.begin[_]} of dimension ${_} out of bounds.`)}else d.begin[_]=E0(d.begin[_],0,d.strides[_],S,w,T),d.end[_]=E0(d.end[_],1,d.strides[_],S,w,T);const L=d.strides[_]===1&&d.begin[_]===0&&d.end[_]===S;f=f&&L,p=p&&(_===0&&d.strides[_]===1||L)}else f=f&&d.strides[_]===1&&R,p=p&&(_===0&&d.strides[_]===1||R);let M,P=!1;if(d.beginValid&&d.endValid?(M=d.end[_]-d.begin[_],P=!0):b?(M=1,P=!0):R&&S>=0&&(d.strides[_]<0?M=-S:M=S,P=!0),P){let L;M===0||M<0!=d.strides[_]<0?L=0:L=Math.trunc(M/d.strides[_])+(M%d.strides[_]!==0?1:0),y.push(L)}else y.push(-1)}for(let _=0;_<d.finalShapeGatherIndices.length;++_){const b=d.finalShapeGatherIndices[_];b>=0?g.push(y[b]):b===Ym&&g.push(1)}return{finalShapeSparse:g.filter((_,b)=>d.finalShapeGatherIndices[b]!==Ym),finalShape:g,isIdentity:f,sliceDim0:p,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function xN(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let i=0;i<n.dims;i++)if(1<<i&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-i)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=i}else if(1<<i&n.newAxisMask)e.finalShapeGatherIndices.push(Ym),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[i]),n.end!=null&&(e.end[t]=n.end[i]),e.strides[t]=n.strides[i],n.beginMask&1<<i&&(e.beginMask|=1<<t),n.endMask&1<<i&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<i?(e.finalShapeGatherIndices.push(gN),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(i)),e.inputShapeGatherIndicesSparse[t]=i,t++}}function E0(n,e,t,i,r,s){if(r[e])return t>0?s[e]:s[e+1&1];{const o=n<0?i+n:n;return o<s[0]?s[0]:o>s[1]?s[1]:o}}var _N=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:dT,maskToAxes:yN,computeOutShape:fT,stridesWithElidedDims:pT,getNormalizedAxes:vN,startIndicesWithElidedDims:yT,stopIndicesWithElidedDims:vT,stridesForAxis:xT,startForAxis:_T,stopForAxis:bT,isSliceContinous:by,computeFlatOffset:wy,parseSliceParams:wT,sliceInfo:ST},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(n,e){let t=U(n,"a","add"),i=U(e,"b","add");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(uy,r)}const Dt=K({add_:bN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wN(n,e){let t=U(n,"a","floorDiv"),i=U(e,"b","floorDiv");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(tw,r)}const TT=K({floorDiv_:wN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(n,e){let t=U(n,"a","div"),i=U(e,"b","div");if([t,i]=tn(t,i),t.dtype==="int32"&&i.dtype==="int32")return TT(t,i);const r={a:t,b:i},s={};return Y.runKernel(G1,r,s)}const Lt=K({div_:SN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n,e){let t=U(n,"a","mul"),i=U(e,"b","mul");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(Pw,r)}const Ge=K({mul_:TN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EN(n){const e=U(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Y.runKernel(C1,t)}else{const t={x:e};return Y.runKernel(r1,t)}}const zi=K({abs_:EN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(n){const t={x:U(n,"x","acos")};return Y.runKernel(s1,t)}const MN=K({acos_:CN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(n){const t={x:U(n,"x","acosh")};return Y.runKernel(o1,t)}const RN=K({acosh_:AN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(n){G(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),G(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,s)=>U(r,`tensors${s}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!ln(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const i=e;return Y.runKernel(a1,i)}const PN=K({addN_:IN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(n,e=null,t=!1){const r={x:U(n,"x","all","bool")},s={axis:e,keepDims:t};return Y.runKernel(l1,r,s)}const LN=K({all_:NN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(n,e=null,t=!1){const r={x:U(n,"x","any","bool")},s={axis:e,keepDims:t};return Y.runKernel(c1,r,s)}const kN=K({any_:DN});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(n,e=0){const i={x:U(n,"x","argMax")},r={axis:e};return Y.runKernel(u1,i,r)}const ET=K({argMax_:ON});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n,e=0){const i={x:U(n,"x","argMin")},r={axis:e};return Y.runKernel(h1,i,r)}const $N=K({argMin_:FN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(n){const t={x:U(n,"x","asin")};return Y.runKernel(d1,t)}const zN=K({asin_:BN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(n){const t={x:U(n,"x","asinh")};return Y.runKernel(f1,t)}const VN=K({asinh_:UN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GN(n){const t={x:U(n,"x","atan")};return Y.runKernel(p1,t)}const HN=K({atan_:GN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WN(n,e){let t=U(n,"a","atan2"),i=U(e,"b","atan2");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(g1,r)}const jN=K({atan2_:WN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qN(n){const t={x:U(n,"x","atanh")};return Y.runKernel(m1,t)}const XN=K({atanh_:qN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CT(n,e,t,i,r="NHWC",s){const o=n[3],a=[...e,o],l=$l(r);return Ni(n,a,t,s,i,null,null,l)}function Fl(n,e,t,i,r,s,o="channelsLast"){const[a,l]=Cd(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ni(n,c,t,i,r,s,!1,o)}function Ru(n,e,t,i,r,s,o="NDHWC"){const[a,l,c]=Km(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Iu(n,u,t,i,r,!1,h,s)}function Ni(n,e,t,i,r,s,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,f,,p]=e,[m,y]=Cd(t),[g,v]=Cd(i),_=ll(d,g),b=ll(f,v),{padInfo:S,outHeight:w,outWidth:T}=ZN(r,c,u,m,y,_,b,s,a),R=o?p*h:p;let M;return a==="channelsFirst"?M=[l,R,w,T]:a==="channelsLast"&&(M=[l,w,T,R]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:w,outWidth:T,outChannels:R,padInfo:S,strideHeight:m,strideWidth:y,filterHeight:d,filterWidth:f,effectiveFilterHeight:_,effectiveFilterWidth:b,dilationHeight:g,dilationWidth:v,inShape:n,outShape:M,filterShape:e}}function Iu(n,e,t,i,r,s=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,d]=n;else if(o==="channelsFirst")[l,d,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[f,p,m,,y]=e,[g,v,_]=Km(t),[b,S,w]=Km(i),T=ll(f,b),R=ll(p,S),M=ll(m,w),{padInfo:P,outDepth:L,outHeight:$,outWidth:O}=JN(r,c,u,h,g,v,_,T,R,M,a),I=s?y*d:y;let N;return o==="channelsFirst"?N=[l,I,L,$,O]:o==="channelsLast"&&(N=[l,L,$,O,I]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:L,outHeight:$,outWidth:O,outChannels:I,padInfo:P,strideDepth:g,strideHeight:v,strideWidth:_,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:T,effectiveFilterHeight:R,effectiveFilterWidth:M,dilationDepth:b,dilationHeight:S,dilationWidth:w,inShape:n,outShape:N,filterShape:e}}function YN(n,e,t,i,r){i==null&&(i=Sy(n,e,t));const s=n[0],o=n[1],a=Wo((s-e+2*i)/t+1,r),l=Wo((o-e+2*i)/t+1,r);return[a,l]}function KN(n,e,t,i,r,s){r==null&&(r=Sy(n,e,i));const o=n[0],a=n[1],l=n[2],c=Wo((o-e+2*r)/i+1,s),u=Wo((a-e+2*r)/i+1,s),h=Wo((l-e+2*r)/i+1,s);return[c,u,h,t]}function Sy(n,e,t,i=1){const r=ll(e,i);return Math.floor((n[0]*(t-1)-t+r)/2)}function Cd(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Km(n){return typeof n=="number"?[n,n,n]:n}function ll(n,e){return e<=1?n:n+(n-1)*(e-1)}function ZN(n,e,t,i,r,s,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const f=YN([e,t],s,i,n,a);u=f[0],h=f[1]}else if(n==="same"){u=Math.ceil(e/i),h=Math.ceil(t/r);const d=Math.max(0,(u-1)*i+s-e),f=Math.max(0,(h-1)*r+o-t),p=Math.floor(d/2),m=d-p,y=Math.floor(f/2),g=f-y;c={top:p,bottom:m,left:y,right:g,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/i),h=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],f=l==="channelsLast"?n[1][1]:n[2][1],p=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:d,bottom:f,left:p,right:m,type:d===0&&f===0&&p===0&&m===0?"VALID":"EXPLICIT"},u=Wo((e-s+d+f)/i+1,a),h=Wo((t-o+p+m)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function JN(n,e,t,i,r,s,o,a,l,c,u){let h,d,f,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=KN([e,t,i,1],a,1,r,n,u);d=y[0],f=y[1],p=y[2]}else if(n==="same"){d=Math.ceil(e/r),f=Math.ceil(t/s),p=Math.ceil(i/o);const m=(d-1)*r+a-e,y=(f-1)*s+l-t,g=(p-1)*o+c-i,v=Math.floor(m/2),_=m-v,b=Math.floor(y/2),S=y-b,w=Math.floor(g/2),T=g-w;h={top:b,bottom:S,left:w,right:T,front:v,back:_,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/r),f=Math.ceil((t-l+1)/s),p=Math.ceil((i-c+1)/o);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:f,outWidth:p}}function Wo(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Bc(n){const[e,t,i]=Cd(n);return e===1&&t===1&&i===1}function Li(n,e){return Bc(n)||Bc(e)}function $l(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Qi(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")G(Oc(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(i=>{i.forEach(r=>{G(Oc(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QN(n,e){const i={x:U(n,"x","reshape","string_or_numeric")},r={shape:e};return Y.runKernel(Xw,i,r)}const he=K({reshape_:QN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(n,e,t,i,r){const s=U(n,"x","avgPool","float32"),o=1;G(Li(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=he(s,[1,s.shape[0],s.shape[1],s.shape[2]])),G(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Qi("avgPool",i,r);const c={x:a},u={filterSize:e,strides:t,pad:i,dimRoundingMode:r};let h=Y.runKernel(y1,c,u);return h=Ft(h,s.dtype),l?he(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const tL=K({avgPool_:eL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nL(n,e,t,i,r,s="NDHWC"){const o=U(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=he(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),G(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Qi("avgPool3d",i,r);const c={x:a},u={filterSize:e,strides:t,pad:i,dimRoundingMode:r,dataFormat:s};let h=Y.runKernel(v1,c,u);return h=Ft(h,a.dtype),l?he(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const iL=K({avgPool3d_:nL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rL(n,e=0){G(n.length>=1,()=>"Pass at least one tensor to concat");const t=KS(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Ho(t[0]);const i=t,r={axis:e};return Y.runKernel(M1,i,r)}const fi=K({concat_:rL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sL(n){const t={x:U(n,"x","sigmoid","float32")};return Y.runKernel(cS,t)}const Pu=K({sigmoid_:sL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oL(n,e,t){const i=U(n,"x","slice","string_or_numeric");if(i.rank===0)throw new Error("Slicing scalar is not possible");const r={x:i},s={begin:e,size:t};return Y.runKernel(sS,r,s)}const Tt=K({slice_:oL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aL(n){const t={x:U(n,"x","tanh","float32")};return Y.runKernel(AS,t)}const lL=K({tanh_:aL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cL(n,e,t){const i=U(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);G(i.rank>=1+e.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${e.length}`),G(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),G(i.shape[0]%r===0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const s={x:i},o={blockShape:e,crops:t};return Y.runKernel(_1,s,o)}const uL=K({batchToSpaceND_:cL});function hL(n){let e;return n.rank===0||n.rank===1?e=he(n,[1,1,1,n.size]):n.rank===2?e=he(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=he(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL(n,e,t,i,r,s){s==null&&(s=.001);const o=U(n,"x","batchNorm"),a=U(e,"mean","batchNorm"),l=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let u;i!=null&&(u=U(i,"offset","batchNorm")),G(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:hL(o),scale:c,offset:u,mean:a,variance:l},f={varianceEpsilon:s},p=Y.runKernel(nw,d,f);return he(p,o.shape)}const C0=K({batchNorm_:dL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fL(n,e,t){const i=U(n,"x","bincount"),r=U(e,"weights","bincount");G(i.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`),G(t>=0,()=>`size must be non-negative, but got ${t}.`),G(r.size===i.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${r.shape}.`);const s={x:i,weights:r},o={size:t};return Y.runKernel(b1,s,o)}const MT=K({bincount_:fL});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pL(n,e){const t=U(n,"s0","broadcastArgs","int32"),i=U(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(i.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${i.rank}`);const r={s0:t,s1:i};return Y.runKernel(w1,r)}const mL=K({broadcastArgs_:pL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gL(n,e){let t=U(n,"broadcastTo","x");const i=t.shape;if(e.some(c=>!(c>0)||c%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=he(t,c)}const r=t.shape,s=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])s[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${e}].`);if(s.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return Ho(t);const a={x:t},l={reps:s};return Y.runKernel(fy,a,l)}const ld=K({broadcastTo_:gL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(n){const t={x:U(n,"x","ceil","float32")};return Y.runKernel(S1,t)}const vL=K({ceil_:yL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xL(n,e,t){const i=U(n,"x","clipByValue");G(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const r={x:i},s={clipValueMin:e,clipValueMax:t};return Y.runKernel(T1,r,s)}const AT=K({clipByValue_:xL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _L(n,e,t,i,r="NHWC",s=[1,1],o){const a=U(n,"x","conv2d","float32"),l=U(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=he(a,[1,a.shape[0],a.shape[1],a.shape[2]])),G(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),G(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Qi("conv2d",i,o);const h=r==="NHWC"?c.shape[3]:c.shape[1];G(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),G(Li(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const d={x:c,filter:l},f={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o},p=Y.runKernel(A1,d,f);return u?he(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Ty=K({conv2d_:_L});function bL(n,e,t,i,r="NWC",s=1,o){const a=U(n,"x","conv1d"),l=U(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=he(a,[1,a.shape[0],a.shape[1]])),G(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),G(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Qi("conv1d",i,o),G(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),G(Li(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),G(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=he(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=he(c,[c.shape[0],1,c.shape[1],c.shape[2]]),y=Ty(d,h,[1,t],i,"NHWC",[1,s],o);return u?he(y,[y.shape[2],y.shape[3]]):he(y,[y.shape[0],y.shape[2],y.shape[3]])}const wL=K({conv1d_:bL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SL(n,e,t,i,r,s="NHWC",o){G(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=he(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),G(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),G(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),G(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=s==="NHWC"?a[3]:a[1],h=s==="NHWC"?l.shape[3]:l.shape[1];G(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),G(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Qi("conv2dDerInput",r,o);const d={dy:l,filter:t},f={strides:i,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:a},p=Y.runKernel(I1,d,f);return c?he(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const RT=K({conv2DBackpropInput_:SL});function TL(n,e,t,i,r,s){const o=U(n,"x","conv2dTranspose"),a=U(e,"filter","conv2dTranspose");return RT(t,o,a,i,r,"NHWC",s)}const EL=K({conv2dTranspose_:TL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CL(n,e,t,i,r="NDHWC",s=[1,1,1]){const o=U(n,"x","conv3d"),a=U(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=he(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),G(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),G(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),G(Li(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),G(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const u={x:l,filter:a},h={strides:t,pad:i,dataFormat:r,dilations:s},d=Y.runKernel(P1,u,h);return c?he(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const ML=K({conv3d_:CL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AL(n){const t={x:U(n,"x","cos","float32")};return Y.runKernel(N1,t)}const RL=K({cos_:AL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IL(n){const t={x:U(n,"x","cosh","float32")};return Y.runKernel(L1,t)}const PL=K({cosh_:IL});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NL(n,e=0,t=!1,i=!1){const s={x:U(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:i};return Y.runKernel(D1,s,o)}const LL=K({cumprod_:NL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DL(n,e=0,t=!1,i=!1){const s={x:U(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:i};return Y.runKernel(k1,s,o)}const kL=K({cumsum_:DL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OL(n,e,t,i=!1){const r=U(n,"x","denseBincount"),s=U(e,"weights","denseBincount");G(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),G(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),G(t>=0,()=>`size must be non-negative, but got ${t}.`),G(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},a={size:t,binaryOutput:i};return Y.runKernel(F1,o,a)}const FL=K({denseBincount_:OL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $L(n,e,t="NHWC"){const i=U(n,"x","depthToSpace","float32"),r=t==="NHWC"?i.shape[1]:i.shape[2],s=t==="NHWC"?i.shape[2]:i.shape[3],o=t==="NHWC"?i.shape[3]:i.shape[1];G(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),G(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${i.shape}`),G(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${i.shape}`),G(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${i.shape}`);const a={x:i},l={blockSize:e,dataFormat:t};return Y.runKernel($1,a,l)}const BL=K({depthToSpace_:$L});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(n,e,t,i,r="NHWC",s=[1,1],o){const a=U(n,"x","depthwiseConv2d","float32"),l=U(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=he(a,[1,a.shape[0],a.shape[1],a.shape[2]])),G(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),G(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),G(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),Qi("depthwiseConv2d",i,o);const h={x:c,filter:l},d={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o},f=Y.runKernel(B1,h,d);return u?he(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const IT=K({depthwiseConv2d_:zL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UL(n,e,t,i,r=[1,1],s="NHWC"){const o=U(n,"x","dilation2d"),a=U(e,"filter","dilation2d");G(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),G(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),G(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,c=!1;o.rank===3&&(l=he(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const u={x:l,filter:a},h={strides:t,pad:i,dilations:r},d=Y.runKernel(V1,u,h);return c?he(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const VL=K({dilation2d_:UL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n,e){let t=U(n,"a","equal","string_or_numeric"),i=U(e,"b","equal","string_or_numeric");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(q1,r)}const PT=K({equal_:GL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HL(n,e,t){const i=U(e,"a","where"),r=U(t,"b","where"),s=U(n,"condition","where","bool"),o=Et(Et(s.shape,i.shape),r.shape),a=ld(s,o),l=ld(i,o),c=ld(r,o),u={condition:a,t:l,e:c};return Y.runKernel(iS,u)}const vl=K({where_:HL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WL(n){const t={x:U(n,"x","zerosLike")};return Y.runKernel(LS,t)}const Ey=K({zerosLike_:WL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jL(n,e){let t=U(n,"a","div"),i=U(e,"b","div");[t,i]=tn(t,i);const r=Lt(t,i),s=Ey(r),o=PT(i,s);return vl(o,s,r)}const qL=K({divNoNan_:jL});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XL(n,...e){const t=e.map((r,s)=>U(r,`tensors${s}`,"einsum")),i={equation:n};return Y.runKernel(H1,t,i)}const YL=K({einsum_:XL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KL(n){const t={x:U(n,"x","elu","float32")};return Y.runKernel(W1,t)}const NT=K({elu_:KL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZL(n){let e=U(n,"x","erf");G(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ft(e,"float32"));const t={x:e};return Y.runKernel(j1,t)}const JL=K({erf_:ZL});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cy(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function LT(n,e,t){const i=n.length+e.length,r=[];let s=0,o=0;for(let a=0;a<i;a++)t.indexOf(a)===-1?r.push(n[s++]):r.push(e[o++]);return r}function Xr(n,e){const t=[],i=n.length;for(let s=0;s<i;s++)e.indexOf(s)===-1&&t.push(n[s]);const r=e.map(s=>n[s]);return[t,r]}function er(n,e){const t=e.map(i=>1);return LT(n,t,e)}function Pr(n,e,t){G(Cy(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function tr(n,e){if(Cy(n,e))return null;const t=[];for(let i=0;i<e;++i)n.indexOf(i)===-1&&t.push(i);return n.forEach(i=>t.push(i)),t}function My(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function nr(n,e){const t=[];for(let i=e-n;i<e;++i)t.push(i);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QL(n,e=null,t=!1){const r={x:U(n,"x","max")},s={reductionIndices:e,keepDims:t};return Y.runKernel(_w,r,s)}const cl=K({max_:QL});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3(n,e=null,t=!1){const r={x:U(n,"x","min")},s={axis:e,keepDims:t};return Y.runKernel(Cw,r,s)}const Zm=K({min_:e3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(n,e){let t=U(n,"base","pow"),i=U(e,"exp","pow");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(Uw,r)}const DT=K({pow_:t3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pt(n,e){if((zr(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&zr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Au(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3(n){const t={x:U(n,"x","sqrt","float32")};return Y.runKernel(hS,t)}const Jm=K({sqrt_:n3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3(n){const e=U(n,"x","square"),t={};return Y.runKernel("Square",{x:e},t)}const Af=K({square_:i3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r3(n,e=null,t=!1){let i=U(n,"x","sum");i.dtype==="bool"&&(i=Ft(i,"int32"));const r={x:i},s={axis:e,keepDims:t};return Y.runKernel(dS,r,s)}const Gt=K({sum_:r3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s3(n,e="euclidean",t=null,i=!1){n=U(n,"x","norm");const r=kT(n,e,t);let s=r.shape;if(i){const o=Mn(t,n.shape);s=er(r.shape,o)}return he(r,s)}function kT(n,e,t=null){if(n.rank===0)return zi(n);if(n.rank!==1&&t===null)return kT(he(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Gt(zi(n),t);if(e===1/0)return cl(zi(n),t);if(e===-1/0)return Zm(zi(n),t);if(e==="euclidean"||e===2)return Jm(Gt(DT(zi(n),pt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return cl(Gt(zi(n),t[0]),t[1]-1);if(e===1/0)return cl(Gt(zi(n),t[1]),t[0]);if(e===-1/0)return Zm(Gt(zi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Jm(Gt(Af(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Ay=K({norm_:s3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3(n,e=null,t=!1){return Ay(n,"euclidean",e,t)}const a3=K({euclideanNorm_:o3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3(n){const t={x:U(n,"x","exp")};return Y.runKernel(X1,t)}const fs=K({exp_:l3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3(n,e=0){const t=U(n,"x","expandDims","string_or_numeric");G(e<=t.rank,()=>"Axis must be <= rank of the tensor");const i={input:t},r={dim:e};return Y.runKernel(Y1,i,r)}const Vi=K({expandDims_:c3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3(n){const t={x:U(n,"x","expm1")};return Y.runKernel(K1,t)}const h3=K({expm1_:u3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(n,e){const t=U(n,"x","tile","string_or_numeric");G(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const i={x:t},r={reps:e};return Y.runKernel(fy,i,r)}const Ac=K({tile_:d3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f3(n,e,t,i="float32"){e==null&&(e=n);const r=cn([n,e],i),s=n<=e?n:e;for(let a=0;a<s;++a)r.set(1,a,a);const o=he(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Ac(Vi(o,0),[t[0],1,1]);if(t.length===2)return Ac(Vi(Vi(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Ac(Vi(Vi(Vi(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const p3=K({eye_:f3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ry(n,e,t){const i={shape:n,value:e,dtype:t};return Y.runKernel(J1,{},i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3(n){const t={x:U(n,"x","floor","float32")};return Y.runKernel(ew,t)}const g3=K({floor_:m3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(n,e,t=0,i=0){const r=U(n,"x","gather"),s=U(e,"indices","gather","int32"),o={x:r,indices:s},a={axis:t,batchDims:i};return Y.runKernel(iw,o,a)}const M0=K({gather_:y3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(n,e){let t=U(n,"a","greater","string_or_numeric"),i=U(e,"b","greater","string_or_numeric");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(sw,r)}const Rf=K({greater_:v3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3(n,e){let t=U(n,"a","greaterEqual","string_or_numeric"),i=U(e,"b","greaterEqual","string_or_numeric");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(ow,r)}const OT=K({greaterEqual_:x3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3(n){const t={x:U(n,"x","isNaN")};return Y.runKernel(cw,t)}const b3=K({isNaN_:_3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(n,e=.2){const i={x:U(n,"x","leakyRelu")},r={alpha:e};return Y.runKernel(uw,i,r)}const FT=K({leakyRelu_:w3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(n,e){let t=U(n,"a","less","string_or_numeric"),i=U(e,"b","less","string_or_numeric");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(hw,r)}const T3=K({less_:S3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3(n,e){let t=U(n,"a","lessEqual","string_or_numeric"),i=U(e,"b","lessEqual","string_or_numeric");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(dw,r)}const Iy=K({lessEqual_:E3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const i={start:n,stop:e,num:t};return Y.runKernel(fw,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3(n,e=5,t=1,i=1,r=.5){const s=U(n,"x","localResponseNormalization");G(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),G(Oc(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;s.rank===3&&(a=!0,o=he(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:i,beta:r},u=Y.runKernel(xw,l,c);return a?he(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const A3=K({localResponseNormalization_:M3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(n){const t={x:U(n,"x","log","float32")};return Y.runKernel(pw,t)}const zc=K({log_:R3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n){const t={x:U(n,"x","log1p")};return Y.runKernel(mw,t)}const $T=K({log1p_:I3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function to(n){return Y.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3(n){const t={x:U(n,"x","softplus")};return Y.runKernel(uS,t)}const N3=K({softplus_:P3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3(n,e){let t=U(n,"a","sub"),i=U(e,"b","sub");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(CS,r)}const mt=K({sub_:L3});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3(n,e=-1){const t=U(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return to((r,s)=>{const a=cl(r,e,!0),l=mt(r,a),c=mt(Ft(l,"float32"),zc(Gt(fs(l),e,!0)));return s([c]),{value:c,gradFunc:(h,d)=>{const[f]=d,p=!0,m=fs(f);return mt(h,Ge(Gt(h,e,p),m))}}})(t)}const k3=K({logSoftmax_:D3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3(n,e=null,t=!1){const i=U(n,"x","logSumExp"),r=Mn(e,i.shape),s=cl(i,r,!0),o=mt(i,s),a=fs(o),l=Gt(a,r),c=zc(l),u=Dt(he(s,c.shape),c);if(t){const h=er(u.shape,r);return he(u,h)}return u}const F3=K({logSumExp_:O3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(n,e){const t=U(n,"a","logicalAnd","bool"),i=U(e,"b","logicalAnd","bool");Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(gw,r)}const BT=K({logicalAnd_:$3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B3(n){const t={x:U(n,"x","logicalNot","bool")};return Y.runKernel(yw,t)}const z3=K({logicalNot_:B3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3(n,e){const t=U(n,"a","logicalOr","bool"),i=U(e,"b","logicalOr","bool");Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(vw,r)}const V3=K({logicalOr_:U3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nh=2147483648;function G3(n,e,t="left"){const i=U(n,"sortedSequence","searchSorted"),r=U(e,"values","searchSorted"),s=i.shape[i.shape.length-1],o=r.shape[r.shape.length-1],a=he(i,[-1,s]),l=he(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(we(l.shape)>=nh)throw new Error(`values tensor size must less than ${nh}`);if(a.shape[1]>=nh)throw new Error(`trailing dim_size must less than ${nh} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:t};return Y.runKernel(nS,c,u)}const zT=K({searchSorted_:G3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3(n,e){return zT(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3(n,e,t,i,r){const s=U(n,"x","maxPool"),o=1;let a=s,l=!1;s.rank===3&&(l=!0,a=he(s,[1,s.shape[0],s.shape[1],s.shape[2]])),G(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),G(Li(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Qi("maxPool",i,r);const c={x:a},u={filterSize:e,strides:t,pad:i,dimRoundingMode:r},h=Y.runKernel(ww,c,u);return l?he(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const j3=K({maxPool_:W3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3(n,e=[1,1,1],t,i,r,s="NDHWC"){const o=U(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=he(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),G(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Qi("maxPool3d",i,r);const c={x:a},u={filterSize:e,strides:t,pad:i,dimRoundingMode:r,dataFormat:s},h=Y.runKernel(Sw,c,u);return l?he(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const X3=K({maxPool3d_:q3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3(n,e,t,i,r=!1){const o={x:U(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:i,includeBatchInIndex:r},l=Y.runKernel(Tw,o,a);return{result:l[0],indexes:l[1]}}const K3=K({maxPoolWithArgmax_:Y3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(n,e){let t=U(n,"a","maximum"),i=U(e,"b","maximum");[t,i]=tn(t,i),t.dtype==="bool"&&(t=Ft(t,"int32"),i=Ft(i,"int32")),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(bw,r)}const J3=K({maximum_:Z3});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3(n,e=null,t=!1){const r={x:U(n,"x","mean")},s={axis:e,keepDims:t};return Y.runKernel(Ew,r,s)}const UT=K({mean_:Q3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(n,e="float32"){if(e==="complex64"){const i=no(n,"float32"),r=no(n,"float32");return eo(i,r)}const t=Qs(we(n),e);return Y.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(n,e="float32"){if(e==="complex64"){const i=Py(n,"float32"),r=no(n,"float32");return eo(i,r)}const t=Qb(we(n),e);return Y.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eD(n,e){let t=U(n,"a","minimum"),i=U(e,"b","minimum");[t,i]=tn(t,i),t.dtype==="bool"&&(t=Ft(t,"int32"),i=Ft(i,"int32")),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(Mw,r)}const Ny=K({minimum_:eD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tD(n,e,t){G(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const i=U(n,"x","mirrorPad");if(i.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");G(e.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<i.rank;a++)G(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),G(e[a][0]>=0&&e[a][0]<=i.shape[a]-r&&e[a][1]>=0&&e[a][1]<=i.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${i.shape[a]-r} or less than 0 for input of shape ${i.shape}`);const s={paddings:e,mode:t},o={x:i};return Y.runKernel(Aw,o,s)}const VT=K({mirrorPad_:tD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nD(n,e){let t=U(n,"a","mod"),i=U(e,"b","mod");[t,i]=tn(t,i);const r={a:t,b:i};return Y.runKernel(Rw,r)}const iD=K({mod_:nD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n,e,t,i=!1){const r=U(n,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?he(r,[1,-1]):r},c={numSamples:e,seed:t,normalized:i},u=Y.runKernel(Iw,l,c);return o===1?he(u,[u.size]):u}const sD=K({multinomial_:rD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(n,e){let t=U(n,"a","notEqual","string_or_numeric"),i=U(e,"b","notEqual","string_or_numeric");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i};return Y.runKernel(Lw,r)}const GT=K({notEqual_:oD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aD(n){const t={x:U(n,"x","onesLike")};return Y.runKernel(Fw,t)}const lD=K({onesLike_:aD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(n,e,t=0){const i=U(n,"x","pad");if(i.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},s={x:i};return Y.runKernel(zw,s,r)}const Md=K({pad_:cD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(n,e,t){const i=U(n,"x","spaceToBatchND");G(i.rank>=1+e.length,()=>`input rank ${i.rank} should be > than [blockShape] ${e.length}`),G(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),G(i.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:i},s={blockShape:e,paddings:t};return Y.runKernel(fS,r,s)}const hD=K({spaceToBatchND_:uD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(n,e){const t=U(n,"x","prelu"),i=U(e,"alpha","prelu"),r={x:t,alpha:i};return Y.runKernel(Vw,r)}const HT=K({prelu_:dD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fD(n,e=null,t=!1){let i=U(n,"x","prod");i.dtype==="bool"&&(i=Ft(i,"int32"));const r={x:i},s={axis:e,keepDims:t};return Y.runKernel(Gw,r,s)}const WT=K({prod_:fD});var jT={exports:{}};(function(n){(function(e,t,i){function r(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function s(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new r(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&s(h,u),d.state=function(){return s(u,{})}),d}function a(){var l=4022871197,c=function(u){u=u.toString();for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.alea=o})(It,n,!1)})(jT);var qT={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xor128=o})(It,n,!1)})(qT);var XT={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xorwow=o})(It,n,!1)})(XT);var YT={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this;l.next=function(){var u=l.x,h=l.i,d,f;return d=u[h],d^=d>>>7,f=d^d<<24,d=u[h+1&7],f^=d^d>>>10,d=u[h+3&7],f^=d^d>>>3,d=u[h+4&7],f^=d^d<<7,d=u[h+7&7],d=d^d<<13,f^=d^d<<9,u[h]=f,l.i=h+1&7,f};function c(u,h){var d,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,d=0;d<h.length;++d)f[d&7]=f[d&7]<<15^h.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8&&(f[7]=-1),u.x=f,u.i=0,d=256;d>0;--d)u.next()}c(l,a)}function s(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.x&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xorshift7=o})(It,n,!1)})(YT);var KT={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,f,p;return l.w=u=u+1640531527|0,p=h[d+34&127],f=h[d=d+1&127],p^=p<<13,f^=f<<17,p^=p>>>15,f^=f>>>12,p=h[d]=p^f,l.i=d,p+(u^u>>>16)|0};function c(u,h){var d,f,p,m,y,g=[],v=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,v=Math.max(v,h.length)),p=0,m=-32;m<v;++m)h&&(f^=h.charCodeAt((m+32)%h.length)),m===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,m>=0&&(y=y+1640531527|0,d=g[m&127]^=f+y,p=d==0?p+1:0);for(p>=128&&(g[(h&&h.length||0)&127]=-1),p=127,m=4*128;m>0;--m)f=g[p+34&127],d=g[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,g[p]=f^d;u.w=y,u.X=g,u.i=p}c(l,a)}function s(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.X&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xor4096=o})(It,n,!1)})(KT);var ZT={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this,c="";l.next=function(){var h=l.b,d=l.c,f=l.d,p=l.a;return h=h<<25^h>>>7^d,d=d-f|0,f=f<<24^f>>>8^p,p=p-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-f|0,l.d=f<<16^d>>>16^p,l.a=p-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function s(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,p=(d+f)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.tychei=o})(It,n,!1)})(ZT);var JT={exports:{}};(function(n){(function(e,t){var i=this,r=256,s=6,o=52,a="random",l=t.pow(r,s),c=t.pow(2,o),u=c*2,h=r-1,d;function f(b,S,w){var T=[];S=S==!0?{entropy:!0}:S||{};var R=g(y(S.entropy?[b,_(e)]:b==null?v():b,3),T),M=new p(T),P=function(){for(var L=M.g(s),$=l,O=0;L<c;)L=(L+O)*r,$*=r,O=M.g(1);for(;L>=u;)L/=2,$/=2,O>>>=1;return(L+O)/$};return P.int32=function(){return M.g(4)|0},P.quick=function(){return M.g(4)/4294967296},P.double=P,g(_(M.S),e),(S.pass||w||function(L,$,O,I){return I&&(I.S&&m(I,M),L.state=function(){return m(M,{})}),O?(t[a]=L,$):L})(P,R,"global"in S?S.global:this==t,S.state)}t["seed"+a]=f;function p(b){var S,w=b.length,T=this,R=0,M=T.i=T.j=0,P=T.S=[];for(w||(b=[w++]);R<r;)P[R]=R++;for(R=0;R<r;R++)P[R]=P[M=h&M+b[R%w]+(S=P[R])],P[M]=S;(T.g=function(L){for(var $,O=0,I=T.i,N=T.j,V=T.S;L--;)$=V[I=h&I+1],O=O*r+V[h&(V[I]=V[N=h&N+$])+(V[N]=$)];return T.i=I,T.j=N,O})(r)}function m(b,S){return S.i=b.i,S.j=b.j,S.S=b.S.slice(),S}function y(b,S){var w=[],T=typeof b,R;if(S&&T=="object")for(R in b)try{w.push(y(b[R],S-1))}catch{}return w.length?w:T=="string"?b:b+"\0"}function g(b,S){for(var w=b+"",T,R=0;R<w.length;)S[h&R]=h&(T^=S[h&R]*19)+w.charCodeAt(R++);return _(S)}function v(){try{var b;return d&&(b=d.randomBytes)?b=b(r):(b=new Uint8Array(r),(i.crypto||i.msCrypto).getRandomValues(b)),_(b)}catch{var S=i.navigator,w=S&&S.plugins;return[+new Date,i,w,i.screen,_(e)]}}function _(b){return String.fromCharCode.apply(0,b)}if(g(t.random(),e),n.exports){n.exports=f;try{d=require("crypto")}catch{}}})([],Math)})(JT);var pD=jT.exports,mD=qT.exports,gD=XT.exports,yD=YT.exports,vD=KT.exports,xD=ZT.exports,ya=JT.exports;ya.alea=pD;ya.xor128=mD;ya.xorwow=gD;ya.xorshift7=yD;ya.xor4096=vD;ya.tychei=xD;var QT=ya;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _D{constructor(e,t,i,r,s){this.mean=e,this.stdDev=t,this.dtype=i,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=s||Math.random();this.random=QT.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,i=!1;for(;!i;){let r,s,o;do r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(i=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class bD{constructor(e=0,t=1,i,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=i,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=QT.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wD(n,e=0,t=1,i="float32",r){const s=cn(n,i),o=new bD(e,t,null,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}const SD=K({randomUniform_:wD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uc(n,e,t=1,i="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:i};return Y.runKernel(Hw,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(n){const t={x:U(n,"x","reciprocal")};return Y.runKernel(jw,t)}const ED=K({reciprocal_:TD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(n){const t={x:U(n,"x","relu")};return Y.runKernel(qw,t)}const If=K({relu_:CD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(n){const t={x:U(n,"x","relu6")};return Y.runKernel(Zw,t)}const eE=K({relu6_:MD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(n,e){const i={x:U(n,"x","reverse")},r={dims:e};return Y.runKernel(Jw,i,r)}const Ad=K({reverse_:AD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const t={x:U(n,"x","round")};return Y.runKernel(Qw,t)}const tE=K({round_:RD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(n){const t={x:U(n,"x","rsqrt","float32")};return Y.runKernel(eS,t)}const PD=K({rsqrt_:ID});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(n){const t={x:U(n,"x","selu")};return Y.runKernel(rS,t)}const LD=K({selu_:ND});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function DD(n,e){const t=U(n,"x","setdiff1d"),i=U(e,"y","setdiff1d");G(t.dtype===i.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${i.dtype}).`),G(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),G(i.rank===1,()=>`y should be 1D tensor, but got y (${i.shape}).`);const r=await t.data(),s=await i.data(),o=new Set(s);let a=0;for(let u=0;u<r.length;u++)o.has(r[u])||a++;const l=new Fc([a],t.dtype),c=new Fc([a],"int32");for(let u=0,h=0;u<r.length;u++)o.has(r[u])||(l.values[h]=r[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const kD=DD;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(n){const t={x:U(n,"x","sign")};return Y.runKernel(lS,t)}const FD=K({sign_:OD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $D(n){const t={x:U(n,"x","sin","float32")};return Y.runKernel(oS,t)}const BD=K({sin_:$D});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(n){const t={x:U(n,"x","sinh")};return Y.runKernel(aS,t)}const UD=K({sinh_:zD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VD(n,e=-1){const t=U(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const i={logits:t},r={dim:e};return Y.runKernel(mS,i,r)}const GD=K({softmax_:VD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(n){G(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Y.runKernel(Z1,e)}const nE=K({fft_:HD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n){G(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Y.runKernel(aw,e)}const Qm=K({ifft_:WD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jD(n){const e=n.shape[n.shape.length-1],t=n.size/e;let i;if(e<=2){const r=he(n,[t,e]);i=Qm(r)}else{const r=[t,2*(e-1)],s=he($c(n),[t,e]),o=he(Mf(n),[t,e]),a=Ad(Tt(s,[0,1],[t,e-2]),1),l=Ge(Ad(Tt(o,[0,1],[t,e-2]),1),pt(-1)),c=fi([s,a],1),u=fi([o,l],1),h=he(eo(c,u),[r[0],r[1]]);i=Qm(h)}if(i=$c(i),n.rank===3&&n.shape[0]!==0){const r=i,s=n.shape[0];i=he(i,[s,i.shape[0]/s,i.shape[1]]),r.dispose()}return i}const qD=K({irfft_:jD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XD(n,e,t=0){const r={x:U(n,"x","split")},s={numOrSizeSplits:e,axis:t};return Y.runKernel(pS,r,s)}const Vc=K({split_:XD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(n,e){G(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const i=n.size/t;let r;if(e!=null&&e<t){const p=n.shape.map(y=>0),m=n.shape.map(y=>y);m[n.shape.length-1]=e,r=Tt(n,p,m),t=e}else if(e!=null&&e>t){const p=n.shape.map(m=>m);p[n.shape.length-1]=e-t,r=fi([n,no(p)],n.shape.length-1),t=e}else r=n;const s=Ey(r),o=he(eo(r,s),[i,t]),a=nE(o),l=Math.floor(t/2)+1,c=$c(a),u=Mf(a),h=Vc(c,[l,t-l],c.shape.length-1),d=Vc(u,[l,t-l],u.shape.length-1),f=r.shape.slice();return f[r.shape.length-1]=l,he(eo(h[0],d[0]),f)}const iE=K({rfft_:YD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(n,e){let t=U(n,"a","squaredDifference"),i=U(e,"b","squaredDifference");[t,i]=tn(t,i),Et(t.shape,i.shape);const r={a:t,b:i},s={};return Y.runKernel(bS,r,s)}const rE=K({squaredDifference_:KD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(n,e){const t=U(n,"x","squeeze");return he(t,ho(t.shape,e).newShape)}const Rt=K({squeeze_:ZD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(n,e=0){const t=KS(n,"tensors","stack","string_or_numeric");G(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&G(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const i=t,r={axis:e};return Y.runKernel(Bw,i,r)}const ps=K({stack_:JD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QD(n,e=0){const i={x:U(n,"x","step")},r={alpha:e};return Y.runKernel(DS,i,r)}const ek=K({step_:QD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(n,e,t,i,r=0,s=0,o=0,a=0,l=0){const u={x:U(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:i,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return Y.runKernel(wS,u,h)}const nk=K({stridedSlice_:tk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ik(n){const t={x:U(n,"x","tan","float32")};return Y.runKernel(MS,t)}const rk=K({tan_:ik});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(n,e){ly(n);const t=Mu(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Au(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(n,e,t){if(ly(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const i=Mu(n,t);if(i.length!==2&&i.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Au(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sk(n,e=1,t=!0){const i=U(n,"x","topk");if(i.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=i.shape[i.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const s={x:i},o={k:e,sorted:t},[a,l]=Y.runKernel(RS,s,o);return{values:a,indices:l}}const ok=K({topk_:sk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ak(n,e=0,t=1,i,r){if(i!=null&&i==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new _D(e,t,i,!0,r),o=cn(n,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const lk=K({truncatedNormal_:ak});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ck(n,e=0){const t=U(n,"x","unique","string_or_numeric");G(t.rank>0,()=>"The input tensor must be at least 1D");const i={x:t},r={axis:e},[s,o]=Y.runKernel(PS,i,r);return{values:s,indices:o}}const A0=K({unique_:ck});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uk(n,e=0){const t=U(n,"x","unstack","string_or_numeric");G(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const i={value:t},r={axis:e};return Y.runKernel(NS,i,r)}const va=K({unstack_:uk});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hk(n,e){return zT(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sE(n,e){const t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);const i=cn(n,"int32"),r=cn([t.length,n.length],"int32");for(let s=0;s<t.length;s++){const o=i.indexToLoc(t[s]),a=s*n.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function dk(n){const e=U(n,"condition","whereAsync","bool"),t=await e.data(),i=sE(e.shape,t);return n!==e&&e.dispose(),i}const fk=dk;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pk(n,e,t){const i=U(n,"indices","scatterND","int32"),r=U(e,"updates","scatterND");hT(r,i,t);const s={indices:i,updates:r},o={shape:t};return Y.runKernel(tS,s,o)}const mk=K({scatterND_:pk});function gk(n,e,t,i){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==i.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yk(n,e,t,i=0){const r=U(n,"sparseIndices","sparseToDense","int32"),s=U(e,"sparseValues","sparseToDense","string_or_numeric"),o=U(i,"defaultValue","sparseToDense",s.dtype);gk(r,s,t,o);const a={sparseIndices:r,sparseValues:s,defaultValue:o},l={outputShape:t};return Y.runKernel(_S,a,l)}const oE=K({sparseToDense_:yk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vk(n,e){const t=U(e,"indices","gatherND","int32"),r={params:U(n,"x","gatherND","string_or_numeric"),indices:t};return Y.runKernel(rw,r)}const xk=K({gatherND_:vk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _k(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function aE(n,e,t){const i=1-n%2,r=new Float32Array(n);for(let s=0;s<n;++s){const o=2*Math.PI*s/(n+i-1);r[s]=e-t*Math.cos(o)}return Dn(r,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bk(n,e,t,i,r,s="NHWC",o){let a=n;n.rank===3&&(a=he(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=he(e,[1,e.shape[0],e.shape[1],e.shape[2]])),G(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),G(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),G(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=s==="NHWC"?a.shape[3]:a.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];G(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),G(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),Qi("conv2dDerFilter",r,o);const h={x:a,dy:l},d={strides:i,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:t};return Y.runKernel(R1,h,d)}const wk=K({conv2DBackpropFilter_:bk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Ge(n,ek(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Nf(n,e){let t=e;const i=aT(n.shape,e.shape);return i.length>0&&(t=Gt(t,i)),he(t,n.shape)}function Lf(n,e,t,i){if(e==="linear")return n;if(e==="relu")return If(n);if(e==="elu")return NT(n);if(e==="relu6")return eE(n);if(e==="prelu")return HT(n,t);if(e==="leakyrelu")return FT(n,i);if(e==="sigmoid")return Pu(n);throw new Error(`Unknown fused activation ${e}.`)}const Df=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sk({x:n,filter:e,strides:t,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",Df(Y.state.gradientDepth,l)===!1){G(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let w=Ty(n,e,t,i,r,s,o);return a!=null&&(w=Dt(w,a)),Lf(w,l,c,u)}const h=U(n,"x","conv2d","float32"),d=U(e,"filter","conv2d","float32");let f=h,p=!1;h.rank===3&&(p=!0,f=he(h,[1,h.shape[0],h.shape[1],h.shape[2]])),G(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),G(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Qi("fused conv2d",i,o);const m=r==="NHWC"?f.shape[3]:f.shape[1];G(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),G(Li(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const y=Ni(f.shape,d.shape,t,s,i,o);let g;a!=null&&(g=U(a,"bias","fused conv2d"),[g]=tn(g,h),r==="NHWC"?Et(y.outShape,g.shape):(G(g.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`),G(g.shape.length===0||g.shape[0]===y.outChannels||g.shape[0]===1,()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let v;if(c!=null){const w=c.shape;if(G(w.length<=1||w.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`),w.length===1)G(w[0]===1||w[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${y.outChannels}).`);else if(w.length===3)try{Et(w,y.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(R)}v=U(c,"prelu weights","fused conv2d")}const _=(w,T)=>{G(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,M,P,L]=T,$=Pf(w,P,l);G(Bc(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const O=RT(M.shape,$,R,t,i),I=wk(M,$,R.shape,t,i),N=[O,I];if(L!=null){const V=Nf(L,$);N.push(V)}return N},b={x:f,filter:d,bias:g,preluActivationWeights:v},S={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?to((T,R,M)=>{let P=Y.runKernel(Dm,b,S);return M([R,T,P]),p&&(P=he(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:_}})(f,d):to((T,R,M,P)=>{let L=Y.runKernel(Dm,b,S);return P([R,T,L,M]),p&&(L=he(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:_}})(f,d,g)}const Tk=K({fusedConv2d_:Sk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ek(n,e,t,i,r,s=[1,1],o){let a=n;n.rank===3&&(a=he(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=he(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:i,pad:r,dimRoundingMode:o,dilations:s,filterShape:t};return Y.runKernel(z1,c,u)}const Ck=K({depthwiseConv2dNativeBackpropFilter_:Ek});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mk(n,e,t,i,r,s=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=he(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:i,pad:r,dimRoundingMode:o,dilations:s,inputShape:n},h=Y.runKernel(U1,c,u);return l?he(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Ak=K({depthwiseConv2dNativeBackpropInput_:Mk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rk({x:n,filter:e,strides:t,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(Df(Y.state.gradientDepth,l)===!1){let S=IT(n,e,t,i,r,s,o);return a!=null&&(S=Dt(S,a)),Lf(S,l,c,u)}const h=U(n,"x","depthwiseConv2d","float32"),d=U(e,"filter","depthwiseConv2d","float32");let f=h,p=!1;h.rank===3&&(p=!0,f=he(h,[1,h.shape[0],h.shape[1],h.shape[2]])),G(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),G(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),G(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),G(Li(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Qi("fused depthwiseConv2d",i,o);const m=Ni(f.shape,d.shape,t,s,i,o,!0);let y;a!=null&&(y=U(a,"bias","fused conv2d"),[y]=tn(y,h),Et(m.outShape,y.shape));let g;c!=null&&(g=U(c,"prelu weights","fused depthwiseConv2d"));const v=(S,w)=>{G(Bc(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[T,R,M,P]=w,L=Pf(S,M,l),$=Ak(R.shape,L,T,t,i,s,o),O=Ck(R,L,T.shape,t,i,s,o);if(P!=null){const I=Nf(y,L);return[$,O,I]}return[$,O]},_={x:f,filter:d,bias:y,preluActivationWeights:g},b={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?to((w,T,R)=>{let M=Y.runKernel(km,_,b);return R([T,w,M]),p&&(M=he(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:v}})(f,d):to((w,T,R,M)=>{let P=Y.runKernel(km,_,b);return M([T,w,P,R]),p&&(P=he(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:v}})(f,d,y)}const Ik=K({fusedDepthwiseConv2d_:Rk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pk({a:n,b:e,transposeA:t=!1,transposeB:i=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a}){if(Df(Y.state.gradientDepth,s)===!1){let L=xn(n,e,t,i);return r!=null&&(L=Dt(L,r)),Lf(L,s,o,a)}let l=U(n,"a","fused matMul"),c=U(e,"b","fused matMul");[l,c]=tn(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=i?c.shape[c.rank-1]:c.shape[c.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],f=i?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),y=we(p),g=we(m);G(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${i} must match.`);const _=Et(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,f]),b=t?he(l,[y,u,d]):he(l,[y,d,u]),S=i?he(c,[g,f,h]):he(c,[g,h,f]);let w;r!=null&&(w=U(r,"bias","fused matMul"),[w]=tn(w,l),Et(_,w.shape));let T;o!=null&&(T=U(o,"prelu weights","fused matMul"));const R=(L,$)=>{const[O,I,N,V]=$,X=Pf(he(L,N.shape),N,s);let J,W;if(!t&&!i?(J=xn(X,I,!1,!0),W=xn(O,X,!0,!1)):!t&&i?(J=xn(X,I,!1,!1),W=xn(X,O,!0,!1)):t&&!i?(J=xn(I,X,!1,!0),W=xn(O,X,!1,!1)):(J=xn(I,X,!0,!0),W=xn(X,O,!0,!0)),r!=null){const Q=Nf(V,X);return[J,W,Q]}else return[J,W]},M={a:b,b:S,bias:w,preluActivationWeights:T},P={transposeA:t,transposeB:i,activation:s,leakyreluAlpha:a};return r==null?to(($,O,I)=>{const N=Y.runKernel(Lm,M,P);return I([$,O,N]),{value:he(N,_),gradFunc:R}})(b,S):to(($,O,I,N)=>{const V=Y.runKernel(Lm,M,P);return N([$,O,V,I]),{value:he(V,_),gradFunc:R}})(b,S,w)}const Nk=K({fusedMatMul_:Pk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lk(n){return aE(n,.54,.46)}const are=K({hammingWindow_:Lk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dk(n){return aE(n,.5,.5)}const kk=K({hannWindow_:Dk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ok(n,e,t,i=!1,r=0){let s=0;const o=[];for(;s+e<=n.size;)o.push(Tt(n,s,e)),s+=t;if(i)for(;s<n.size;){const a=s+e-n.size,l=fi([Tt(n,s,e-a),Ry([a],r)]);o.push(l),s+=t}return o.length===0?wr([],[0,e]):he(fi(o),[o.length,e])}const Fk=K({frame_:Ok});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(n,e,t,i,r=kk){i==null&&(i=_k(e));const s=Fk(n,e,t),o=Ge(s,r(e));return iE(o,i)}const lre=K({stft_:$k});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(n,e,t,i,r="bilinear",s=0){const o=U(n,"image","cropAndResize"),a=U(e,"boxes","cropAndResize","float32"),l=U(t,"boxInd","cropAndResize","int32"),c=a.shape[0];G(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),G(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),G(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),G(i.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`),G(i[0]>=1&&i[1]>=1,()=>`cropSize must be atleast [1,1], but was ${i}`),G(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const u={image:o,boxes:a,boxInd:l},h={method:r,extrapolationValue:s,cropSize:i};return Y.runKernel(O1,u,h)}const zk=K({cropAndResize_:Bk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uk(n){const e=U(n,"image","flipLeftRight","float32");G(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Y.runKernel(Q1,t,{})}const Vk=K({flipLeftRight_:Uk});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gk(n){const e=U(n,"image","grayscaleToRGB"),t=e.rank-1,i=e.shape[t];G(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),G(i===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${i}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Ac(e,r)}const Hk=K({grayscaleToRGB_:Gk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(n,e,t=0,i=.5){const r=U(n,"image","rotateWithOffset","float32");G(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const s={image:r},o={radians:e,fillValue:t,center:i};return Y.runKernel(kS,s,o)}const jk=K({rotateWithOffset_:Wk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(n,e,t,i,r,s){i==null&&(i=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);const o=n.shape[0];return t=Math.min(t,o),G(0<=i&&i<=1,()=>`iouThreshold must be in [0, 1], but was '${i}'`),G(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),G(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),G(e.rank===1,()=>"scores must be a 1D tensor"),G(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),G(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:i,scoreThreshold:r,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY){const s=U(n,"boxes","nonMaxSuppression","float32"),o=U(e,"scores","nonMaxSuppression","float32"),a=Bl(s,o,t,i,r);t=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:i,scoreThreshold:r};return Y.runKernel(Dw,{boxes:s,scores:o},l)}const Xk=K({nonMaxSuppression_:qk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yk(n,e,t){const i=Kk(n,e,t),r=i<0?-(i+1):i;n.splice(r,0,e)}function Kk(n,e,t){return Jk(n,e,t||Zk)}function Zk(n,e){return n>e?1:n<e?-1:0}function Jk(n,e,t){let i=0,r=n.length,s=0,o=!1;for(;i<r;){s=i+(r-i>>>1);const a=t(e,n[s]);a>0?i=s+1:(r=s,o=!a)}return o?i:-i-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(n,e,t,i,r){return Ly(n,e,t,i,r,0)}function cE(n,e,t,i,r,s){return Ly(n,e,t,i,r,0,!1,s,!0)}function uE(n,e,t,i,r,s){return Ly(n,e,t,i,r,s,!0)}function Ly(n,e,t,i,r,s,o=!1,a=!1,l=!1){const c=[];for(let y=0;y<e.length;y++)e[y]>r&&c.push({score:e[y],boxIndex:y,suppressBeginIndex:0});c.sort(R0);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<t&&c.length>0;){const y=c.pop(),{score:g,boxIndex:v,suppressBeginIndex:_}=y;if(g<r)break;let b=!1;for(let S=h.length-1;S>=_;--S){const w=Qk(n,v,h[S]);if(w>=i){b=!0;break}if(y.score=y.score*eO(i,u,w),y.score<=r)break}y.suppressBeginIndex=h.length,b||(y.score===g?(h.push(v),d.push(y.score)):y.score>r&&Yk(c,y,R0))}const f=h.length,p=t-f;a&&p>0&&(h.push(...new Array(p).fill(0)),d.push(...new Array(p).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),l&&(m.validOutputs=f),m}function Qk(n,e,t){const i=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),s=Math.min(i[0],i[2]),o=Math.min(i[1],i[3]),a=Math.max(i[0],i[2]),l=Math.max(i[1],i[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),f=(a-s)*(l-o),p=(h-c)*(d-u);if(f<=0||p<=0)return 0;const m=Math.max(s,c),y=Math.max(o,u),g=Math.min(a,h),v=Math.min(l,d),_=Math.max(g-m,0)*Math.max(v-y,0);return _/(f+p-_)}function eO(n,e,t){const i=Math.exp(e*t*t);return t<=n?i:0}function R0(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function tO(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY){const s=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),a=Bl(s,o,t,i,r);t=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=lE(c,u,t,i,r);return s!==n&&s.dispose(),o!==e&&o.dispose(),Dn(h,"int32")}const nO=tO;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=U(n,"boxes","nonMaxSuppression"),a=U(e,"scores","nonMaxSuppression"),l=Bl(o,a,t,i,r,s);t=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:i,scoreThreshold:r,softNmsSigma:s},h=Y.runKernel(Ow,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const rO=K({nonMaxSuppressionWithScore_:iO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function sO(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=U(n,"boxes","nonMaxSuppressionAsync"),a=U(e,"scores","nonMaxSuppressionAsync"),l=Bl(o,a,t,i,r,s);t=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:f}=uE(u,h,t,i,r,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Dn(d,"int32"),selectedScores:Dn(f)}}const oO=sO;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=U(n,"boxes","nonMaxSuppression"),a=U(e,"scores","nonMaxSuppression"),l=Bl(o,a,t,i,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},f={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:s},p=Y.runKernel(kw,d,f);return{selectedIndices:p[0],validOutputs:p[1]}}const lO=K({nonMaxSuppressionPadded_:aO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function cO(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=U(n,"boxes","nonMaxSuppressionAsync"),a=U(e,"scores","nonMaxSuppressionAsync"),l=Bl(o,a,t,i,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,f]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=cE(d,f,c,u,h,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Dn(p,"int32"),validOutputs:pt(m,"int32")}}const uO=cO;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(n,e,t=!1,i=!1){const r=U(n,"images","resizeBilinear");G(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),G(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),G(i===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;r.rank===3&&(o=!0,s=he(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:i,size:e},c=Y.runKernel(Kw,a,l);return o?he(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const dO=K({resizeBilinear_:hO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(n,e,t=!1,i=!1){const r=U(n,"images","resizeNearestNeighbor");G(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),G(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),G(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),G(i===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;r.rank===3&&(o=!0,s=he(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:i,size:e},c=Y.runKernel(Yw,a,l);return o?he(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const pO=K({resizeNearestNeighbor_:fO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(n,e="binary",t=!1,i=.5){const r=U(n,"image","threshold"),s=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=Ge(Dn([i]),255),u,h,d,f;if(G(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),G(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),G(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),G(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[u,h,d]=Vc(r,[1,1,1],-1);const y=Ge(u,s),g=Ge(h,o),v=Ge(d,a);f=Dt(Dt(y,g),v)}else f=n;if(e==="otsu"){const y=MT(Ft(tE(f),"int32"),Ws([]),256);c=gO(y,l)}const p=t?Iy(f,c):Rf(f,c);return Ft(Ge(p,255),"int32")}function gO(n,e){let t=Dn([-1]),i=Dn([0]),r=Dn([0]),s,o,a,l,c,u;for(let h=0;h<n.size-1;h++){s=Tt(n,0,h+1),o=Tt(n,h+1),c=Lt(Gt(s),e),u=Lt(Gt(o),e);const d=Gt(Ge(s,Uc(0,s.size)));a=Lt(d,Gt(s));const f=Ry(o.shape,s.size),p=Dt(Uc(0,o.size),f),m=Ge(o,p);l=Lt(Gt(m),Gt(o));const y=mt(a,l),g=mt(a,l),v=Ge(c,u);r=Ge(Ge(v,y),g);const _=Rf(r,i);i=vl(_,r,i),t=vl(_,Dn([h]),t)}return t}const yO=K({threshold_:mO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vO(n,e,t="nearest",i="constant",r=0,s){const o=U(n,"image","transform","float32"),a=U(e,"transforms","transform","float32");G(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),G(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),G(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:i,fillValue:r,outputShape:s};return Y.runKernel(IS,l,c)}const xO=K({transform_:vO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(n,e,t){G(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),G(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const i=U(n,"a","bandPart");G(i.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${i.rank}.`);const r=i.shape,[s,o]=i.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=s),t<0&&(t=o);const a=he(Uc(0,s,1,"int32"),[-1,1]),l=Uc(0,o,1,"int32"),c=mt(a,l),u=BT(Iy(c,pt(+e,"int32")),OT(c,pt(-t,"int32"))),h=no([s,o],i.dtype);return he(ps(va(he(i,[-1,s,o])).map(d=>vl(u,d,h))),r)}const cre=K({bandPart_:_O});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(n){let e;if(Array.isArray(n)){e=!1,G(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let s=1;s<n.length;++s)G(n[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${r})`)}else e=!0,n=Vc(n,n.shape[0],0).map(r=>Rt(r,[0]));G(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],i=n;for(let r=0;r<n.length;++r)t.push(Y.tidy(()=>{let s=i[r];if(r>0)for(let o=0;o<r;++o){const a=Ge(Gt(Ge(t[o],s)),t[o]);s=mt(s,a)}return Lt(s,Ay(s,"euclidean"))}));return e?ps(t,0):t}const ure=K({gramSchmidt_:bO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(n,e=!1){if(G(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return I0(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),i=va(he(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],s=[];i.forEach(l=>{const[c,u]=I0(l,e);r.push(c),s.push(u)});const o=he(ps(r,0),n.shape),a=he(ps(s,0),n.shape);return[o,a]}}function I0(n,e=!1){return Y.tidy(()=>{G(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],i=n.shape[1];let r=p3(t),s=Ho(n);const o=wr([[1]],[1,1]);let a=Ho(o);const l=t>=i?i:t;for(let c=0;c<l;++c){const u=s,h=a,d=r;[a,s,r]=Y.tidy(()=>{const f=Tt(s,[c,c],[t-c,1]),p=Ay(f),m=Tt(s,[c,c],[1,1]),y=vl(Rf(m,0),wr([[-1]]),wr([[1]])),g=mt(m,Ge(y,p)),v=Lt(f,g);v.shape[0]===1?a=Ho(o):a=fi([o,Tt(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const _=Ol(Lt(xn(y,g),p)),b=Tt(s,[c,0],[t-c,i]),S=Ge(_,a),w=Xm(a);if(c===0)s=mt(b,xn(S,xn(w,b)));else{const M=mt(b,xn(S,xn(w,b)));s=fi([Tt(s,[0,0],[c,i]),M],0)}const T=Xm(S),R=Tt(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=mt(R,xn(xn(R,a),T));else{const M=mt(R,xn(xn(R,a),T));r=fi([Tt(r,[0,0],[t,c]),M],1)}return[a,s,r]}),Gn([u,h,d])}return!e&&t>i&&(r=Tt(r,[0,0],[t,i]),s=Tt(s,[0,0],[i,i])),[r,s]})}const hre=K({qr_:wO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ni;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ni||(ni={}));function SO(n,e,t=ni.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=U(e,"weights","computeWeightedLoss"));const s=r==null?i:Ge(i,r);if(t===ni.NONE)return s;if(t===ni.SUM)return Gt(s);if(t===ni.MEAN){if(r==null)return UT(s);{const o=i.size/r.size,a=Lt(Gt(s),Gt(r));return o>1?Lt(a,pt(o)):a}}if(t===ni.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Lt(Gt(s),pt(i.size));{const o=Ge(r,Py(i.shape)),a=Ft(Gt(GT(o,pt(0))),"float32");return Lt(Gt(s),a)}}throw Error(`Unknown reduction: ${t}`)}const fo=K({computeWeightedLoss_:SO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(n,e,t,i=ni.SUM_BY_NONZERO_WEIGHTS){const r=U(n,"labels","absoluteDifference"),s=U(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=U(t,"weights","absoluteDifference")),Rr(r.shape,s.shape,"Error in absoluteDifference: ");const a=zi(mt(r,s));return fo(a,o,i)}const dre=K({absoluteDifference_:TO});function EO(n,e,t,i,r=ni.SUM_BY_NONZERO_WEIGHTS){const s=U(n,"labels","cosineDistance"),o=U(e,"predictions","cosineDistance");let a=null;i!=null&&(a=U(i,"weights","cosineDistance")),Rr(s.shape,o.shape,"Error in cosineDistance: ");const l=pt(1),c=mt(l,Gt(Ge(s,o),t,!0));return fo(c,a,r)}const fre=K({cosineDistance_:EO});function CO(n,e,t,i=ni.SUM_BY_NONZERO_WEIGHTS){let r=U(n,"labels","hingeLoss");const s=U(e,"predictions","hingeLoss");let o=null;t!=null&&(o=U(t,"weights","hingeLoss")),Rr(r.shape,s.shape,"Error in hingeLoss: ");const a=pt(1);r=mt(Ge(pt(2),r),a);const l=If(mt(a,Ge(r,s)));return fo(l,o,i)}const pre=K({hingeLoss_:CO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MO(n,e,t,i=1,r=ni.SUM_BY_NONZERO_WEIGHTS){const s=U(n,"labels","huberLoss"),o=U(e,"predictions","huberLoss");let a=null;t!=null&&(a=U(t,"weights","huberLoss")),Rr(s.shape,o.shape,"Error in huberLoss: ");const l=pt(i),c=zi(mt(o,s)),u=Ny(c,l),h=mt(c,u),d=Dt(Ge(pt(.5),Af(u)),Ge(l,h));return fo(d,a,r)}const mre=K({huberLoss_:MO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AO(n,e,t,i=1e-7,r=ni.SUM_BY_NONZERO_WEIGHTS){const s=U(n,"labels","logLoss"),o=U(e,"predictions","logLoss");let a=null;t!=null&&(a=U(t,"weights","logLoss")),Rr(s.shape,o.shape,"Error in logLoss: ");const l=pt(1),c=pt(i),u=Ol(Ge(s,zc(Dt(o,c)))),h=Ge(mt(l,s),zc(Dt(mt(l,o),c))),d=mt(u,h);return fo(d,a,r)}const gre=K({logLoss_:AO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RO(n,e,t,i=ni.SUM_BY_NONZERO_WEIGHTS){const r=U(n,"labels","meanSquaredError"),s=U(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=U(t,"weights","meanSquaredError")),Rr(r.shape,s.shape,"Error in meanSquaredError: ");const a=rE(r,s);return fo(a,o,i)}const yre=K({meanSquaredError_:RO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(n,e){const t=U(n,"labels","sigmoidCrossEntropyWithLogits"),i=U(e,"logits","sigmoidCrossEntropyWithLogits");Rr(t.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=If(i),s=Ge(i,t),o=$T(fs(Ol(zi(i))));return Dt(mt(r,s),o)}function PO(n,e,t,i=0,r=ni.SUM_BY_NONZERO_WEIGHTS){let s=U(n,"multiClassLabels","sigmoidCrossEntropy");const o=U(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=U(t,"weights","sigmoidCrossEntropy")),Rr(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),i>0){const c=pt(i),u=pt(1),h=pt(.5);s=Dt(Ge(s,mt(u,c)),Ge(h,c))}const l=IO(s,o);return fo(l,a,r)}const vre=K({sigmoidCrossEntropy_:PO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return to((r,s,o)=>{const l=F3(s,[t],!0),c=mt(Ft(s,"float32"),l);o([r,c]);const u=Ol(Ge(c,r));return{value:Gt(u,[t]),gradFunc:(f,p)=>{const[m,y]=p,g=er(f.shape,[t]);return[Ge(he(f,g),mt(Ft(m,"float32"),fs(y))),Ge(he(f,g),mt(fs(y),Ft(m,"float32")))]}}})(n,e)}function LO(n,e,t,i=0,r=ni.SUM_BY_NONZERO_WEIGHTS){let s=U(n,"onehotLabels","softmaxCrossEntropy");const o=U(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=U(t,"weights","softmaxCrossEntropy")),Rr(s.shape,o.shape,"Error in softmaxCrossEntropy: "),i>0){const c=pt(i),u=pt(1),h=pt(s.shape[1]);s=Dt(Ge(s,mt(u,c)),Lt(c,h))}const l=NO(s,o);return fo(l,a,r)}const xre=K({softmaxCrossEntropy_:LO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(n,e,t,i){const r=U(n,"indices","sparseFillEmptyRows","int32"),s=U(e,"values","sparseFillEmptyRows"),o=U(t,"denseShape","sparseFillEmptyRows","int32"),a=U(i,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:s,denseShape:o,defaultValue:a},c=Y.runKernel(gS,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const kO=K({sparseFillEmptyRows_:DO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(n,e,t){const i=U(n,"inputIndices","sparseReshape","int32"),r=U(e,"inputShape","sparseReshape","int32"),s=U(t,"newShape","sparseReshape","int32");if(i.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${i.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:i,inputShape:r,newShape:s},a=Y.runKernel(yS,o);return{outputIndices:a[0],outputShape:a[1]}}const FO=K({sparseReshape_:OO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $O(n,e,t){const i=U(n,"data","sparseSegmentMean"),r=U(e,"indices","sparseSegmentMean","int32"),s=U(t,"segmentIds","sparseSegmentMean","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const o={data:i,indices:r,segmentIds:s};return Y.runKernel(vS,o)}const BO=K({sparseSegmentMean_:$O});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zO(n,e,t){const i=U(n,"data","sparseSegmentSum"),r=U(e,"indices","sparseSegmentSum","int32"),s=U(t,"segmentIds","sparseSegmentSum","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const o={data:i,indices:r,segmentIds:s};return Y.runKernel(xS,o)}const UO=K({sparseSegmentSum_:zO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VO(n,e,t,i,r,s,o,a){const l=U(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=U(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:i,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},d=Y.runKernel(SS,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}const GO=K({stringNGrams_:VO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HO(n,e,t=!0){const i=U(n,"input","stringSplit","string"),r=U(e,"delimiter","stringSplit","string");if(i.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${i.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const s={skipEmpty:t},o={input:i,delimiter:r},a=Y.runKernel(TS,o,s);return{indices:a[0],values:a[1],shape:a[2]}}const WO=K({stringSplit_:HO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jO(n,e){const t=U(n,"input","stringToHashBucketFast","string"),i={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return Y.runKernel(ES,r,i)}const qO=K({stringToHashBucketFast_:jO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const di={flipLeftRight:Vk,grayscaleToRGB:Hk,resizeNearestNeighbor:pO,resizeBilinear:dO,rotateWithOffset:jk,cropAndResize:zk,nonMaxSuppression:Xk,nonMaxSuppressionAsync:nO,nonMaxSuppressionWithScore:rO,nonMaxSuppressionWithScoreAsync:oO,nonMaxSuppressionPadded:lO,nonMaxSuppressionPaddedAsync:uO,threshold:yO,transform:xO},ih={sparseFillEmptyRows:kO,sparseReshape:FO,sparseSegmentMean:BO,sparseSegmentSum:UO},up={stringNGrams:GO,stringSplit:WO,stringToHashBucketFast:qO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XO=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:n=>n())();function YO(){return new Promise(n=>XO(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hE(n,e){const t=n[0].length;n.forEach((r,s)=>{G(r.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),G(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const i=n[0];n.forEach((r,s)=>{for(let o=0;o<t;o++)G(o===e||r[o]===i[o],()=>`Error in concat${t}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${i}) along the non-concatenated axis ${s}.`)})}function Qo(n,e){const t=n[0].slice();for(let i=1;i<n.length;i++)t[e]+=n[i][e];return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dy=30;function kf(n){return n<=Dy?n:Rm(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(n,e,t){const i=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[i,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ky(n,e,t,i=!0){let r=[];if(i)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const s=e.length;for(let o=0;o<s;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(s+1))}return r}function Oy(n,e,t=!0){const i=[];if(t){i.push(e);for(let r=e+1;r<n;++r)r<=2*e?(i.push(r),i.push(r-(e+1))):i.push(r)}else{const r=[],s=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?s.push(o):r.push(o);i.push(...r),i.push(0),i.push(...s)}return i}function Fy(n,e,t,i=!0){const r=[];i?r.push(n[0]/t):r.push(n[0]*t);for(let s=1;s<n.length;++s)s<=e.length?i?r.push(e[s-1]*n[s]):r.push(n[s]/e[s-1]):r.push(n[s]);return r}function fE(n,e){const t=[0];for(let i=0;i<e;++i)t.push(n[i][0]);return t}function pE(n,e,t){const i=n.slice(0,1);for(let r=0;r<t;++r)i.push(n[r+1]-e[r][0]-e[r][1]);return i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mE=1.7580993408473768,gE=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE=.3275911,vE=.254829592,xE=-.284496736,_E=1.421413741,bE=-1.453152027,wE=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eg(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let i=0;i<t.length;i+=2)t[i]=n[i/2],t[i+1]=e[i/2];return t}function KO(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let i=0;i<n.length;i+=2)e[i/2]=n[i],t[i/2]=n[i+1];return{real:e,imag:t}}function ZO(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),i=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],i[Math.floor(r/4)]=n[r+1];return{real:t,imag:i}}function JO(n){const e=Math.floor(n.length/4),t=new Float32Array(e),i=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],i[Math.floor(r/4)]=n[r+1];return{real:t,imag:i}}function QO(n,e){const t=n[e*2],i=n[e*2+1];return{real:t,imag:i}}function eF(n,e,t,i){n[i*2]=e,n[i*2+1]=t}function tF(n,e){const t=new Float32Array(n/2),i=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const s=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(s),i[r]=Math.sin(s)}return{real:t,imag:i}}function nF(n,e,t){const i=(t?2:-2)*Math.PI*(n/e),r=Math.cos(i),s=Math.sin(i);return{real:r,imag:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hp="->",iF=/->/g,P0=",",N0="...";function SE(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(iF,"").length)/hp.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${hp}").`);const[i,r]=n.split(hp);G(i.indexOf(N0)===-1,()=>`The ellipsis notation ("${N0}") is not supported yet.`);const s=i.split(P0),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const f=r[d];if(!s.some(p=>p.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<i.length;++d){const f=i[d];a.indexOf(f)===-1&&f!==P0&&a.push(f)}const l=new Array(s.length);for(let d=0;d<o;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let f=0;f<s[d].length;++f)l[d].push(a.indexOf(s[d][f]))}const c=a.length,u=r.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function TE(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const i=[];for(let r=0;r<n;++r)t[r]===-1&&i.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:i}}function EE(n,e,t){const i=new Array(n);for(let r=0;r<t.length;++r){const s=t[r].shape;for(let o=0;o<e[r].length;++o)i[e[r][o]]===void 0?i[e[r][o]]=s[o]:G(i[e[r][o]]===s[o],()=>`Expected dimension ${i[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function CE(n,e){const t=n,i=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)i.push([]);const s=[];for(let o=0;o<t.length;++o){const a=t[o],l=rF(e,a);for(const c of l)s.indexOf(c)===-1&&(i[o].push(c),s.push(c))}return{path:t,steps:i}}function ME(n){return n.every((e,t)=>e===t)}function rF(n,e){const t=[];for(let i=0;i<n.length;++i)(n[i].length===0||n[i].indexOf(e)!==-1||e===-1)&&t.push(i);return t}function AE(n,e,t=0){let i=[];if(typeof e=="number")G(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),i=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);G(r<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[s]=n.shape[t]-o}G(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),i=e}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function IE(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function PE(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function LE(n,e){return`size ${n} must be non-negative, not ${e}`}function DE(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function kE(n,e){const t=we(n),i=we(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${i}. inputShape=${n} outputShape= ${e}`}function OE(n,e){const t=we(n),i=we(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${i}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tg(){return"segment ids must be >= 0"}function FE(){return"segment ids are not increasing"}function $E(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function BE(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(n,e){let t=!1,i;for(n<=Dy?(i=n,t=!0):i=Rm(n,Math.floor(Math.sqrt(n)));!t;)i>e||i===n?t=!0:i=Rm(n,i+1);return i}function UE(n,e,t){const i=[],r=n.length;for(let s=0;s<r;s++)s!==e?i.push(n[s]):i.push(t);return i}function VE(n,e,t,i){const r=e.shape.length,s=n.shape.length;if(i!==0&&(i<-r||i>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${i}`);if(i<0&&(i+=r),i>s)throw new Error(`batchDims (${i}) must be less than rank(x) (
    ${s}).`);if(t<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${t}).`);for(let h=0;h<i;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<i;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=i;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=i;h<r;h++)a.push(e.shape[h]);for(let h=t+1;h<s;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}var sF=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:zE,computeOutShape:UE,collectGatherOpShapeInfo:VE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gc(n){try{return n.map(e=>gl(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function GE(n){return n.map(e=>Go(e))}var oF=Object.freeze(Object.defineProperty({__proto__:null,slice_util:_N,segment_util:sF,fromUint8ToStringArray:Gc,fromStringArrayToUint8:GE,upcastType:Ur,axesAreInnerMostDims:Cy,combineLocations:LT,computeOutAndReduceShapes:Xr,expandShapeToKeepDim:er,assertAxesAreInnerMostDims:Pr,getAxesPermutation:tr,getUndoAxesPermutation:My,getInnerMostAxes:nr,getBroadcastDims:Ed,getReductionAxes:aT,assertAndGetBroadcastShape:Et,assertParamsConsistent:hE,computeOutShape:Qo,computeDilation2DInfo:CT,computePool2DInfo:Fl,computePool3DInfo:Ru,computeConv2DInfo:Ni,computeConv3DInfo:Iu,computeDefaultPad:Sy,tupleValuesAreOne:Bc,eitherStridesOrDilationsAreOne:Li,convertConv2DDataFormat:$l,checkPadOnDimRoundingMode:Qi,getFusedDyActivation:Pf,getFusedBiasGradient:Nf,applyActivation:Lf,shouldFuse:Df,PARALLELIZE_THRESHOLD:Dy,computeOptimalWindowSize:kf,getImageCenter:dE,getReshaped:ky,getPermuted:Oy,getReshapedPermuted:Fy,getSliceBeginCoords:fE,getSliceSize:pE,prepareAndValidate:cT,validateUpdateShape:uT,validateInput:hT,calculateShapes:_y,SELU_SCALEALPHA:mE,SELU_SCALE:gE,ERF_P:yE,ERF_A1:vE,ERF_A2:xE,ERF_A3:_E,ERF_A4:bE,ERF_A5:wE,warn:xr,log:WI,mergeRealAndImagArrays:eg,splitRealAndImagArrays:KO,complexWithEvenIndex:ZO,complexWithOddIndex:JO,getComplexWithIndex:QO,assignToTypedArray:eF,exponents:tF,exponent:nF,decodeEinsumEquation:SE,getEinsumPermutation:TE,checkEinsumDimSizes:EE,getEinsumComputePath:CE,isIdentityPermutation:ME,prepareSplitSize:AE,getSparseFillEmptyRowsIndicesDenseShapeMismatch:RE,getSparseFillEmptyRowsNegativeIndexErrorMessage:IE,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:PE,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:NE,getSparseReshapeNegativeOutputDimErrorMessage:LE,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:DE,getSparseReshapeInputOutputMultipleErrorMessage:kE,getSparseReshapeInputOutputMismatchErrorMessage:OE,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:tg,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:FE,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:$E,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:BE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aF=ne();aF.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var $i;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})($i||($i={}));var L0;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(L0||(L0={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lF={};function HE(n){return lF[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E(n,e,t,i,r){const s=e.inputParams[n];if(s&&s.inputIndexStart!==void 0){const a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return Wn(e.inputNames[s.inputIndexStart],t,i,r);if(s.type==="tensors")return e.inputNames.slice(a,l).map(d=>Wn(d,t,i,r));const c=Wn(e.inputNames.slice(a)[0],t,i,r),u=c.dataSync();return s.type==="number"?u[0]:Im(c.shape,u)}const o=e.attrParams[n];return o&&o.value}function Wn(n,e,t,i){const[r,s]=ui(n);if(i!=null){const a=i.getHashTableHandleByName(r);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[Rd(r,a)]);return o!==void 0?e[Rd(r,o)][s]:void 0}function cF(n,e,t){return e[Rd(n,t.currentContextId)]}function Fr(n,e){const[t,i,r]=ui(n);return[Rd(t,e&&e.currentContextId),i,r]}function Rd(n,e){return e?`${n}-${e}`:n}function ui(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],i=e.length===3?e[1]:void 0,r=Number(e[e.length-1]);return[t,r,i]}function cd(n,e,t){let i=E("pad",n,e,t);if(i==="explicit"){i=E("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=i[s*2],r[s][1]=i[s*2+1];return r}return i}function os(n){return n.kept?n:Ho(n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var hF=Object.freeze(Object.defineProperty({__proto__:null,json:uF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dF=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var fF=Object.freeze(Object.defineProperty({__proto__:null,json:dF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pF=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var mF=Object.freeze(Object.defineProperty({__proto__:null,json:pF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gF=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var yF=Object.freeze(Object.defineProperty({__proto__:null,json:gF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vF=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var xF=Object.freeze(Object.defineProperty({__proto__:null,json:vF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _F=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bF=Object.freeze(Object.defineProperty({__proto__:null,json:_F},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wF=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var SF=Object.freeze(Object.defineProperty({__proto__:null,json:wF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var EF=Object.freeze(Object.defineProperty({__proto__:null,json:TF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CF=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var MF=Object.freeze(Object.defineProperty({__proto__:null,json:CF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AF=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var RF=Object.freeze(Object.defineProperty({__proto__:null,json:AF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var PF=Object.freeze(Object.defineProperty({__proto__:null,json:IF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NF=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var LF=Object.freeze(Object.defineProperty({__proto__:null,json:NF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var kF=Object.freeze(Object.defineProperty({__proto__:null,json:DF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var FF=Object.freeze(Object.defineProperty({__proto__:null,json:OF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $F=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var BF=Object.freeze(Object.defineProperty({__proto__:null,json:$F},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var UF=Object.freeze(Object.defineProperty({__proto__:null,json:zF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var GF=Object.freeze(Object.defineProperty({__proto__:null,json:VF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var WF=Object.freeze(Object.defineProperty({__proto__:null,json:HF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var qF=Object.freeze(Object.defineProperty({__proto__:null,json:jF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D0{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[hF,fF,mF,yF,xF,bF,SF,EF,MF,RF,PF,LF,kF,FF,BF,UF,GF,WF,qF],t=[].concat(...e.map(i=>i.json));this.opMappers=t.reduce((i,r)=>(i[r.tfOpName]=r,i),{})}transformGraph(e,t={}){const i=e.node,r=[],s=[],o=[],a=i.reduce((m,y)=>(m[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?r.push(m[y.name]):y.op==="Const"?s.push(m[y.name]):(y.input==null||y.input.length===0)&&o.push(m[y.name]),m),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(m=>{const y=a[m];y.inputNames.forEach((g,v)=>{const[_,,b]=Fr(g),S=a[_];if(S.outputs!=null){const w=S.outputs.indexOf(b);if(w!==-1){const T=`${_}:${w}`;y.inputNames[v]=T}}y.inputs.push(S),S.children.push(y)})}),Object.keys(h).length===0?d.forEach(m=>{const y=a[m];y.children.length===0&&c.push(y)}):Object.keys(h).forEach(m=>{const[y]=Fr(m),g=a[y];g!=null&&(g.signatureKey=h[m],c.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[y]=Fr(m),g=a[y];g&&(g.signatureKey=u[m],l.push(g))}):l=r;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((m,y)=>(m[y.signature.name]=this.mapFunction(y),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:s,placeholders:r,signature:t,functions:f};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,i)=>(t[e[i].name]=i,t),{})}mapNode(e){const t=HE(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const i={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(i.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(i.attrParams=t.attrs.reduce((r,s)=>{const o=s.type;let a;switch(s.type){case"string":a=ng(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=ng(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=cg(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=cg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=rg(e.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=rg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=lg(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=lg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=ig(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=ig(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=hg(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=hg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=ag(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=ag(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=ug(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=ug(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=sg(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=sg(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=og(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=og(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=k0(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=k0(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:a,type:o},r},{})),i}mapFunction(e){const t=e.nodeDef,i=[],r=[];let s={};t!=null&&(s=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=Fr(h.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$y(h.type),type:"dtype"}},children:[]};f.signatureKey=h.name,o.push(f),s[d]=f}),Object.keys(s).forEach(h=>{const d=s[h];d.inputNames.forEach((f,p)=>{const[m,,y]=Fr(f),g=s[m];if(g.outputs!=null){const v=g.outputs.indexOf(y);if(v!==-1){const _=`${m}:${v}`;d.inputNames[p]=_}}d.inputs.push(g),g.children.push(d)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[d,f]=Fr(c[h.name]),p=s[d];p!=null&&(p.defaultOutput=f,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:a,weights:r,placeholders:i,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,i)=>(t[i.name]=this.mapArgToTensorInfo(i),t),{}),outputs:e.signature.outputArg.reduce((t,i)=>(t[i.name]=this.mapArgToTensorInfo(i,e.ret),t),{})}}mapArgToTensorInfo(e,t){let i=e.name;return t!=null&&(i=t[i]),{name:i,dtype:e.type}}}function XF(n){const e=ne().global;if(typeof e.atob!="undefined")return e.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function WE(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):XF(n);return e?t:t.toLowerCase()}function ng(n,e,t,i=!1){const r=n[e];return r!=null?WE(r.s,i):t}function ig(n,e,t){const i=n[e];return i?i.b:t}function rg(n,e,t){const i=n[e]||{},r=i.i!=null?i.i:i.f!=null?i.f:t;return typeof r=="number"?r:parseInt(r,10)}function $y(n){switch(typeof n=="string"&&(n=$i[n]),n){case $i.DT_FLOAT:case $i.DT_HALF:return"float32";case $i.DT_INT32:case $i.DT_INT64:case $i.DT_INT8:case $i.DT_UINT8:return"int32";case $i.DT_BOOL:return"bool";case $i.DT_DOUBLE:return"float32";case $i.DT_STRING:return"string";default:return null}}function k0(n,e,t){const i=n[e];return i&&i.func?i.func.name:t}function sg(n,e,t){const i=n[e];return i&&i.type?$y(i.type):t}function og(n,e,t){const i=n[e];return i&&i.list&&i.list.type?i.list.type.map(r=>$y(r)):t}function jE(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ag(n,e,t){const i=n[e];return i&&i.shape?jE(i.shape):t}function lg(n,e,t){const i=n[e];return i?((i.list.f&&i.list.f.length?i.list.f:i.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function cg(n,e,t,i=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(s=>WE(s,i)):t}function ug(n,e,t){const i=n[e];return i&&i.list&&i.list.shape?i.list.shape.map(r=>jE(r)):t}function hg(n,e,t){const i=n[e];return i&&i.list&&i.list.b?i.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YF{constructor(e,t,i){this.node=e,this.tensorMap=t,this.context=i,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return Wn(e,this.tensorMap,this.context)}getAttr(e,t){const i=this.node.rawAttrs[e];if(i.tensor!=null)return Wn(e,this.tensorMap,this.context);if(i.i!=null||i.f!=null)return rg(this.node.rawAttrs,e,t);if(i.s!=null)return ng(this.node.rawAttrs,e,t);if(i.b!=null)return ig(this.node.rawAttrs,e,t);if(i.shape!=null)return ag(this.node.rawAttrs,e,t);if(i.type!=null)return sg(this.node.rawAttrs,e,t);if(i.list!=null){if(i.list.i!=null||i.list.f!=null)return lg(this.node.rawAttrs,e,t);if(i.list.s!=null)return cg(this.node.rawAttrs,e,t);if(i.list.shape!=null)return ug(this.node.rawAttrs,e,t);if(i.list.b!=null)return hg(this.node.rawAttrs,e,t);if(i.list.type!=null)return og(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KF=(n,e,t)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[Dt(E("a",n,e,t),E("b",n,e,t))];case"AddN":return[PN(E("tensors",n,e,t))];case"FloorMod":case"Mod":return[iD(E("a",n,e,t),E("b",n,e,t))];case"Mul":return[Ge(E("a",n,e,t),E("b",n,e,t))];case"RealDiv":case"Div":return[Lt(E("a",n,e,t),E("b",n,e,t))];case"DivNoNan":return[qL(E("a",n,e,t),E("b",n,e,t))];case"FloorDiv":return[TT(E("a",n,e,t),E("b",n,e,t))];case"Sub":return[mt(E("a",n,e,t),E("b",n,e,t))];case"Minimum":return[Ny(E("a",n,e,t),E("b",n,e,t))];case"Maximum":return[J3(E("a",n,e,t),E("b",n,e,t))];case"Pow":return[DT(E("a",n,e,t),E("b",n,e,t))];case"SquaredDifference":return[rE(E("a",n,e,t),E("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZF=(n,e,t)=>{switch(n.op){case"Abs":case"ComplexAbs":return[zi(E("x",n,e,t))];case"Acos":return[MN(E("x",n,e,t))];case"Acosh":return[RN(E("x",n,e,t))];case"Asin":return[zN(E("x",n,e,t))];case"Asinh":return[VN(E("x",n,e,t))];case"Atan":return[HN(E("x",n,e,t))];case"Atan2":return[jN(E("x",n,e,t),E("y",n,e,t))];case"Atanh":return[XN(E("x",n,e,t))];case"Ceil":return[vL(E("x",n,e,t))];case"Complex":return[eo(E("real",n,e,t),E("imag",n,e,t))];case"Cos":return[RL(E("x",n,e,t))];case"Cosh":return[PL(E("x",n,e,t))];case"Elu":return[NT(E("x",n,e,t))];case"Erf":return[JL(E("x",n,e,t))];case"Exp":return[fs(E("x",n,e,t))];case"Expm1":return[h3(E("x",n,e,t))];case"Floor":return[g3(E("x",n,e,t))];case"Log":return[zc(E("x",n,e,t))];case"Log1p":return[$T(E("x",n,e,t))];case"Imag":return[Mf(E("x",n,e,t))];case"Neg":return[Ol(E("x",n,e,t))];case"Reciprocal":return[ED(E("x",n,e,t))];case"Real":return[$c(E("x",n,e,t))];case"Relu":return[If(E("x",n,e,t))];case"Round":return[tE(E("x",n,e,t))];case"Selu":return[LD(E("x",n,e,t))];case"Sigmoid":return[Pu(E("x",n,e,t))];case"Sin":return[BD(E("x",n,e,t))];case"Sign":return[FD(E("x",n,e,t))];case"Sinh":return[UD(E("x",n,e,t))];case"Softplus":return[N3(E("x",n,e,t))];case"Sqrt":return[Jm(E("x",n,e,t))];case"Square":return[Af(E("x",n,e,t))];case"Tanh":return[lL(E("x",n,e,t))];case"Tan":return[rk(E("x",n,e,t))];case"ClipByValue":return[AT(E("x",n,e,t),E("clipValueMin",n,e,t),E("clipValueMax",n,e,t))];case"Relu6":return[eE(E("x",n,e,t))];case"Rsqrt":return[PD(Wn(n.inputNames[0],e,t))];case"Prod":return[WT(E("x",n,e,t),E("axes",n,e,t))];case"LeakyRelu":return[FT(E("x",n,e,t),E("alpha",n,e,t))];case"Prelu":return[HT(E("x",n,e,t),E("alpha",n,e,t))];case"IsNan":return[b3(Wn(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ui(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){G(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let i=0;i<n.length;i++){const r=n[i],s=e[i];G(r<0||s<0||r===s,()=>t+` Shapes ${n} and ${e} must match`)}}}function O0(n){return!(typeof n=="number"||n.some(e=>e<0))}function ac(n,e,t){let i=dg(n,t);const r=!O0(i);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${i}`);if(r&&e.forEach(s=>{i=dg(s.shape,i)}),!O0(i))throw new Error(`Non-fully-defined elementShape: ${i}`);return i}function dg(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let i=0;i<n.length;++i){const r=n[i],s=e[i];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[i]=r>=0?r:s}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JF{constructor(e,t,i,r,s,o,a){this.name=e,this.dtype=t,this.maxSize=i,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=pt(0),zs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const i=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ui(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),i.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(i.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);i.tensor=t,zs(t),i.written=!0,this.tensors[e]=i}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((i,r)=>this.write(i,t[r]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Ws([],[0].concat(this.elementShape));const i=this.readMany(e);return Ui(this.elementShape,i[0].shape,"TensorArray shape mismatch: "),ps(i,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ws([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const i=this.readMany(t);return Ui(this.elementShape,i[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${i[0].shape})`),fi(i,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const i=Math.max(...e);if(!this.dynamicSize&&i>=this.maxSize)throw new Error(`Max index must be < array size (${i}  vs. ${this.maxSize})`);this.writeMany(e,va(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let i=0;const r=e.map(l=>(i+=l,i));if(i!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${i}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=i===0?0:t.size/i,o=[];nt(()=>{t=he(t,[1,i,s]);for(let l=0;l<e.length;++l){const c=l===0?0:r[l-1],u=[0,c,0],h=[1,e[l],s];o[l]=he(Tt(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ea{constructor(e,t,i,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=i,e!=null&&e.forEach(s=>{if(i!==s.dtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${s.dtype}`);Ui(t,s.shape,"TensorList shape mismatch: "),zs(s)}),this.idTensor=pt(0),this.maxNumElements=r,zs(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ea([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,i=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(i!==-1&&this.tensors.length!==i)throw new Error(`Operation expected a list with ${i} elements but got a list with ${this.tensors.length} elements.`);Ui(e,this.elementShape,"TensorList shape mismatch: ");const r=ac(this.elementShape,this.tensors,e);return nt(()=>{const s=this.tensors.map(o=>he(o,r));return ps(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const i=ac(this.elementShape,this.tensors,e),r=this.tensors.pop();return Ui(r.shape,e,"TensorList shape mismatch: "),he(r,i)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ui(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");zs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new ea([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let i=0;i<Math.min(this.tensors.length,e);++i)t.tensors[i]=this.tensors[i];return t}getItem(e,t,i){if(i!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ui(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=ac(this.elementShape,this.tensors,t);return he(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ui(this.elementShape,t.shape,"TensorList shape mismatch: "),zs(t),this.tensors[e]=t}gather(e,t,i){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ui(this.elementShape,i,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=ac(this.elementShape,this.tensors,i);return e.length===0?Ws([],[0].concat(r)):nt(()=>{const s=e.map(o=>he(this.tensors[o],r));return ps(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ui(this.elementShape,t,"TensorList shape mismatch: ");const i=ac(this.elementShape,this.tensors,t);return this.size()===0?Ws([],[0].concat(i)):nt(()=>{const r=this.tensors.map(s=>he(s,i));return fi(r,0)})}}function QF(n,e,t){const i=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Ui(r,e,"TensorList shape mismatch: ");const s=va(n);return new ea(s,e,i)}function e$(n,e,t){return new ea([],n,e,t)}function t$(n,e,t,i){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(i!=null&&i!==-1&&r>=i)throw new Error(`Max index must be < array size (${r}  vs. ${i})`);const s=new ea([],t,n.dtype,i),o=va(n,0);return e.forEach((a,l)=>{s.setItem(a,o[l])}),s}function n$(n,e,t){let i=0;const r=e.map(u=>(i+=u,i));if(i!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${i}, and tensor's shape is: ${n.shape}`);const s=n.shape.slice(1),o=dg(s,t),a=i===0?0:n.size/i,l=nt(()=>{const u=[];n=he(n,[1,i,a]);for(let h=0;h<e.length;++h){const d=h===0?0:r[h-1],f=[0,d,0],p=[1,e[h],a];u[h]=he(Tt(n,f,p),o)}return n.dispose(),u}),c=new ea([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const i=E("thenBranch",n,e,t),r=E("elseBranch",n,e,t),s=E("cond",n,e,t),o=E("args",n,e,t);return(await s.data())[0]?t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const i=E("body",n,e,t),r=E("cond",n,e,t),s=E("args",n,e,t),o=await t.functionMap[r].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=s;for(;l[0];){const u=c;c=await t.functionMap[i].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(f=>f.id);u.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()});const d=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()})}return c}case"LoopCond":{const i=E("pred",n,e,t);return[os(i)]}case"Switch":{const i=E("pred",n,e,t);let r=E("data",n,e,t);return r.kept||(r=os(r)),(await i.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const i=n.inputNames.find(r=>Wn(r,e,t)!==void 0);if(i){const r=Wn(i,e,t);return[os(r)]}return}case"Enter":{const i=E("frameName",n,e,t),r=E("tensor",n,e,t);return t.enterFrame(i),[os(r)]}case"Exit":{const i=E("tensor",n,e,t);return t.exitFrame(),[os(i)]}case"NextIteration":{const i=E("tensor",n,e,t);return t.nextIteration(),[os(i)]}case"TensorArrayV3":{const i=E("size",n,e,t),r=E("dtype",n,e,t),s=E("elementShape",n,e,t),o=E("dynamicSize",n,e,t),a=E("clearAfterRead",n,e,t),l=E("identicalElementShapes",n,e,t),c=E("name",n,e,t),u=new JF(c,r,i,s,l,o,a);return t.addTensorArray(u),[u.idTensor,pt(1)]}case"TensorArrayWriteV3":{const i=E("tensorArrayId",n,e,t),r=E("index",n,e,t),s=E("tensor",n,e,t),o=t.getTensorArray(i.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const i=E("tensorArrayId",n,e,t),r=E("index",n,e,t);return[t.getTensorArray(i.id).read(r)]}case"TensorArrayGatherV3":{const i=E("tensorArrayId",n,e,t),r=E("indices",n,e,t),s=E("dtype",n,e,t);return[t.getTensorArray(i.id).gather(r,s)]}case"TensorArrayScatterV3":{const i=E("tensorArrayId",n,e,t),r=E("indices",n,e,t),s=E("tensor",n,e,t),o=t.getTensorArray(i.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const i=E("tensorArrayId",n,e,t),r=t.getTensorArray(i.id),s=E("dtype",n,e,t);return[r.concat(s)]}case"TensorArraySplitV3":{const i=E("tensorArrayId",n,e,t),r=E("tensor",n,e,t),s=E("lengths",n,e,t),o=t.getTensorArray(i.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const i=E("tensorArrayId",n,e,t),r=t.getTensorArray(i.id);return[pt(r.size(),"int32")]}case"TensorArrayCloseV3":{const i=E("tensorArrayId",n,e,t),r=t.getTensorArray(i.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const i=E("tensorListId",n,e,t),r=E("index",n,e,t),s=E("tensor",n,e,t),o=t.getTensorList(i.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const i=E("tensorListId",n,e,t),r=E("index",n,e,t),s=E("elementShape",n,e,t),o=E("elementDType",n,e,t);return[t.getTensorList(i.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const i=E("indices",n,e,t),r=E("tensor",n,e,t),s=E("elementShape",n,e,t),o=E("numElements",n,e,t),a=t$(r,i,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const i=E("elementShape",n,e,t),r=E("elementDType",n,e,t);let s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";const o=E(s,n,e,t),a=e$(i,r,o);return t.addTensorList(a),[a.idTensor]}case"TensorListGather":{const i=E("tensorListId",n,e,t),r=E("indices",n,e,t),s=E("elementShape",n,e,t),o=E("elementDType",n,e,t);return[t.getTensorList(i.id).gather(r,o,s)]}case"TensorListStack":{const i=E("tensorListId",n,e,t),r=E("elementShape",n,e,t),s=E("elementDType",n,e,t),o=E("numElements",n,e,t);return[t.getTensorList(i.id).stack(r,s,o)]}case"TensorListFromTensor":{const i=E("tensor",n,e,t),r=E("elementShape",n,e,t),s=E("elementDType",n,e,t),o=QF(i,r,s);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const i=E("tensorListId",n,e,t),r=t.getTensorList(i.id),s=E("dtype",n,e,t),o=E("elementShape",n,e,t);return[r.concat(s,o)]}case"TensorListPushBack":{const i=E("tensorListId",n,e,t),r=E("tensor",n,e,t),s=t.getTensorList(i.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const i=E("tensorListId",n,e,t),r=E("elementShape",n,e,t),s=E("elementDType",n,e,t);return[t.getTensorList(i.id).popBack(r,s)]}case"TensorListSplit":{const i=E("tensor",n,e,t),r=E("elementShape",n,e,t),s=E("lengths",n,e,t),o=n$(i,s,r);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const i=E("tensorListId",n,e,t),r=t.getTensorList(i.id);return[pt(r.size(),"int32")]}case"TensorListResize":{const i=E("tensorListId",n,e,t),r=E("size",n,e,t),o=t.getTensorList(i.id).resize(r);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0(n,e,t){const[i,r]=E("fusedOps",n,e,t),s=i==="biasadd",o=!s,a=r==="prelu",l=i==="fusedbatchnorm",c=E("numArgs",n,e,t);if(s){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=E("strides",n,e,t),h=cd(n,e,t),d=E("dataFormat",n,e,t).toUpperCase(),f=E("dilations",n,e,t);let[p,m]=E("args",n,e,t);o&&(m=p,p=void 0);const y=E("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:d,dilations:f,biasArg:p,preluArg:m,activationFunc:r,leakyreluAlpha:y}}const r$=(n,e,t)=>{switch(n.op){case"Conv1D":{const i=E("stride",n,e,t),r=E("pad",n,e,t),s=E("dataFormat",n,e,t).toUpperCase(),o=E("dilation",n,e,t);return[wL(E("x",n,e,t),E("filter",n,e,t),i,r,s,o)]}case"Conv2D":{const i=E("strides",n,e,t),r=cd(n,e,t),s=E("dataFormat",n,e,t).toUpperCase(),o=E("dilations",n,e,t);return[Ty(E("x",n,e,t),E("filter",n,e,t),[i[1],i[2]],r,s,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:r,dataFormat:s,dilations:o,biasArg:a,preluArg:l,activationFunc:c,leakyreluAlpha:u}=F0(n,e,t);return[Tk({x:E("x",n,e,t),filter:E("filter",n,e,t),strides:[i[1],i[2]],pad:r,dataFormat:s,dilations:[o[1],o[2]],bias:a,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:r,dataFormat:s,dilations:o,biasArg:a,preluArg:l,activationFunc:c,leakyreluAlpha:u}=F0(n,e,t);return[Ik({x:E("x",n,e,t),filter:E("filter",n,e,t),strides:[i[1],i[2]],pad:r,dataFormat:s,dilations:[o[1],o[2]],bias:a,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=E("outputShape",n,e,t),r=E("strides",n,e,t),s=cd(n,e,t);return[EL(E("x",n,e,t),E("filter",n,e,t),i,[r[1],r[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=E("strides",n,e,t),r=cd(n,e,t),s=E("dilations",n,e,t),o=E("dataFormat",n,e,t).toUpperCase();return[IT(E("input",n,e,t),E("filter",n,e,t),[i[1],i[2]],r,o,[s[1],s[2]])]}case"Conv3D":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("dataFormat",n,e,t).toUpperCase(),o=E("dilations",n,e,t);return[ML(E("x",n,e,t),E("filter",n,e,t),[i[1],i[2],i[3]],r,s,[o[1],o[2],o[3]])]}case"AvgPool":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("kernelSize",n,e,t);return[tL(E("x",n,e,t),[s[1],s[2]],[i[1],i[2]],r)]}case"MaxPool":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("kernelSize",n,e,t);return[j3(E("x",n,e,t),[s[1],s[2]],[i[1],i[2]],r)]}case"MaxPoolWithArgmax":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("kernelSize",n,e,t),o=E("includeBatchInIndex",n,e,t),{result:a,indexes:l}=K3(E("x",n,e,t),[s[1],s[2]],[i[1],i[2]],r,o);return[a,l]}case"AvgPool3D":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("kernelSize",n,e,t);return[iL(E("x",n,e,t),[s[1],s[2],s[3]],[i[1],i[2],i[3]],r)]}case"MaxPool3D":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("kernelSize",n,e,t);return[X3(E("x",n,e,t),[s[1],s[2],s[3]],[i[1],i[2],i[3]],r)]}case"Dilation2D":{const i=E("strides",n,e,t),r=E("pad",n,e,t),s=E("dilations",n,e,t),o=i[1],a=i[2],l=s[1],c=s[2];return[VL(E("x",n,e,t),E("filter",n,e,t),[o,a],r,[l,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$=(n,e,t)=>{switch(n.op){case"Fill":{const i=E("shape",n,e,t),r=E("dtype",n,e,t),s=E("value",n,e,t);return[Ry(i,s,r)]}case"LinSpace":{const i=E("start",n,e,t),r=E("stop",n,e,t),s=E("num",n,e,t);return[C3(i,r,s)]}case"Multinomial":{const i=E("logits",n,e,t),r=E("numSamples",n,e,t),s=E("seed",n,e,t);return[sD(i,r,s)]}case"OneHot":{const i=E("indices",n,e,t),r=E("depth",n,e,t),s=E("onValue",n,e,t),o=E("offValue",n,e,t);return[sN(i,r,s,o)]}case"Ones":return[Py(E("shape",n,e,t),E("dtype",n,e,t))];case"OnesLike":return[lD(E("x",n,e,t))];case"RandomUniform":return[SD(E("shape",n,e,t),E("minval",n,e,t),E("maxval",n,e,t),E("dtype",n,e,t))];case"Range":{const i=E("start",n,e,t),r=E("stop",n,e,t),s=E("step",n,e,t);return[Uc(i,r,s,E("dtype",n,e,t))]}case"TruncatedNormal":{const i=E("shape",n,e,t),r=E("mean",n,e,t),s=E("stdDev",n,e,t),o=E("seed",n,e,t);return[lk(i,r,s,E("dtype",n,e,t),o)]}case"Zeros":return[no(E("shape",n,e,t),E("dtype",n,e,t))];case"ZerosLike":return[Ey(E("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dp(n,e,t){const i=E("boxes",n,e,t),r=E("scores",n,e,t),s=E("maxOutputSize",n,e,t),o=E("iouThreshold",n,e,t),a=E("scoreThreshold",n,e,t),l=E("softNmsSigma",n,e,t);return{boxes:i,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const o$=async(n,e,t)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=dp(n,e,t),c=await di.nonMaxSuppressionWithScoreAsync(i,r,s,o,a,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:a}=dp(n,e,t),l=E("padToMaxOutputSize",n,e,t),c=await di.nonMaxSuppressionPaddedAsync(i,r,s,o,a,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:a}=dp(n,e,t);return[await di.nonMaxSuppressionAsync(i,r,s,o,a)]}case"Where":{const i=Ft(E("condition",n,e,t),"bool"),r=[await fk(i)];return i.dispose(),r}case"ListDiff":return kD(E("x",n,e,t),E("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$=(n,e,t)=>{switch(n.op){case"LowerBound":{const i=E("sortedSequence",n,e,t),r=E("values",n,e,t);return[H3(i,r)]}case"TopKV2":{const i=E("x",n,e,t),r=E("k",n,e,t),s=E("sorted",n,e,t),o=ok(i,r,s);return[o.values,o.indices]}case"UpperBound":{const i=E("sortedSequence",n,e,t),r=E("values",n,e,t);return[hk(i,r)]}case"Unique":{const i=E("x",n,e,t),r=A0(i);return[r.values,r.indices]}case"UniqueV2":{const i=E("x",n,e,t),r=E("axis",n,e,t),s=A0(i,r);return[s.values,s.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l$=(n,e,t)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const i=E("default",n,e,t);return[Wn(n.name,e,t)||i];case"Placeholder":return[Wn(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=E("x",n,e,t);return[os(c)]}case"IdentityN":return E("x",n,e,t).map(c=>os(c));case"Snapshot":const r=E("x",n,e,t);return[os(r)];case"Shape":return[Dn(E("x",n,e,t).shape,"int32")];case"ShapeN":return E("x",n,e,t).map(c=>Dn(c.shape));case"Size":return[pt(E("x",n,e,t).size,"int32")];case"Rank":return[pt(E("x",n,e,t).rank,"int32")];case"NoOp":return[pt(1)];case"Print":const s=E("x",n,e,t),o=E("data",n,e,t),a=E("message",n,e,t),l=E("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c${constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=pt(0),this.tensorMap=new Map,zs(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const i=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),nt(()=>{const r=va(t),s=i.length,o=r.length;G(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let a=0;a<s;a++){const l=i[a],c=r[a];zs(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const i=await e.data();return nt(()=>{const r=[];for(let s=0;s<i.length;s++){const o=i[s],a=this.findWithDefault(o,t);r.push(a)}return ps(r)})}findWithDefault(e,t){const i=this.tensorMap.get(e);return i!=null?i:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u$=async(n,e,t,i)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=E("keyDType",n,e,t),s=E("valueDType",n,e,t),o=new c$(r,s);return i.addHashTable(n.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=E("tableHandle",n,e,t,i),s=E("keys",n,e,t),o=E("values",n,e,t);return[await i.getHashTableById(r.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=E("tableHandle",n,e,t,i),s=E("keys",n,e,t),o=E("defaultValue",n,e,t);return[await i.getHashTableById(r.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=E("tableHandle",n,e,t,i);return[i.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$=(n,e,t)=>{switch(n.op){case"ResizeBilinear":{const i=E("images",n,e,t),r=E("size",n,e,t),s=E("alignCorners",n,e,t),o=E("halfPixelCenters",n,e,t);return[di.resizeBilinear(i,[r[0],r[1]],s,o)]}case"ResizeNearestNeighbor":{const i=E("images",n,e,t),r=E("size",n,e,t),s=E("alignCorners",n,e,t),o=E("halfPixelCenters",n,e,t);return[di.resizeNearestNeighbor(i,[r[0],r[1]],s,o)]}case"CropAndResize":{const i=E("image",n,e,t),r=E("boxes",n,e,t),s=E("boxInd",n,e,t),o=E("cropSize",n,e,t),a=E("method",n,e,t),l=E("extrapolationValue",n,e,t);return[di.cropAndResize(i,r,s,o,a,l)]}case"ImageProjectiveTransformV3":{const i=E("images",n,e,t),r=E("transforms",n,e,t),s=E("outputShape",n,e,t),o=E("fillValue",n,e,t),a=E("interpolation",n,e,t),l=E("fillMode",n,e,t);return[di.transform(i,r,a.toLowerCase(),l.toLowerCase(),o,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d$=(n,e,t)=>{switch(n.op){case"Equal":return[PT(E("a",n,e,t),E("b",n,e,t))];case"NotEqual":return[GT(E("a",n,e,t),E("b",n,e,t))];case"Greater":return[Rf(E("a",n,e,t),E("b",n,e,t))];case"GreaterEqual":return[OT(E("a",n,e,t),E("b",n,e,t))];case"Less":return[T3(E("a",n,e,t),E("b",n,e,t))];case"LessEqual":return[Iy(E("a",n,e,t),E("b",n,e,t))];case"LogicalAnd":return[BT(E("a",n,e,t),E("b",n,e,t))];case"LogicalNot":return[z3(E("a",n,e,t))];case"LogicalOr":return[V3(E("a",n,e,t),E("b",n,e,t))];case"Select":case"SelectV2":return[vl(E("condition",n,e,t),E("a",n,e,t),E("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f$=(n,e,t)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[xn(E("a",n,e,t),E("b",n,e,t),E("transposeA",n,e,t),E("transposeB",n,e,t))];case"Einsum":return[YL(E("equation",n,e,t),...E("tensors",n,e,t))];case"Transpose":return[Xm(E("x",n,e,t),E("perm",n,e,t))];case"_FusedMatMul":const[i,r]=E("fusedOps",n,e,t),s=i==="biasadd",o=r==="prelu",a=E("numArgs",n,e,t),l=E("leakyreluAlpha",n,e,t);if(s){if(o&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,u]=E("args",n,e,t);return[Nk({a:E("a",n,e,t),b:E("b",n,e,t),transposeA:E("transposeA",n,e,t),transposeB:E("transposeB",n,e,t),bias:c,activation:r,preluActivationWeights:u,leakyreluAlpha:l})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$=(n,e,t)=>{switch(n.op){case"EuclideanNorm":return[a3(E("x",n,e,t),E("axis",n,e,t),E("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[C0(E("x",n,e,t),E("mean",n,e,t),E("variance",n,e,t),E("offset",n,e,t),E("scale",n,e,t),E("epsilon",n,e,t))];case"FusedBatchNormV3":return[C0(E("x",n,e,t),E("mean",n,e,t),E("variance",n,e,t),E("offset",n,e,t),E("scale",n,e,t),E("epsilon",n,e,t))];case"LRN":return[A3(E("x",n,e,t),E("radius",n,e,t),E("bias",n,e,t),E("alpha",n,e,t),E("beta",n,e,t))];case"Softmax":return[GD(E("x",n,e,t))];case"LogSoftmax":return[k3(E("x",n,e,t))];case"SparseToDense":return[oE(E("sparseIndices",n,e,t),E("outputShape",n,e,t),E("sparseValues",n,e,t),E("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m$=(n,e,t)=>{switch(n.op){case"Max":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[cl(E("x",n,e,t),o,a)]}case"Mean":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[UT(E("x",n,e,t),o,a)]}case"Min":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[Zm(E("x",n,e,t),o,a)]}case"Sum":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[Gt(E("x",n,e,t),o,a)]}case"All":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[LN(E("x",n,e,t),o,a)]}case"Any":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[kN(E("x",n,e,t),o,a)]}case"ArgMax":{const o=E("axis",n,e,t);return[ET(E("x",n,e,t),o)]}case"ArgMin":{const o=E("axis",n,e,t);return[$N(E("x",n,e,t),o)]}case"Prod":{const o=E("axis",n,e,t),a=E("keepDims",n,e,t);return[WT(E("x",n,e,t),o,a)]}case"Cumprod":{const o=E("axis",n,e,t),a=E("exclusive",n,e,t),l=E("reverse",n,e,t);return[LL(E("x",n,e,t),o,a,l)]}case"Cumsum":{const o=E("axis",n,e,t),a=E("exclusive",n,e,t),l=E("reverse",n,e,t);return[kL(E("x",n,e,t),o,a,l)]}case"Bincount":const i=E("x",n,e,t),r=E("weights",n,e,t),s=E("size",n,e,t);return[MT(i,r,s)];case"DenseBincount":{const o=E("x",n,e,t),a=E("weights",n,e,t),l=E("size",n,e,t),c=E("binaryOutput",n,e,t);return[FL(o,a,l,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$=(n,e,t)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=E("n",n,e,t),r=E("axis",n,e,t);let s=E("tensors",n,e,t);return s=s.slice(0,i),[fi(s,r)]}case"Gather":{const i=E("x",n,e,t),r=E("indices",n,e,t);return[M0(i,Ft(r,"int32"),0)]}case"GatherV2":{const i=E("axis",n,e,t),r=E("batchDims",n,e,t),s=E("x",n,e,t),o=E("indices",n,e,t);return[M0(s,Ft(o,"int32"),i,r)]}case"Reverse":{const i=E("dims",n,e,t),r=[];for(let o=0;o<i.length;o++)i[o]&&r.push(o);const s=E("x",n,e,t);return[Ad(s,r)]}case"ReverseV2":{const i=E("axis",n,e,t),r=E("x",n,e,t);return[Ad(r,i)]}case"Slice":{const i=E("begin",n,e,t),r=E("size",n,e,t);return[Tt(E("x",n,e,t),i,r)]}case"StridedSlice":{const i=E("begin",n,e,t),r=E("end",n,e,t),s=E("strides",n,e,t),o=E("beginMask",n,e,t),a=E("endMask",n,e,t),l=E("ellipsisMask",n,e,t),c=E("newAxisMask",n,e,t),u=E("shrinkAxisMask",n,e,t),h=E("x",n,e,t);return[nk(h,i,r,s,o,a,l,c,u)]}case"Pack":return nt(()=>{const i=E("axis",n,e,t),r=E("tensors",n,e,t),s=r[0].shape,o=Rt(r[0]).shape,a=r.map(l=>{const c=ln(l.shape,s);if(!c&&!ln(Rt(l).shape,o))throw new Error("the input tensors shape does not match");return c?l:he(l,s)});return[ps(a,i)]});case"Unpack":{const i=E("axis",n,e,t),r=E("tensor",n,e,t);return va(r,i)}case"Tile":{const i=E("reps",n,e,t);return[Ac(E("x",n,e,t),i)]}case"Split":case"SplitV":{const i=E("axis",n,e,t),r=E("numOrSizeSplits",n,e,t),s=E("x",n,e,t);return Vc(s,r,i)}case"ScatterNd":{const i=E("indices",n,e,t),r=E("values",n,e,t),s=E("shape",n,e,t);return[mk(i,r,s)]}case"GatherNd":{const i=E("x",n,e,t),r=E("indices",n,e,t);return[xk(i,r)]}case"SparseToDense":{const i=E("sparseIndices",n,e,t),r=E("outputShape",n,e,t),s=E("sparseValues",n,e,t),o=E("defaultValue",n,e,t);return[oE(i,s,r,s.dtype===o.dtype?o:Ft(o,s.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y$=(n,e,t)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:r,emptyRowIndicator:s,reverseIndexMap:o}=ih.sparseFillEmptyRows(E("indices",n,e,t),E("values",n,e,t),E("denseShape",n,e,t),E("defaultValue",n,e,t));return[i,r,s,o]}case"SparseReshape":{const{outputIndices:i,outputShape:r}=ih.sparseReshape(E("inputIndices",n,e,t),E("inputShape",n,e,t),E("newShape",n,e,t));return[i,r]}case"SparseSegmentMean":return[ih.sparseSegmentMean(E("data",n,e,t),E("indices",n,e,t),E("segmentIds",n,e,t))];case"SparseSegmentSum":return[ih.sparseSegmentSum(E("data",n,e,t),E("indices",n,e,t),E("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v$=(n,e,t)=>{switch(n.op){case"FFT":return[nE(E("x",n,e,t))];case"IFFT":return[Qm(E("x",n,e,t))];case"RFFT":return[iE(E("x",n,e,t))];case"IRFFT":return[qD(E("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x$=(n,e,t)=>{switch(n.op){case"StringNGrams":{const{nGrams:i,nGramsSplits:r}=up.stringNGrams(E("data",n,e,t),E("dataSplits",n,e,t),E("separator",n,e,t),E("nGramWidths",n,e,t),E("leftPad",n,e,t),E("rightPad",n,e,t),E("padWidth",n,e,t),E("preserveShortSequences",n,e,t));return[i,r]}case"StringSplit":{const{indices:i,values:r,shape:s}=up.stringSplit(E("input",n,e,t),E("delimiter",n,e,t),E("skipEmpty",n,e,t));return[i,r,s]}case"StringToHashBucketFast":return[up.stringToHashBucketFast(E("input",n,e,t),E("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _$=(n,e,t)=>{switch(n.op){case"Cast":return[Ft(E("x",n,e,t),E("dtype",n,e,t))];case"ExpandDims":{const i=E("axis",n,e,t);return[Vi(E("x",n,e,t),i)]}case"Squeeze":{const i=E("axis",n,e,t);return[Rt(E("x",n,e,t),i)]}case"Reshape":return[he(E("x",n,e,t),E("shape",n,e,t))];case"MirrorPad":return[VT(E("x",n,e,t),E("padding",n,e,t),E("mode",n,e,t))];case"PadV2":case"Pad":return[Md(E("x",n,e,t),E("padding",n,e,t),E("constantValue",n,e,t))];case"SpaceToBatchND":{const i=E("blockShape",n,e,t),r=E("paddings",n,e,t);return[hD(E("x",n,e,t),i,r)]}case"BatchToSpaceND":{const i=E("blockShape",n,e,t),r=E("crops",n,e,t);return[uL(E("x",n,e,t),i,r)]}case"DepthToSpace":{const i=E("blockSize",n,e,t),r=E("dataFormat",n,e,t).toUpperCase();return[BL(E("x",n,e,t),i,r)]}case"BroadcastTo":return[ld(E("x",n,e,t),E("shape",n,e,t))];case"BroadcastArgs":return[mL(E("s0",n,e,t),E("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0(n,e,t,i){const r=((s,o,a)=>{switch(s.category){case"arithmetic":return nt(()=>KF(s,o,a));case"basic_math":return nt(()=>ZF(s,o,a));case"control":return i$(s,o,a);case"convolution":return nt(()=>r$(s,o,a));case"creation":return nt(()=>s$(s,o,a));case"dynamic":return o$(s,o,a);case"evaluation":return nt(()=>a$(s,o,a));case"image":return nt(()=>h$(s,o,a));case"graph":return nt(()=>l$(s,o,a));case"logical":return nt(()=>d$(s,o,a));case"matrices":return nt(()=>f$(s,o,a));case"normalization":return nt(()=>p$(s,o,a));case"reduction":return nt(()=>m$(s,o,a));case"slice_join":return nt(()=>g$(s,o,a));case"sparse":return nt(()=>y$(s,o,a));case"spectral":return nt(()=>v$(s,o,a));case"string":return nt(()=>x$(s,o,a));case"transformation":return nt(()=>_$(s,o,a));case"hash_table":return u$(s,o,a,i);case"custom":const l=HE(s.op);if(l&&l.customExecutor)return l.customExecutor(new YF(s,o,a));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return pl(r)?r.then(s=>[].concat(s)):[].concat(r)}class B0{constructor(e={},t={},i={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=i,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const i=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(i))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0(n,e,t,i){const r=new Set,s=[];let o=null,a=null;const l=new Set,c=Object.keys(n).map(d=>ui(d)[0]);let u=[];i!=null&&(u=i.map(d=>ui(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((qE(d)||E$(d)||C$(d))&&o==null&&(o=d,a=o.children.map(f=>f.name).filter(f=>r.has(f))),r.add(d.name),t[d.name]==null&&c.indexOf(d.name)===-1&&u.indexOf(d.name)===-1){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),h.push(f))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:a}}function b$(n,e,t){const{usedNodes:i,inputs:r}=t,s=[],o=Object.keys(r).map(u=>ui(u)[0]).map(u=>n.nodes[u]),a=n.initNodes;o.forEach(u=>{i.has(u.name)&&s.push(u)}),n.weights.forEach(u=>{i.has(u.name)&&s.push(u)}),a!=null&&a.forEach(u=>{i.has(u.name)&&s.push(u)});const l=new Set,c=[];for(;s.length>0;){const u=s.pop();l.add(u.name),e[u.name]||c.push(u),u.children.forEach(h=>{!l.has(h.name)&&i.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&s.push(h)})}return c}const w$=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],S$=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],T$=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function qE(n){return w$.indexOf(n.op)>=0}function E$(n){return S$.indexOf(n.op)>=0}function C$(n){return T$.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Id{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(i=>{this._functionExecutorMap[i]=new Id(e.functions[i],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(i=>e[i].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const i=e.map(s=>s.name).sort(),r=t.map(s=>s.name).sort();return i.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const i=z0(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:o}=i;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const a=t.map(c=>c.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return b$(this.graph,this.weightMap,i)}execute(e,t){e=this.mapInputs(e);const i=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=i.map(h=>this.graph.nodes[ui(h)[0]]),s=t.map(h=>ui(h)[0]);let o=s.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const a=this.getCompilationKey(r,o);let l=this.compiledMap.get(a);l==null&&(l=this.compile(e,o),this.compiledMap.set(a,l));const c={},u={};return nt(()=>{const h=new B0(this.weightMap,c,u,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(m=>{const[y,g]=ui(m),v=[];v[g]=e[m],d[y]=v});const f=this.getFrozenTensorIds(d),p={};for(let m=0;m<l.length;m++){const y=l[m];if(!d[y.name]){const g=$0(y,d,h,this._resourceManager);if(pl(g))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=g,this.checkTensorForDisposal(y.name,y,d,h,f,s,p)}}return this.parent==null&&h.dispose(f),t.map(m=>Wn(m,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(i=>e[i]).map(i=>i.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,i,r,s,o,a){t.category==="control"||o.indexOf(e)!==-1||(i[e].forEach(l=>{l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const c=cF(l.name,i,r);c!=null&&c.forEach(u=>{if(u&&!u.kept&&!s.has(u.id)){const h=a[u.id];if(h===1){if(!this.keepTensorForDebug)u.dispose();else{const[d,f]=Fr(t.name,r);this.intermediateTensors[d]?this.intermediateTensors[d][f]=u:(this.intermediateTensors[d]=[],this.intermediateTensors[d][f]=u)}delete a[u.id]}else h!=null&&a[u.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(i=>{i&&!i.kept&&!i.isDisposed&&!this.keepIds.has(i.id)&&i.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,i=!1,r={},s={}){i||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=ne().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();const o=new B0(this.weightMap,r,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,o,t,i);const a=t.map(u=>Wn(u,this.tensorsMap,o)),l=a.map(u=>u.id),c=Object.keys(e).map(u=>e[u].id);return this.keepIds=new Set([...l,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),a}async executeFunctionAsync(e,t,i){const r=e.reduce((s,o,a)=>(s[this.inputs[a].name]=o,s),{});return this._executeAsync(r,this.outputNodes,!0,t,i)}async executeWithControlFlow(e,t,i,r){const s=Object.keys(e),o=s.map(_=>this.graph.nodes[ui(_)[0]]),a=i.map(_=>ui(_)[0]);let l=a.map(_=>this.graph.nodes[_]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:u,dynamicNode:h,syncInputs:d}=z0(e,l,this.weightMap,this._initNodes),f=[...o,...this.graph.weights,...this._initNodes||[]].map(_=>({node:_,contexts:t.currentContext})),p=Object.assign({},this.weightMap);Object.keys(e).forEach(_=>{const[b,S]=ui(_),w=[];w[S]=e[_],p[b]=w});const m={},y=this.getFrozenTensorIds(p),g={};for(;f.length>0;){const _=this.processStack(o,f,t,p,g,y,a,m,c);await Promise.all(_)}h==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=l.filter(_=>!qE(_)&&!Wn(_.name,p,t)).map(_=>_.name);if(v.length>0){let _="";throw h!=null&&(_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${u}]. ${_}`)}return p}processStack(e,t,i,r,s,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();i.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&E("isConstant",h.node,r,i)&&([d]=Fr(h.node.name,i)),r[h.node.name]==null){const f=$0(h.node,r,i,this._resourceManager);d||([d]=Fr(h.node.name,i));const p=i.currentContext;pl(f)?u.push(f.then(m=>(r[d]=m,i.currentContext=p,this.checkTensorForDisposal(d,h.node,r,i,o,a,l),this.processChildNodes(h.node,t,i,r,s,c),m))):(r[d]=f,this.checkTensorForDisposal(d,h.node,r,i,o,a,l),this.processChildNodes(h.node,t,i,r,s,c))}else this.processChildNodes(h.node,t,i,r,s,c)}return u}processChildNodes(e,t,i,r,s,o){e.children.forEach(a=>{const[l]=Fr(a.name,i);s[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!Wn(c,r,i))&&(s[l]=!0,t.push({contexts:i.currentContext,node:a})):a.inputNames.every(c=>!!Wn(c,r,i))&&(s[l]=!0,t.push({contexts:i.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const i=e[t],[r]=ui(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const o=s.attrParams.shape.value,a=o.length===i.shape.length&&i.shape.every((l,c)=>o[c]===-1||o[c]===l);G(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${i.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&G(i.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${i.dtype}`)})}mapInputs(e){const t={};for(const i in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[i]!=null){const r=this._signature.inputs[i];t[r.name]=e[i]}else t[i]=e[i];return t}checkInputs(e){const t=Object.keys(e).filter(i=>{const[r]=ui(i);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[i]=ui(t);if(!this.graph.nodes[i])throw new Error(`The output '${t}' is not found in the graph`)})}}class M${constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$="?tfjs-format=file",R$="model.json";class I${constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new M$}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=T0(e,this.loadOptions);else{const t=RP(e,this.loadOptions);if(t.length===0)t.push(T0(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return pl(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let i;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?i=this.artifacts.userDefinedMetadata.signature:i=this.artifacts.signature,this.signature=i,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=xP(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Id(D0.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const s=D0.Instance.transformGraph(e.modelInitializer);this.initializer=new Id(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const i=AP(e);if(i.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(i.length>1)throw new Error(`Found more than one (${i.length}) save handlers for URL '${e}'`);e=i[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof dn)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,i,r)=>(t[i]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const i=this.executor.execute(e,t);return i.length>1?i:i[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const i=await this.executor.executeAsync(e,t);return i.length>1?i:i[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,i)=>(t[i]=[e[i]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function xl(n,e={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=P$(n));const t=new I$(n,e);return await t.load(),t}function P$(n){return n.endsWith("/")||(n=n+"/"),`${n}${R$}${A$}`}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var XE=function(n,e){return(XE=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,i){t.__proto__=i}||function(t,i){for(var r in i)i.hasOwnProperty(r)&&(t[r]=i[r])})(n,e)};function YE(n,e){function t(){this.constructor=n}XE(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Ot=function(){return(Ot=Object.assign||function(n){for(var e,t=1,i=arguments.length;t<i;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};function _t(n,e,t,i){return new(t||(t=Promise))(function(r,s){function o(c){try{l(i.next(c))}catch(u){s(u)}}function a(c){try{l(i.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?r(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((i=i.apply(n,e||[])).next())})}function bt(n,e){var t,i,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,i&&(r=2&u[0]?i.return:u[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,u[1])).done)return r;switch(i=0,r&&(u=[2&u[0],r.value]),u[0]){case 0:case 1:r=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,i=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(r=o.trys,!((r=r.length>0&&r[r.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!r||u[1]>r[0]&&u[1]<r[3])){o.label=u[1];break}if(u[0]===6&&o.label<r[1]){o.label=r[1],r=u;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(u);break}r[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],i=0}finally{t=r=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function Fo(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var i=Array(n),r=0;for(e=0;e<t;e++)for(var s=arguments[e],o=0,a=s.length;o<a;o++,r++)i[r]=s[o];return i}var Vr=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Hc=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],N$={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},L$={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},D$=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],k$=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function Pd(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function KE(n){return _t(this,void 0,void 0,function(){var e,t;return bt(this,function(i){switch(i.label){case 0:return e=document.createElement("canvas"),n instanceof dn?[4,xy(n,e)]:[3,2];case 1:return i.sent(),[3,3];case 2:e.width=Pd(n.width),e.height=Pd(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),i.label=3;case 3:return[2,e]}})})}function ZE(n){return _t(this,void 0,void 0,function(){var e,t,i,r,s,o;return bt(this,function(a){switch(a.label){case 0:return n instanceof dn?(e=n.shape.slice(0,2),t=e[0],i=e[1],r=ImageData.bind,[4,xy(n)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,a.sent(),i,t]))];case 2:return s=document.createElement("canvas"),o=s.getContext("2d"),s.width=Pd(n.width),s.height=Pd(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,s.width,s.height)]}})})}function O$(n){return _t(this,void 0,void 0,function(){var e,t;return bt(this,function(i){switch(i.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,KE(n)]:[3,2];case 1:return t=i.sent(),[3,3];case 2:t=n,i.label=3;case 3:return e=t,[2,lT(e,4)]}})})}function JE(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got "+n);if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got "+n)}var lc={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},F$=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,ZE(this.mask)]})})},n.prototype.toTensor=function(){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,O$(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function $$(n){return JE(n),"person"}var B$=function(){function n(e){var t,i=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new dI.Pose({locateFile:function(r,s){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+r:s+"/"+r}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(r){if(i.height=r.image.height,i.width=r.image.width,r.poseLandmarks==null)i.poses=[];else{var s=i.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(s.segmentation={maskValueToLabel:$$,mask:new F$(r.segmentationMask)}),i.poses=[s]}})}return n.prototype.translateOutput=function(e,t){var i=this,r={keypoints:e.map(function(s,o){return{x:s.x*i.width,y:s.y*i.height,z:s.z,score:s.visibility,name:Hc[o]}})};return t!=null&&(r.keypoints3D=t.map(function(s,o){return{x:s.x,y:s.y,z:s.z,score:s.visibility,name:Hc[o]}})),r},n.prototype.estimatePoses=function(e,t,i){return _t(this,void 0,void 0,function(){var r,s;return bt(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof dn?(s=ImageData.bind,[4,xy(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,o.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},i)];case 4:return o.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function z$(n){return _t(this,void 0,void 0,function(){var e,t;return bt(this,function(i){switch(i.label){case 0:return e=function(r){if(r==null)return Ot({},lc);var s=Ot({},r);return s.runtime="mediapipe",s.enableSegmentation==null&&(s.enableSegmentation=lc.enableSegmentation),s.enableSmoothing==null&&(s.enableSmoothing=lc.enableSmoothing),s.smoothSegmentation==null&&(s.smoothSegmentation=lc.smoothSegmentation),s.modelType==null&&(s.modelType=lc.modelType),s}(n),[4,(t=new B$(e)).initialize()];case 1:return i.sent(),[2,t]}})})}function Wc(n){return n instanceof dn?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function QE(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function By(n){return n instanceof dn?n:lT(n)}function eC(n,e,t){return fg(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function fg(n,e){G(n.width!==0,function(){return e+" width cannot be 0."}),G(n.height!==0,function(){return e+" height cannot be 0."})}function fp(n,e,t){var i=t.rotationVectorStartKeypointIndex,r=t.rotationVectorEndKeypointIndex,s=n.locationData,o=s.relativeKeypoints[i].x*e.width,a=s.relativeKeypoints[i].y*e.height,l=s.relativeKeypoints[r].x*e.width,c=s.relativeKeypoints[r].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=function(d,f,p){var m,y=d.locationData,g=p.rotationVectorStartKeypointIndex,v=p.rotationVectorEndKeypointIndex;m=p.rotationVectorTargetAngle?p.rotationVectorTargetAngle:Math.PI*p.rotationVectorTargetAngleDegree/180;var _=y.relativeKeypoints[g].x*f.width,b=y.relativeKeypoints[g].y*f.height,S=y.relativeKeypoints[v].x*f.width,w=y.relativeKeypoints[v].y*f.height;return QE(m-Math.atan2(-(w-b),S-_))}(n,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function tC(n){if(n.length!==16)throw new Error("Array length must be 16 but got "+n.length);return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function pp(n,e,t,i,r,s,o){return n[e][r]*(n[t][s]*n[i][o]-n[t][o]*n[i][s])}function Bn(n,e,t){var i=(e+1)%4,r=(e+2)%4,s=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return pp(n,i,r,s,o,a,l)+pp(n,r,s,i,o,a,l)+pp(n,s,i,r,o,a,l)}function U0(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var i=[],r=0,s=n;r<s.length;r++){var o=s[r],a=o.x-.5,l=o.y-.5,c=t.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var d=o.z*e.width,f=Ot({},o);f.x=u,f.y=h,f.z=d,i.push(f)}return i}function nC(n,e){var t=function(i,r,s,o){var a=r-i,l=o-s;if(a===0)throw new Error("Original min and max are both "+i+", range cannot be 0.");var c=l/a;return{scale:c,offset:s-i*c}}(0,255,e[0],e[1]);return nt(function(){return Dt(Ge(n,t.scale),t.offset)})}function pg(n,e,t){var i,r,s,o,a,l,c,u,h,d,f,p,m,y,g=e.outputTensorSize,v=e.keepAspectRatio,_=e.borderMode,b=e.outputTensorFloatRange,S=Wc(n),w=function(M,P){return P?{xCenter:P.xCenter*M.width,yCenter:P.yCenter*M.height,width:P.width*M.width,height:P.height*M.height,rotation:P.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(S,t),T=function(M,P,L){if(L===void 0&&(L=!1),!L)return{top:0,left:0,right:0,bottom:0};var $=P.height,O=P.width;fg(P,"targetSize"),fg(M,"roi");var I,N,V=$/O,X=M.height/M.width,J=0,W=0;return V>X?(I=M.width,N=M.width*V,W=(1-X/V)/2):(I=M.height/V,N=M.height,J=(1-V/X)/2),M.width=I,M.height=N,{top:W,left:J,right:J,bottom:W}}(w,g,v),R=(i=w,r=S.width,s=S.height,o=!1,a=i.width,l=i.height,c=o?-1:1,u=Math.cos(i.rotation),h=Math.sin(i.rotation),d=i.xCenter,f=i.yCenter,p=1/r,m=1/s,(y=new Array(16))[0]=a*u*c*p,y[1]=-l*h*p,y[2]=0,y[3]=(-.5*a*u*c+.5*l*h+d)*p,y[4]=a*h*c*m,y[5]=l*u*m,y[6]=0,y[7]=(-.5*l*u-.5*a*h*c+f)*m,y[8]=0,y[9]=0,y[10]=a*p,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,tC(y));return{imageTensor:nt(function(){var M=By(n),P=wr(eC(R,S,g),[1,8]),L=_==="zero"?"constant":"nearest",$=di.transform(Vi(Ft(M,"float32")),P,"bilinear",L,0,[g.height,g.width]);return b!=null?nC($,b):$}),padding:T,transformationMatrix:R}}function V0(n,e,t,i){return i===1?.5*(n+e):n+(e-n)*t/(i-1)}function U$(n){return nt(function(){var e=function(r){return nt(function(){return[Tt(r,[0,0,0],[1,-1,1]),Tt(r,[0,0,1],[1,-1,-1])]})}(n),t=e[0],i=e[1];return{boxes:Rt(i),logits:Rt(t)}})}function iC(n){return n!=null&&n.currentTime!=null}function G0(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var a=n[o];t=Math.min(t,a.x),i=Math.max(i,a.x),r=Math.min(r,a.y),s=Math.max(s,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:r,xMax:i,yMax:s,width:i-t,height:s-r},e}function V$(n,e,t,i){return _t(this,void 0,void 0,function(){var r,s,o,a,l;return bt(this,function(c){switch(c.label){case 0:return n.sort(function(u,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,u.score)}),r=wr(n.map(function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]})),s=Dn(n.map(function(u){return u.score[0]})),[4,di.nonMaxSuppressionAsync(r,s,e,t)];case 1:return[4,(o=c.sent()).array()];case 2:return a=c.sent(),l=n.filter(function(u,h){return a.indexOf(h)>-1}),Gn([r,s,o]),[2,l]}})})}function rC(n,e){return n.map(function(t){var i=Ot(Ot({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(i.z=t.z*e.width),i})}function G$(n,e,t){return _t(this,void 0,void 0,function(){var i,r,s,o,a,l,c,u,h,d,f,p,m,y,g,v,_,b,S,w,T,R,M,P;return bt(this,function(L){switch(L.label){case 0:if(i=Rt(e,[0]),r=i.shape,s=r[0],o=r[1],a=r[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+n.length+", heatmap length: "+a);return l=[],[4,i.buffer()];case 1:for(c=L.sent(),u=0;u<n.length;u++)if(h=n[u],d=Ot({},h),l.push(d),f=Math.trunc(d.x*o),p=Math.trunc(d.y*s),!(f<0||f>=o||p<0||f>=s)){for(m=Math.trunc((t.kernelSize-1)/2),y=Math.max(0,f-m),g=Math.min(o,f+m+1),v=Math.max(0,p-m),_=Math.min(s,p+m+1),b=0,S=0,w=0,T=0,R=v;R<_;++R)for(M=y;M<g;++M)P=c.get(R,M,u),b+=P,T=Math.max(T,P),S+=M*P,w+=R*P;T>=t.minConfidenceToRefine&&b>0&&(d.x=S/o/b,d.y=w/s/b)}return i.dispose(),[2,l]}})})}function H0(n,e){var t=e.left,i=e.top,r=e.left+e.right,s=e.top+e.bottom;return n.map(function(o){return Ot(Ot({},o),{x:(o.x-t)/(1-r),y:(o.y-i)/(1-s),z:o.z/(1-r)})})}function H$(n,e,t){return Td()==="webgl"?function(i,r,s){var o=s.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:i.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `+o+`);

      setOutput(outputValue);
    }
`},l=cN();return nt(function(){var c=l.compileAndRun(a,[i,r]);return Ds().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):nt(function(){var i=mt(e,.5),r=Af(i),s=mt(1,Ny(1,Ge(r,Dt(5.68842,Ge(r,Dt(-.748699,Ge(r,Dt(-57.8051,Ge(r,Dt(291.309,Ge(r,-624.717)))))))))));return Dt(e,Ge(mt(n,e),Ge(s,t.combineWithPreviousRatio)))})}function W$(n,e,t){return _t(this,void 0,void 0,function(){var i,r,s,o,a;return bt(this,function(l){switch(l.label){case 0:return i=n[0],r=n[1],s=function(c,u,h){return nt(function(){var d,f,p,m;h.reverseOutputOrder?(f=Rt(Tt(c,[0,h.boxCoordOffset+0],[-1,1])),d=Rt(Tt(c,[0,h.boxCoordOffset+1],[-1,1])),m=Rt(Tt(c,[0,h.boxCoordOffset+2],[-1,1])),p=Rt(Tt(c,[0,h.boxCoordOffset+3],[-1,1]))):(d=Rt(Tt(c,[0,h.boxCoordOffset+0],[-1,1])),f=Rt(Tt(c,[0,h.boxCoordOffset+1],[-1,1])),p=Rt(Tt(c,[0,h.boxCoordOffset+2],[-1,1])),m=Rt(Tt(c,[0,h.boxCoordOffset+3],[-1,1]))),f=Dt(Ge(Lt(f,h.xScale),u.w),u.x),d=Dt(Ge(Lt(d,h.yScale),u.h),u.y),h.applyExponentialOnBoxSize?(p=Ge(fs(Lt(p,h.hScale)),u.h),m=Ge(fs(Lt(m,h.wScale)),u.w)):(p=Ge(Lt(p,h.hScale),u.h),m=Ge(Lt(m,h.wScale),u.h));var y=mt(d,Lt(p,2)),g=mt(f,Lt(m,2)),v=Dt(d,Lt(p,2)),_=Dt(f,Lt(m,2)),b=fi([he(y,[h.numBoxes,1]),he(g,[h.numBoxes,1]),he(v,[h.numBoxes,1]),he(_,[h.numBoxes,1])],1);if(h.numKeypoints)for(var S=0;S<h.numKeypoints;++S){var w=h.keypointCoordOffset+S*h.numValuesPerKeypoint,T=void 0,R=void 0;h.reverseOutputOrder?(T=Rt(Tt(c,[0,w],[-1,1])),R=Rt(Tt(c,[0,w+1],[-1,1]))):(R=Rt(Tt(c,[0,w],[-1,1])),T=Rt(Tt(c,[0,w+1],[-1,1])));var M=Dt(Ge(Lt(T,h.xScale),u.w),u.x),P=Dt(Ge(Lt(R,h.yScale),u.h),u.y);b=fi([b,he(M,[h.numBoxes,1]),he(P,[h.numBoxes,1])],1)}return b})}(r,e,t),o=nt(function(){var c=i;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=AT(i,-t.scoreClippingThresh,t.scoreClippingThresh)),c=Pu(c)):c}),[4,j$(s,o,t)];case 1:return a=l.sent(),Gn([s,o]),[2,a]}})})}function j$(n,e,t){return _t(this,void 0,void 0,function(){var i,r,s,o,a,l,c,u,h,d,f,p;return bt(this,function(m){switch(m.label){case 0:return i=[],[4,n.data()];case 1:return r=m.sent(),[4,e.data()];case 2:for(s=m.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&s[o]<t.minScoreThresh||(a=o*t.numCoords,l=q$(r[a+0],r[a+1],r[a+2],r[a+3],s[o],t.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,d=0;d<h;d+=t.numValuesPerKeypoint)f=a+t.keypointCoordOffset+d,p={x:r[f+0],y:t.flipVertically?1-r[f+1]:r[f+1]},u.relativeKeypoints.push(p);i.push(l)}return[2,i]}})})}function q$(n,e,t,i,r,s,o){return{score:[r],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:s?1-t:n,xMax:i,yMax:s?1-n:t,width:i-e,height:t-n}}}}function X$(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function W0(n,e,t,i){return _t(this,void 0,void 0,function(){var r,s,o,a,l,c,u,h;return bt(this,function(d){switch(d.label){case 0:return t=t||e.flipHorizontally||!1,i=i||e.flipVertically||!1,r=n.size,s=r/e.numLandmarks,[4,n.data()];case 1:for(o=d.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*s,(h={x:0,y:0}).x=t?e.inputImageWidth-o[c]:o[c],s>1&&(h.y=i?e.inputImageHeight-o[c+1]:o[c+1]),s>2&&(h.z=o[c+2]),s>3&&(h.score=X$(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function j0(n,e,t){var i=n.width,r=n.height,s=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(s=function(u,h){return h.rotation!=null?u+=h.rotation:h.rotationDegree!=null&&(u+=Math.PI*h.rotationDegree/180),QE(u)}(s,t)),s===0)n.xCenter=n.xCenter+i*t.shiftX,n.yCenter=n.yCenter+r*t.shiftY;else{var o=(e.width*i*t.shiftX*Math.cos(s)-e.height*r*t.shiftY*Math.sin(s))/e.width,a=(e.width*i*t.shiftX*Math.sin(s)+e.height*r*t.shiftY*Math.cos(s))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+a}if(t.squareLong){var l=Math.max(i*e.width,r*e.height);i=l/e.width,r=l/e.height}else if(t.squareShort){var c=Math.min(i*e.width,r*e.height);i=c/e.width,r=c/e.height}return n.width=i*t.scaleX,n.height=r*t.scaleY,n}function Y$(n,e){return n.map(function(t){var i=Ot(Ot({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),i})}var Us=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var i;return this.initialized?i=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(i=e,this.initialized=!0),this.rawValue=e,this.storedValue=i,i},n.prototype.applyWithAlpha=function(e,t,i){return this.alpha=t,this.apply(e,i)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),mp=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Us(this.getAlpha(this.minCutOff)),this.dx=new Us(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,i){if(e==null)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;this.lastTimestamp!==0&&r!==0&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*i*this.frequency:0,o=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),mg=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,i){var r=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(!this.config.disableValueScaling){if(i<this.config.minAllowedObjectScale)return Fo(e);s=1/i}return e.map(function(o,a){var l=Ot(Ot({},o),{x:r.xFilters[a].apply(o.x,t,s),y:r.yFilters[a].apply(o.y,t,s)});return o.z!=null&&(l.z=r.zFilters[a].apply(o.z,t,s)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(i){return new mp(t.config)}),this.yFilters=e.map(function(i){return new mp(t.config)}),this.zFilters=e.map(function(i){return new mp(t.config)}))},n}(),gp=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Us(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,i){if(e==null)return e;var r,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(this.lastTimestamp===-1)r=1;else{for(var o=e*i-this.lastValue*this.lastValueScale,a=s-this.lastTimestamp,l=o,c=a,u=(1+this.window.length)*(1e6/30),h=0,d=this.window;h<d.length;h++){var f=d[h];if(c+f.duration>u)break;l+=f.distance,c+=f.duration}var p=l/(1e-6*c);r=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=i,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,r)},n}(),K$=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,i){var r=this;if(e==null)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(i<this.config.minAllowedObjectScale)return Fo(e);s=1/i}return this.initializeFiltersIfEmpty(e),e.map(function(o,a){var l=Ot(Ot({},o),{x:r.xFilters[a].apply(o.x,t,s),y:r.yFilters[a].apply(o.y,t,s)});return o.z!=null&&(l.z=r.zFilters[a].apply(o.z,t,s)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(i){return new gp(t.config)}),this.yFilters=e.map(function(i){return new gp(t.config)}),this.zFilters=e.map(function(i){return new gp(t.config)}))},n}(),yp=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new K$(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new mg(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,i,r,s){if(r===void 0&&(r=!1),e==null)return this.keypointsFilter.reset(),null;var o=s!=null?function(c,u){return(c.width*u.width+c.height*u.height)/2}(s,i):1,a=r?rC(e,i):e,l=this.keypointsFilter.apply(a,t,o);return r?Y$(l,i):l},n}(),q0=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Us(t.alpha)}));for(var i=[],r=0;r<e.length;++r){var s=e[r],o=Ot({},s);o.score=this.visibilityFilters[r].apply(s.score),i.push(o)}return i},n}(),Z$={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Ca={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},J$={maxPoses:1,flipHorizontal:!1},Q$={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},eB=.3,X0={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},tB={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},nB={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},iB={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},rB={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},sB={kernelSize:7,minConfidenceToRefine:.5},Y0={alpha:.1},oB={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},aB={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},lB={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},cB={activation:"none"},uB={combineWithPreviousRatio:.7},hB=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,KE(this.mask)]})})},n.prototype.toImageData=function(){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,ZE(this.mask)]})})},n.prototype.toTensor=function(){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function dB(n){return JE(n),"person"}var fB=function(){function n(e,t,i,r,s,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=i,this.enableSegmentation=r,this.smoothSegmentation=s,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var d=[],f=0;f<h.numLayers;){for(var p=[],m=[],y=[],g=[],v=f;v<h.strides.length&&h.strides[v]===h.strides[f];){var _=V0(h.minScale,h.maxScale,v,h.strides.length);if(v===0&&h.reduceBoxesInLowestLayer)y.push(1),y.push(2),y.push(.5),g.push(.1),g.push(_),g.push(_);else{for(var b=0;b<h.aspectRatios.length;++b)y.push(h.aspectRatios[b]),g.push(_);if(h.interpolatedScaleAspectRatio>0){var S=v===h.strides.length-1?1:V0(h.minScale,h.maxScale,v+1,h.strides.length);g.push(Math.sqrt(_*S)),y.push(h.interpolatedScaleAspectRatio)}}v++}for(var w=0;w<y.length;++w){var T=Math.sqrt(y[w]);p.push(g[w]/T),m.push(g[w]*T)}var R=0,M=0;if(h.featureMapHeight.length>0)R=h.featureMapHeight[f],M=h.featureMapWidth[f];else{var P=h.strides[f];R=Math.ceil(h.inputSizeHeight/P),M=Math.ceil(h.inputSizeWidth/P)}for(var L=0;L<R;++L)for(var $=0;$<M;++$)for(var O=0;O<p.length;++O){var I={xCenter:($+h.anchorOffsetX)/M,yCenter:(L+h.anchorOffsetY)/R,width:0,height:0};h.fixedAnchorSize?(I.width=1,I.height=1):(I.width=m[O],I.height=p[O]),d.push(I)}f=v}return d}(Z$);var a=Dn(this.anchors.map(function(h){return h.width})),l=Dn(this.anchors.map(function(h){return h.height})),c=Dn(this.anchors.map(function(h){return h.xCenter})),u=Dn(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:c,y:u,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?wr([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,i){return _t(this,void 0,void 0,function(){var r,s,o,a,l,c,u,h,d,f,p,m,y,g,v,_,b,S,w,T,R,M,P;return bt(this,function(L){switch(L.label){case 0:return r=function($){var O;if((O=$==null?J$:Ot({},$)).maxPoses==null&&(O.maxPoses=1),O.maxPoses<=0)throw new Error("Invalid maxPoses "+O.maxPoses+". Should be > 0.");if(O.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return O}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=i!=null?1e3*i:iC(e)?1e6*e.currentTime:null,s=Wc(e),o=nt(function(){return Ft(By(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=L.sent()).length===0)return this.reset(),o.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,s),L.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return u=L.sent(),o.dispose(),u==null?(this.reset(),[2,[]]):(h=u.landmarks,d=u.auxiliaryLandmarks,f=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,y=this.poseLandmarkFiltering(h,d,p,s),g=y.actualLandmarksFiltered,v=y.auxiliaryLandmarksFiltered,_=y.actualWorldLandmarksFiltered,b=this.poseLandmarksToRoi(v,s),this.regionOfInterest=b,S=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(w=g!=null?rC(g,s):null)!=null&&w.forEach(function($,O){$.name=Hc[O]}),(T=_)!=null&&T.forEach(function($,O){$.name=Hc[O]}),R={score:f,keypoints:w,keypoints3D:T},S!==null&&(M=nt(function(){var $=Vi(S,2),O=Md($,[[0,0],[0,0],[0,1]]);return VT(O,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Gn(S),P={maskValueToLabel:dB,mask:new hB(M)},R.segmentation=P),[2,[R]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=H$(t,e,uB),Gn(e)),Gn(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Gn([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Gn(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=wr([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return _t(this,void 0,void 0,function(){var t,i,r,s,o,a,l,c,u,h;return bt(this,function(d){switch(d.label){case 0:return t=pg(e,tB),i=t.imageTensor,r=t.padding,s=this.detectorModel.predict(i),o=U$(s),a=o.boxes,[4,W$([l=o.logits,a],this.anchorTensor,Q$)];case 1:return(c=d.sent()).length===0?(Gn([i,s,l,a]),[2,c]):[4,V$(c,this.maxPoses,eB)];case 2:return u=d.sent(),h=function(f,p){f===void 0&&(f=[]);for(var m=p.left,y=p.top,g=p.left+p.right,v=p.top+p.bottom,_=0;_<f.length;_++){var b=f[_],S=b.locationData.relativeBoundingBox,w=(S.xMin-m)/(1-g),T=(S.yMin-y)/(1-v),R=S.width/(1-g),M=S.height/(1-v);S.xMin=w,S.yMin=T,S.width=R,S.height=M,S.xMax=w+R,S.yMax=T+M;var P=b.locationData.relativeKeypoints;P&&P.forEach(function(L){var $=(L.x-m)/(1-g),O=(L.y-y)/(1-v);L.x=$,L.y=O})}return f}(u,r),Gn([i,s,l,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return j0(fp(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,X0)},n.prototype.poseLandmarksByRoi=function(e,t){return _t(this,void 0,void 0,function(){var i,r,s,o,a,l,c,u,h,d,f,p,m,y;return bt(this,function(g){switch(g.label){case 0:if(i=Wc(t),r=pg(t,nB,e),s=r.imageTensor,o=r.padding,a=r.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType);return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(s,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(u=g.sent())==null?(Gn(c),Gn(s),[2,null]):(h=u.landmarks,d=u.auxiliaryLandmarks,f=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(i,e,o,a,h,d,p,m)]);case 2:return y=g.sent(),Gn(c),Gn(s),[2,Ot({poseScore:f},y)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,i,r,s,o,a,l){return _t(this,void 0,void 0,function(){var c,u,h,d,f,p;return bt(this,function(m){return c=H0(s,i),u=H0(o,i),h=U0(c,t),d=U0(u,t),f=function(y,g){for(var v=[],_=0,b=y;_<b.length;_++){var S=b[_],w=S.x,T=S.y,R=g.rotation,M=Math.cos(R)*w-Math.sin(R)*T,P=Math.sin(R)*w+Math.cos(R)*T,L=Ot({},S);L.x=M,L.y=P,v.push(L)}return v}(a,t),p=null,this.enableSegmentation&&(p=nt(function(){var y=l.shape,g=y[0],v=y[1],_=function(w){var T=tC(new Array(16).fill(0));T[0][0]=Bn(w,0,0),T[1][0]=-Bn(w,0,1),T[2][0]=Bn(w,0,2),T[3][0]=-Bn(w,0,3),T[0][2]=Bn(w,2,0),T[1][2]=-Bn(w,2,1),T[2][2]=Bn(w,2,2),T[3][2]=-Bn(w,2,3),T[0][1]=-Bn(w,1,0),T[1][1]=Bn(w,1,1),T[2][1]=-Bn(w,1,2),T[3][1]=Bn(w,1,3),T[0][3]=-Bn(w,3,0),T[1][3]=Bn(w,3,1),T[2][3]=-Bn(w,3,2),T[3][3]=Bn(w,3,3);for(var R=w[0][0]*T[0][0]+w[1][0]*T[0][1]+w[2][0]*T[0][2]+w[3][0]*T[0][3],M=0;M<T.length;M++)for(var P=0;P<T.length;P++)T[M][P]/=R;return T}(r),b=wr(eC(_,{width:v,height:g},e),[1,8]),S=[1,g,v,1];return Rt(di.transform(he(l,S),b,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Gn(l)),[2,{landmarks:h,auxiliaryLandmarks:d,worldLandmarks:f,segmentationMask:p}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return _t(this,void 0,void 0,function(){var t,i,r,s,o,a,l,c,u,h,d,f,p;return bt(this,function(m){switch(m.label){case 0:return t=e[0],i=e[1],r=e[2],s=e[3],o=this.enableSegmentation?e[4]:null,[4,i.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,W0(t,iB)];case 2:return[4,G$(m.sent(),r,sB)];case 3:return l=m.sent(),c=l.slice(0,33),u=l.slice(33,35),[4,W0(s,rB)];case 4:return h=m.sent(),d=h.slice(0,33),f=function(y,g,v){v===void 0&&(v=!0);for(var _=[],b=0;b<y.length;b++){var S=Ot({},g[b]);v&&(S.score=y[b].score),_.push(S)}return _}(c,d,!0),p=this.enableSegmentation?function(y,g,v){return nt(function(){var _=Rt(y,[0]),b=_.shape[2];if(b===1){var S=_;switch(g.activation){case"none":break;case"sigmoid":S=Pu(S);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+g.activation+")")}var w=v?di.resizeBilinear(S,[v.height,v.width]):S;return Rt(w,[2])}throw new Error("Unsupported number of tensor channels "+b)})}(o,cB):null,[2,{landmarks:c,auxiliaryLandmarks:u,poseScore:a,worldLandmarks:f,segmentationMask:p}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return j0(fp(G0(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,X0)},n.prototype.poseLandmarkFiltering=function(e,t,i,r){var s,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=fp(G0(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new q0(Y0)),s=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new q0(Y0)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(i),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new yp(oB)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,r,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new yp(aB)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,r,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new yp(lB)),a=this.worldLandmarksSmoothingFilterActual.apply(i,this.timestamp)}else s=e,o=t,a=i;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},n}();function pB(n){return _t(this,void 0,void 0,function(){var e,t,i,r,s,o;return bt(this,function(a){switch(a.label){case 0:return e=function(l){var c=Ot({},l==null?Ca:l);if(c.enableSmoothing==null&&(c.enableSmoothing=Ca.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Ca.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Ca.smoothSegmentation),c.modelType==null&&(c.modelType=Ca.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Ca.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,i=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([xl(e.detectorModelUrl,{fromTFHub:t}),xl(e.landmarkModelUrl,{fromTFHub:i})])];case 1:return r=a.sent(),s=r[0],o=r[1],[2,new fB(s,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var jo,rn,sC=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but encountered "+t.maxTracks);if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but encountered "+t.maxAge);if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+t.keypointTrackerParams.keypointConfidenceThreshold);if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but encountered "+t.keypointTrackerParams.minNumberOfKeypoints);for(var i=0,r=t.keypointTrackerParams.keypointFalloff;i<r.length;i++){var s=r[i];if(s<=0)throw new Error("Must specify each keypoint falloff parameterto be positive but encountered "+s)}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var i=this.computeSimilarity(e);return this.assignTracks(e,i,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(i){return e-i.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,i){for(var r=Array.from(Array(t[0].length).keys()),s=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(r.length!==0){for(var c=-1,u=-1,h=0,d=r;h<d.length;h++){var f=d[h],p=t[l][f];p>=this.minSimilarity&&p>u&&(c=f,u=p)}if(c>=0){var m=this.tracks[c];m=Object.assign(m,this.createTrack(e[l],i,m.id)),e[l].id=m.id;var y=r.indexOf(c);r.splice(y,1)}else s.push(l)}else s.push(l)}for(var g=0,v=s;g<v.length;g++){l=v[g];var _=this.createTrack(e[l],i);this.tracks.push(_),e[l].id=_.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,i){return i.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,i){var r={id:i||this.nextTrackID(),lastTimestamp:t,keypoints:Fo(e.keypoints).map(function(s){return Ot({},s)})};return e.box!==void 0&&(r.box=Ot({},e.box)),r},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(i){return!e.includes(i.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),mB=function(n){function e(t){return n.call(this,t)||this}return YE(e,n),e.prototype.computeSimilarity=function(t){var i=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(r){return i.tracks.map(function(s){return i.iou(r,s)})})},e.prototype.iou=function(t,i){var r=Math.max(t.box.xMin,i.box.xMin),s=Math.max(t.box.yMin,i.box.yMin),o=Math.min(t.box.xMax,i.box.xMax),a=Math.min(t.box.yMax,i.box.yMax);if(r>=o||s>=a)return 0;var l=(o-r)*(a-s);return l/(t.box.width*t.box.height+i.box.width*i.box.height-l)},e}(sC),gB=function(n){function e(t){var i=n.call(this,t)||this;return i.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,i.keypointFalloff=t.keypointTrackerParams.keypointFalloff,i.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,i}return YE(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var i=[],r=0,s=t;r<s.length;r++){for(var o=s[r],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}i.push(a)}return i},e.prototype.oks=function(t,i){for(var r=this.area(i.keypoints)+1e-6,s=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=i.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),h=2*this.keypointFalloff[a];s+=Math.exp(-1*u/(2*r*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:s/o},e.prototype.area=function(t){var i=this,r=t.filter(function(l){return l.score>i.keypointThreshold}),s=Math.min.apply(Math,Fo([1],r.map(function(l){return l.x}))),o=Math.max.apply(Math,Fo([0],r.map(function(l){return l.x}))),a=Math.min.apply(Math,Fo([1],r.map(function(l){return l.y})));return(o-s)*(Math.max.apply(Math,Fo([0],r.map(function(l){return l.y})))-a)},e}(sC);function oC(n){switch(n){case rn.BlazePose:return Hc.reduce(function(e,t,i){return e[t]=i,e},{});case rn.PoseNet:case rn.MoveNet:return Vr.reduce(function(e,t,i){return e[t]=i,e},{});default:throw new Error("Model "+n+" is not supported.")}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(jo||(jo={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(rn||(rn={}));var rh=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case rn.BlazePose:return N$;case rn.PoseNet:case rn.MoveNet:return L$;default:throw new Error("Model "+n+" is not supported.")}},getAdjacentPairs:function(n){switch(n){case rn.BlazePose:return k$;case rn.PoseNet:case rn.MoveNet:return D$;default:throw new Error("Model "+n+" is not supported.")}},getKeypointIndexByName:oC}),K0=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],aC={modelType:"SinglePose.Lightning",enableSmoothing:!0},Z0={},J0={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},vp={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Q0={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function yB(n,e,t,i){for(var r={},s=0,o=Vr;s<o.length;s++){var a=o[s];r[a]=[e[t[a]].y*i.height,e[t[a]].x*i.width]}if(function(v,_){return(v[_.left_hip].score>.2||v[_.right_hip].score>.2)&&(v[_.left_shoulder].score>.2||v[_.right_shoulder].score>.2)}(e,t)){var l=(r.left_hip[0]+r.right_hip[0])/2,c=(r.left_hip[1]+r.right_hip[1])/2,u=function(v,_,b,S,w){for(var T=["left_shoulder","right_shoulder","left_hip","right_hip"],R=0,M=0,P=0;P<T.length;P++)(N=Math.abs(S-b[T[P]][0]))>R&&(R=N),(V=Math.abs(w-b[T[P]][1]))>M&&(M=V);for(var L=0,$=0,O=0,I=Object.keys(b);O<I.length;O++){var N,V,X=I[O];v[_[X]].score<.2||((N=Math.abs(S-b[X][0]))>L&&(L=N),(V=Math.abs(w-b[X][1]))>$&&($=V))}return[R,M,L,$]}(e,t,r,l,c),h=u[0],d=u[1],f=u[2],p=u[3],m=Math.max(1.9*d,1.9*h,1.2*f,1.2*p),y=[l-(m=Math.min(m,Math.max(c,i.width-c,l,i.height-l))),c-m];if(m>Math.max(i.width,i.height)/2)return gg(n==null,i);var g=2*m;return{yMin:y[0]/i.height,xMin:y[1]/i.width,yMax:(y[0]+g)/i.height,xMax:(y[1]+g)/i.width,height:(y[0]+g)/i.height-y[0]/i.height,width:(y[1]+g)/i.width-y[1]/i.width}}return gg(n==null,i)}function gg(n,e){var t,i,r,s;return n?e.width>e.height?(t=1,i=e.height/e.width,r=0,s=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,i=1,r=(e.height/2-e.width/2)/e.height,s=0):e.width>e.height?(t=e.width/e.height,i=1,r=(e.height/2-e.width/2)/e.height,s=0):(t=1,i=e.height/e.width,r=0,s=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:s,yMax:r+t,xMax:s+i,height:t,width:i}}function vB(n){var e,t=n==null?aC:Ot({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(K0.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+K0);if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=jo.BoundingBox),t.trackerType===jo.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(i){var r=ex(vp,i);return r.keypointTrackerParams=Ot({},vp.keypointTrackerParams),i.keypointTrackerParams!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold=i.keypointTrackerParams.keypointConfidenceThreshold),i.keypointTrackerParams.keypointFalloff!=null&&(r.keypointTrackerParams.keypointFalloff=i.keypointTrackerParams.keypointFalloff),i.keypointTrackerParams.minNumberOfKeypoints!=null&&(r.keypointTrackerParams.minNumberOfKeypoints=i.keypointTrackerParams.minNumberOfKeypoints)),r}(t.trackerConfig):t.trackerConfig=vp;else{if(t.trackerType!==jo.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,ex(Q0,e)):t.trackerConfig=Q0}return t}function ex(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var xB=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=oC(rn.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new mg(J0),this.cropRegionFilterYMin=new Us(.9),this.cropRegionFilterXMin=new Us(.9),this.cropRegionFilterYMax=new Us(.9),this.cropRegionFilterXMax=new Us(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===jo.Keypoint?this.tracker=new gB(t.trackerConfig):t.trackerType===jo.BoundingBox&&(this.tracker=new mB(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return _t(this,void 0,void 0,function(){var t,i,r,s,o;return bt(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Td()==="webgpu"?[3,1]:(i=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:i=a.sent(),a.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},s=0,o=0;o<17;++o)r.keypoints[o]={y:i[3*o],x:i[3*o+1],score:i[3*o+2]},r.keypoints[o].score>.2&&(++s,r.score+=r.keypoints[o].score);return s>0&&(r.score/=s),[2,r]}})})},n.prototype.runMultiPersonPoseModel=function(e){return _t(this,void 0,void 0,function(){var t,i,r,s,o,a,l,c;return bt(this,function(u){switch(u.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Td()==="webgpu"?[3,1]:(i=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:i=u.sent(),u.label=3;case 3:for(t.dispose(),r=[],s=i.length/56,o=0;o<s;++o)for(r[o]={keypoints:[]},a=56*o+51,r[o].box={yMin:i[a],xMin:i[a+1],yMax:i[a+2],xMax:i[a+3],width:i[a+3]-i[a+1],height:i[a+2]-i[a]},l=56*o+55,r[o].score=i[l],r[o].keypoints=[],c=0;c<17;++c)r[o].keypoints[c]={y:i[56*o+3*c],x:i[56*o+3*c+1],score:i[56*o+3*c+2]};return[2,r]}})})},n.prototype.estimatePoses=function(e,t,i){return t===void 0&&(t=Z0),_t(this,void 0,void 0,function(){var r,s,o,a,l,c;return bt(this,function(u){switch(u.label){case 0:return t=function(h){return h==null?Z0:Ot({},h)}(t),e==null?(this.reset(),[2,[]]):(i==null?iC(e)&&(i=1e6*e.currentTime):i*=1e3,r=By(e),s=Wc(r),o=Vi(r,0),e instanceof dn||r.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,s,i)]);case 1:return a=u.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,s,i)];case 3:a=u.sent(),u.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Vr[c],a[l].keypoints[c].y*=s.height,a[l].keypoints[c].x*=s.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,i){return _t(this,void 0,void 0,function(){var r,s,o,a,l=this;return bt(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=gg(this.cropRegion==null,t)),r=nt(function(){var u=wr([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=no([1],"int32"),d=[l.modelInputResolution.height,l.modelInputResolution.width];return Ft(di.cropAndResize(e,u,h,d,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(s=c.sent(),r.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<s.keypoints.length;++o)s.keypoints[o].y=this.cropRegion.yMin+s.keypoints[o].y*this.cropRegion.height,s.keypoints[o].x=this.cropRegion.xMin+s.keypoints[o].x*this.cropRegion.width;return i!=null&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,i,1)),a=yB(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[s]]}})})},n.prototype.estimateMultiplePoses=function(e,t,i){return _t(this,void 0,void 0,function(){var r,s,o,a,l,c,u,h,d,f,p,m=this;return bt(this,function(y){switch(y.label){case 0:return t.width>t.height?(s=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=di.resizeBilinear(e,[o,s]),l=s,c=32*Math.ceil(o/32),a=Md(r,[[0,0],[0,c-o],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,r=di.resizeBilinear(e,[o,s]),l=32*Math.ceil(s/32),c=o,a=Md(r,[[0,0],[0,0],[0,l-s],[0,0]])),r.dispose(),e.dispose(),u=Ft(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(u)];case 1:for(h=y.sent(),u.dispose(),h=h.filter(function(g){return g.score>=m.minPoseScore}),f=0;f<h.length;++f)for(d=0;d<h[f].keypoints.length;++d)h[f].keypoints[d].y*=c/o,h[f].keypoints[d].x*=l/s;if(this.enableTracking&&(this.tracker.apply(h,i),this.enableSmoothing)){for(f=0;f<h.length;++f)this.keypointFilterMap.has(h[f].id)||this.keypointFilterMap.set(h[f].id,new mg(J0)),h[f].keypoints=this.keypointFilterMap.get(h[f].id).apply(h[f].keypoints,i,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(g,v){p.has(v)||m.keypointFilterMap.delete(v)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),i=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:i,yMax:r,xMax:s,height:r-t,width:s-i}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function _B(n){return n===void 0&&(n=aC),_t(this,void 0,void 0,function(){var e,t,i,r;return bt(this,function(s){switch(s.label){case 0:return e=vB(n),i=!0,e.modelUrl?(i=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,xl(e.modelUrl,{fromTFHub:i})]):[3,2];case 1:return t=s.sent(),[3,4];case 2:return r=void 0,e.modelType==="SinglePose.Lightning"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,xl(r,{fromTFHub:i})];case 3:t=s.sent(),s.label=4;case 4:return Td()==="webgl"&&ne().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new xB(t,e)]}})})}var tx={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},nx=["MobileNetV1","ResNet50"],ix={MobileNetV1:[8,16],ResNet50:[16]},bB=[8,16,32],rx={MobileNetV1:[.5,.75,1],ResNet50:[1]},sx=[1,2,4],wB={maxPoses:1,flipHorizontal:!1},SB={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},TB=[-123.15,-115.9,-103.06];function xp(n){return Math.floor(n/2)}var EB=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(xp(e),e);)this.exchange(e,xp(e)),e=xp(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var i=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=i},n}();function CB(n,e,t,i,r,s){for(var o=s.shape,a=o[0],l=o[1],c=!0,u=Math.max(t-r,0),h=Math.min(t+r+1,a),d=u;d<h;++d){for(var f=Math.max(i-r,0),p=Math.min(i+r+1,l),m=f;m<p;++m)if(s.get(d,m,n)>e){c=!1;break}if(!c)break}return c}function MB(n){return _t(this,void 0,void 0,function(){return bt(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function lC(n,e,t,i){return{y:i.get(n,e,t),x:i.get(n,e,t+17)}}function cC(n,e,t){var i=lC(n.heatmapY,n.heatmapX,n.id,t),r=i.y,s=i.x;return{x:n.heatmapX*e+s,y:n.heatmapY*e+r}}function uC(n,e,t,i){var r=t.x,s=t.y;return n.some(function(o){var a,l,c,u,h,d,f=o.keypoints;return a=s,l=r,c=f[i].y,u=f[i].x,(h=c-a)*h+(d=u-l)*d<=e})}var ox=Vr.reduce(function(n,e,t){return n[e]=t,n},{}),hC=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[ox[e],ox[t]]}),_p=hC.map(function(n){return n[1]}),ax=hC.map(function(n){return n[0]});function lx(n,e,t){return n<e?e:n>t?t:n}function bp(n,e,t,i){return{y:lx(Math.round(n.y/e),0,t-1),x:lx(Math.round(n.x/e),0,i-1)}}function cx(n,e){return{x:n.x+e.x,y:n.y+e.y}}function ux(n,e,t,i,r,s,o,a){a===void 0&&(a=2);for(var l=i.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},d=cx(h,function(v,_,b){var S=b.shape[2]/2;return{y:b.get(_.y,_.x,v),x:b.get(_.y,_.x,S+v)}}(n,bp(h,s,c,u),o)),f=0;f<a;f++){var p=bp(d,s,c,u),m=lC(p.y,p.x,t,r);d=cx({x:p.x*s,y:p.y*s},{x:m.x,y:m.y})}var y=bp(d,s,c,u),g=i.get(y.y,y.x,t);return{y:d.y,x:d.x,name:Vr[t],score:g}}function AB(n,e,t,i,r,s){var o=e.shape[2],a=_p.length,l=new Array(o),c=n.part,u=n.score,h=cC(c,i,t);l[c.id]={score:u,name:Vr[c.id],y:h.y,x:h.x};for(var d=a-1;d>=0;--d){var f=_p[d],p=ax[d];l[f]&&!l[p]&&(l[p]=ux(d,l[f],p,e,t,i,s))}for(d=0;d<a;++d)f=ax[d],p=_p[d],l[f]&&!l[p]&&(l[p]=ux(d,l[f],p,e,t,i,r));return l}function RB(n,e,t){return t.reduce(function(i,r,s){var o=r.y,a=r.x,l=r.score;return uC(n,e,{y:o,x:a},s)||(i+=l),i},0)/t.length}function IB(n,e,t,i,r,s,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),_t(this,void 0,void 0,function(){var l,c,u,h,d,f,p,m,y,g,v,_;return bt(this,function(b){switch(b.label){case 0:return[4,MB([n,e,t,i])];case 1:for(l=b.sent(),c=l[0],u=l[1],h=l[2],d=l[3],f=[],p=function(S,w,T){for(var R=T.shape,M=R[0],P=R[1],L=R[2],$=new EB(M*P*L,function(X){return X.score}),O=0;O<M;++O)for(var I=0;I<P;++I)for(var N=0;N<L;++N){var V=T.get(O,I,N);V<S||CB(N,V,O,I,w,T)&&$.enqueue({score:V,part:{heatmapY:O,heatmapX:I,id:N}})}return $}(o,1,c),m=a*a;f.length<s&&!p.empty();)y=p.dequeue(),g=cC(y.part,r,u),uC(f,m,g,y.part.id)||(v=AB(y,c,u,r,h,d),_=RB(f,m,v),f.push({keypoints:v,score:_}));return[2,f]}})})}function PB(n){var e=n.shape,t=e[0],i=e[1],r=e[2];return nt(function(){var s,o,a=he(n,[t*i,r]),l=ET(a,0),c=Vi(Lt(l,pt(i,"int32")),1),u=Vi((s=l,o=i,nt(function(){var h=Lt(s,pt(o,"int32"));return mt(s,Ge(h,pt(o,"int32")))})),1);return fi([c,u],1)})}function NB(n,e,t){return nt(function(){var i=function(r,s){for(var o=[],a=0;a<Vr.length;a++){var l=r.get(a,0).valueOf(),c=r.get(a,1).valueOf(),u=LB(l,c,a,s),h=u.x,d=u.y;o.push(d),o.push(h)}return wr(o,[Vr.length,2])}(n,t);return Dt(Ft(Ge(n.toTensor(),pt(e,"int32")),"float32"),i)})}function LB(n,e,t,i){return{y:i.get(n,e,t),x:i.get(n,e,t+Vr.length)}}function DB(n,e,t){return _t(this,void 0,void 0,function(){var i,r,s,o,a,l,c,u,h,d;return bt(this,function(f){switch(f.label){case 0:return i=0,r=PB(n),[4,Promise.all([n.buffer(),e.buffer(),r.buffer()])];case 1:return s=f.sent(),o=s[0],a=s[1],l=s[2],[4,(c=NB(l,t,a)).buffer()];case 2:return u=f.sent(),h=Array.from(function(p,m){for(var y=m.shape[0],g=new Float32Array(y),v=0;v<y;v++){var _=m.get(v,0),b=m.get(v,1);g[v]=p.get(_,b,v)}return g}(o,l)),d=h.map(function(p,m){return i+=p,{y:u.get(m,0),x:u.get(m,1),score:p,name:Vr[m]}}),r.dispose(),c.dispose(),[2,{keypoints:d,score:i/d.length}]}})})}function hx(n,e){return(n-1)%e==0}var dx="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",fx="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function px(n,e){return function(t,i){return(t-1)%i==0}(n,e)?n:Math.floor(n/e)*e+1}var mx=function(){function n(e,t){this.posenetModel=e;var i=this.posenetModel.inputs[0].shape;G(i[1]===-1&&i[2]===-1,function(){return"Input shape ["+i[1]+", "+i[2]+"] must both be equal to or -1"});var r,s,o=(r=t.inputResolution,s=t.outputStride,{height:px(r.height,s),width:px(r.width,s)});(function(a){G(bB.indexOf(a)>=0,function(){return"outputStride of "+a+" is invalid. It must be either 8 or 16."})})(t.outputStride),function(a,l){G(hx(a.height,l),function(){return"height of "+a.height+" is invalid for output stride "+l+"."}),G(hx(a.width,l),function(){return"width of "+a.width+" is invalid for output stride "+l+"."})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=wB),_t(this,void 0,void 0,function(){var i,r,s,o,a,l,c,u,h,d,f,p,m,y,g;return bt(this,function(v){switch(v.label){case 0:return i=function(_){var b=_;if(b.maxPoses==null&&(b.maxPoses=1),b.maxPoses<=0)throw new Error("Invalid maxPoses "+b.maxPoses+". Should be > 0.");if(b.maxPoses>1){if((b=Ot(Ot({},SB),b)).scoreThreshold<0||b.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+b.scoreThreshold+". Should be in range [0.0, 1.0]");if(b.nmsRadius<=0)throw new Error("Invalid nmsRadius "+b.nmsRadius+".")}return b}(t),e==null?[2,[]]:(this.maxPoses=i.maxPoses,r=pg(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),s=r.imageTensor,o=r.padding,a=this.architecture==="ResNet50"?Dt(s,TB):nC(s,[-1,1]),l=this.posenetModel.predict(a),this.architecture==="ResNet50"?(c=Rt(l[2],[0]),u=Rt(l[3],[0]),h=Rt(l[0],[0]),d=Rt(l[1],[0])):(c=Rt(l[0],[0]),u=Rt(l[1],[0]),h=Rt(l[2],[0]),d=Rt(l[3],[0])),f=Pu(u),this.maxPoses!==1?[3,2]:[4,DB(f,c,this.outputStride)]);case 1:return m=v.sent(),p=[m],[3,4];case 2:return[4,IB(f,c,h,d,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 3:p=v.sent(),v.label=4;case 4:return y=Wc(e),g=function(_,b,S,w){var T=b.height,R=b.width,M=T/(S.height*(1-w.top-w.bottom)),P=R/(S.width*(1-w.left-w.right)),L=-w.top*S.height,$=-w.left*S.width;if(P===1&&M===1&&L===0&&$===0)return _;for(var O=0,I=_;O<I.length;O++)for(var N=0,V=I[O].keypoints;N<V.length;N++){var X=V[N];X.x=(X.x+$)*P,X.y=(X.y+L)*M}return _}(p,y,this.inputResolution,o),i.flipHorizontal&&(g=function(_,b){for(var S=0,w=_;S<w.length;S++)for(var T=0,R=w[S].keypoints;T<R.length;T++){var M=R[T];M.x=b.width-1-M.x}return _}(g,y)),s.dispose(),a.dispose(),Gn(l),c.dispose(),u.dispose(),h.dispose(),d.dispose(),f.dispose(),[2,g]}})})},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function kB(n){return n===void 0&&(n=tx),_t(this,void 0,void 0,function(){var e,t,i,r,s;return bt(this,function(o){switch(o.label){case 0:return(e=function(u){var h=u||tx;if(h.architecture==null&&(h.architecture="MobileNetV1"),nx.indexOf(h.architecture)<0)throw new Error("Invalid architecture "+h.architecture+". Should be one of "+nx);if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),ix[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride "+h.outputStride+". Should be one of "+ix[h.architecture]+" for architecture "+h.architecture+".");if(h.multiplier==null&&(h.multiplier=1),rx[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier "+h.multiplier+". Should be one of "+rx[h.architecture]+" for architecture "+h.architecture+".");if(h.quantBytes==null&&(h.quantBytes=4),sx.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes "+h.quantBytes+". Should be one of "+sx+" for architecture "+h.architecture+".");if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride"+a+".json",t=l===4?fx+"float/"+c:fx+"quant"+l+"/"+c,[4,xl(e.modelUrl||t)]);case 1:return i=o.sent(),[2,new mx(i,e)];case 2:return r=function(u,h,d){var f={1:"100",.75:"075",.5:"050"},p="model-stride"+u+".json";return d===4?dx+"float/"+f[h]+"/"+p:dx+"quant"+d+"/"+f[h]+"/"+p}(e.outputStride,e.multiplier,e.quantBytes),[4,xl(e.modelUrl||r)];case 3:return s=o.sent(),[2,new mx(s,e)]}var a,l,c})})}function wp(n,e){return _t(this,void 0,void 0,function(){var t,i;return bt(this,function(r){switch(n){case rn.PoseNet:return[2,kB(e)];case rn.BlazePose:if(i=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,pB(e)];if(t.runtime==="mediapipe")return[2,z$(e)];i=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+i);case rn.MoveNet:return[2,_B(e)];default:throw new Error(n+" is not a supported model name.")}})})}var OB={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No={},Sp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function FB(n,e){No[n]=e}function Sr(n,e){if(!(n in No)||e!=null){const i=BB(n,e);if(i!==null)No[n]=i;else return console.log("Could not get context for WebGL version",n),null}const t=No[n];return t==null||t.isContextLost()?(delete No[n],Sr(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),No[n])}function $B(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function BB(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?$B(n):e;return t.addEventListener("webglcontextlost",i=>{i.preventDefault(),delete No[n]},!1),n===1?t.getContext("webgl",Sp)||t.getContext("experimental-webgl",Sp):t.getContext("webgl2",Sp)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jc;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(jc||(jc={}));var Ti;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Ti||(Ti={}));var En;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(En||(En={}));function Nu(n,e){return[e,n]}function zB(n,e){return n*e}function sh(n){const e=we(n),t=Math.ceil(e/4);return Mm(t)}function zl(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function UB(n,e){const[t,i]=zl(n,e);return t*i*4}function zy(n,e){const t=n;let i,r,s,o,a,l,c,u,h,d;return ne().getNumber("WEBGL_VERSION")===2?(i=t.R32F,r=t.R16F,s=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(i=n.RGBA,r=n.RGBA,s=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:i,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ke(n,e){const t=e();return ne().getBool("DEBUG")&&VB(n),t}function VB(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+jB(n,e))}const GB=596e-10,HB=65504;function WB(n){return!!(ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||GB<Math.abs(n)&&Math.abs(n)<HB)}function jB(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function oh(n,e){return xs(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function qB(n,e){const t=xs(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ke(n,()=>n.shaderSource(t,e)),ke(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function XB(n,e){const t=xs(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ke(n,()=>n.shaderSource(t,e)),ke(n,()=>n.compileShader(t)),ne().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw dC(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const YB=/ERROR: [0-9]+:([0-9]+):/g;function dC(n,e){const t=YB.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const i=+t[1],r=n.split(`
`),s=r.length.toString().length+2,o=r.map((h,d)=>al((d+1).toString(),s)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,i-1),c=o.slice(i-1,i),u=o.slice(i);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${al(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function KB(n){return xs(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function ZB(n,e){if(ke(n,()=>n.linkProgram(e)),!ne().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Tp(n,e){if(ke(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function JB(n,e){const t=xs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ke(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ke(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function QB(n,e){const t=xs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ke(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ke(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function ez(n){return xs(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function tz(n,e){const t=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const i=`[${n}x${e}]`;throw new Error("Requested texture size "+i+" is invalid.")}if(n>t||e>t){const i=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+i+" greater than WebGL maximum on this browser / GPU "+r+".")}}function nz(n){return xs(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function gx(n,e,t,i,r,s,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(ke(n,()=>n.bindBuffer(n.ARRAY_BUFFER,i)),ke(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,s,o)),ke(n,()=>n.enableVertexAttribArray(a)),!0)}function iz(n,e,t){lz(n,t),ke(n,()=>n.activeTexture(n.TEXTURE0+t)),ke(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function rz(n,e,t){return xs(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function sz(n,e,t){return n.getUniformLocation(e,t)}function oz(n,e,t,i){ke(n,()=>iz(n,e,i)),ke(n,()=>n.uniform1i(t,i))}function Ep(n,e,t){ke(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ke(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function yx(n,e){ke(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ke(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function ah(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+az(n,e))}function az(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function xs(n,e,t){const i=ke(n,()=>e());if(i==null)throw new Error(t);return i}function lz(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,i=e+n.TEXTURE0;if(i<n.TEXTURE0||i>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function _l(n,e=2){return we(n.slice(0,n.length-e))}function bl(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Cp(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[_l(n),...bl(n)]),e}function cz(n,e=!1){let t=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,n=n.map((r,s)=>s>=n.length-2?Zb(n[s]):n[s]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=ho(n).newShape);let i=we(n);if(n.length<=1&&i<=t)return[1,i];if(n.length===2&&n[0]<=t&&n[1]<=t)return n;if(n.length===3&&n[0]*n[1]<=t&&n[2]<=t)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=t&&n[1]*n[2]<=t)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t)return[n[0],n[1]*n[2]*n[3]];if(e){const r=_l(n);let s=2,o=2;return n.length&&([s,o]=bl(n)),i=r*(s/2)*(o/2),Mm(i).map(a=>a*2)}return Mm(i)}function lh(n){return n%2===0}function Nd(n,e){if(n=n.slice(-2),e=e.slice(-2),ln(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],i=e.slice(-1)[0];if(t===i||lh(t)&&lh(i)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&lh(n[0])&&lh(e[0])}let Mp,Ap;function uz(n){if(Mp==null){const e=Sr(n);Mp=e.getParameter(e.MAX_TEXTURE_SIZE)}return Mp}function hz(n){if(Ap==null){const e=Sr(n);Ap=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ap)}function dz(n){if(n===0)return 0;let e;const t=Sr(n);return qi(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:qi(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function qi(n,e){return n.getExtension(e)!=null}function vx(n){try{if(Sr(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function fz(n){if(n===0)return!1;const e=Sr(n);if(n===1){if(!qi(e,"OES_texture_float"))return!1}else if(!qi(e,"EXT_color_buffer_float"))return!1;return yg(e)}function pz(n){if(n===0)return!1;const e=Sr(n);if(n===1){if(!qi(e,"OES_texture_float")||!qi(e,"WEBGL_color_buffer_float"))return!1}else{if(qi(e,"EXT_color_buffer_float"))return yg(e);const i="EXT_color_buffer_half_float";if(qi(e,i)){const r=e.getExtension(i);return mz(e,r)}return!1}return yg(e)}function yg(n){const e=zy(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const i=1,r=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,i,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(s),o}function mz(n,e){const t=zy(n,e),i=n.createTexture();n.bindTexture(n.TEXTURE_2D,i);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,r,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(i),n.deleteFramebuffer(o),a}function gz(n){return n!==2?!1:Sr(n).fenceSync!=null}function Lu(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&G(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve=ne();Ve.registerFlag("HAS_WEBGL",()=>Ve.getNumber("WEBGL_VERSION")>0);Ve.registerFlag("WEBGL_VERSION",()=>vx(2)?2:vx(1)?1:0);Ve.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ve.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ve.get("WEBGL_VERSION")===2);Ve.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ve.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ve.registerFlag("WEBGL_PACK",()=>Ve.getBool("HAS_WEBGL"));Ve.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CLIP",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_REDUCE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_CONV_IM2COL",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>uz(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>hz(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Ve.getNumber("WEBGL_VERSION");return n===0?0:dz(n)});Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ve.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!qS());Ve.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>fz(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ve.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ve.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ve.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>pz(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_FENCE_API_ENABLED",()=>gz(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ve.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ve.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Ve.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>qS()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Ve.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ve.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ve.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zn(){let n,e,t,i,r,s,o,a,l,c;return ne().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",i="in",r="texture",s="outputColor",o="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",i="varying",r="texture2D",s="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:i,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(n,e,t="index"){const i=kn(e);return i.map((r,s)=>{const o=`int ${n[s]} = ${t} / ${r}`,a=s===i.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${r}`:`index -= ${n[s]} * ${r}`;return`${o}; ${a};`}).join("")}function Of(n,e,t="index"){const i=kn(e);return i.map((r,s)=>{const o=`int ${n[s]} = ${t} / outShapeStrides[${s}]`,a=s===i.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${o}; ${a};`}).join("")}function yz(n,e){const t=n.length,i=n.map(s=>`${e}[${s}]`),r=new Array(t-1);r[t-2]=i[t-1];for(let s=t-3;s>=0;--s)r[s]=`(${r[s+1]} * ${i[s+1]})`;return r}function vz(n,e,t="index"){const i=n.map((s,o)=>o),r=yz(i,e);return r.map((s,o)=>{const a=`int ${n[o]} = ${t} / ${r[o]}`,l=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function Uy(n){const e=kn(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Vy(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const fC=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:pC}=oF;function xz(n,e,t){const i=[];if(n.forEach(f=>{const p=we(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?i.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(i.push(`uniform sampler2D ${f.name};`),i.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){const{uniformShape:m}=Gy(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:i.push(`uniform int ${f.name}Shape;`);break;case 2:i.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:i.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:i.push(`uniform ivec4 ${f.name}Shape;`);break}i.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:i.push("uniform int outShape;");break;case 2:i.push("uniform ivec2 outShape;"),i.push("uniform int outShapeStrides;");break;case 3:i.push("uniform ivec3 outShape;"),i.push("uniform ivec2 outShapeStrides;");break;case 4:i.push("uniform ivec4 outShape;"),i.push("uniform ivec3 outShapeStrides;");break}i.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{i.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const r=i.join(`
`),s=n.map(f=>_z(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Zn(),l=Sz(a);let c,u,h=Cz(a);return e.isPacked?(c=bz(e.logicalShape,o,t.enableShapeUniforms),u=Ez(a)):(c=wz(e.logicalShape,o,t.enableShapeUniforms),u=Tz(a)),t.packedInputs&&(h+=Iz),[h,l,u,r,c,s,t.userCode].join(`
`)}function Ul(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Vz(n,e);case 1:return Hz(n,e);case 2:return jz(n,e);case 3:return Xz(n,e);case 4:return Kz(n,e);case 5:return Zz(n);case 6:return Jz(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function mC(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Uz(n);case 1:return Gz(n,e);case 2:return Wz(n,e);case 3:return qz(n,e);default:return Yz(n,e)}}function _z(n,e,t=!1,i){let r="";t?r+=mC(n,i):r+=Ul(n,i);const s=n.shapeInfo.logicalShape,o=e.logicalShape;return s.length<=o.length&&(t?r+=Qz(n,e):r+=eU(n,e)),r}function bz(n,e,t){switch(n.length){case 0:return gC();case 1:return Pz(n,e,t);case 2:return Bz(n,e,t);case 3:return Lz(n,e,t);default:return kz(n,e,t)}}function wz(n,e,t){switch(n.length){case 0:return gC();case 1:return Nz(n,e,t);case 2:return zz(n,e,t);case 3:return Dz(n,e,t);case 4:return Oz(n,e,t);case 5:return Fz(n,e);case 6:return $z(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Sz(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Tz(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Ez(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Cz(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Mz}
    ${Az}
    ${Rz}
  `}const Mz=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Az=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Rz=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Iz=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function gC(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Pz(n,e,t){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return i[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${i[1]}.0);
      }
    `:i[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${i[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);
    }
  `}function Nz(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Lz(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),s=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Dz(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Of(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const i=xa(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${i}
      return ivec3(r, c, d);
    }
  `}function kz(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),s=r*Math.ceil(n[n.length-2]/2);let o=s,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function Oz(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Of(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const i=xa(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${i}
      return ivec4(r, c, d, d2);
    }
  `}function Fz(n,e){const t=xa(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function $z(n,e){const t=xa(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Bz(n,e,t){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(ln(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));

      int index = resTexRC.x * ${i[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function zz(n,e,t){return ln(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function _a(n){return`offset${n}`}function Uz(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),i=Zn();return`
    vec4 ${t}() {
      return ${i.texture2D}(${e}, halfCR);
    }
  `}function Vz(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${i}() {return ${t};}`;const[r,s]=n.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${i}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=_a(t);if(e)return`
    float ${i}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${i}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function Gz(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,s=Zn();if(e)return`
    vec4 ${i}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${i}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Hz(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${i}(int index) {
        ${Vl(n)}
      }
    `;const r=n.shapeInfo.texShape,s=r[0],o=r[1];if(o===1&&s===1)return`
      float ${i}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=_a(t);return o===1?e?`
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Wz(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape,o=s[0],a=s[1],l=Zn();if(s!=null&&ln(t,s))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);

        return ${l.texture2D}(${i}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${i}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${i}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${i}, uv);
    }
  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${i}, uv);
    }
  `}function jz(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape;if(s!=null&&ln(t,s)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `;const d=s[0],f=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${i}, uv);
    }
  `}const{newShape:o,keptDims:a}=ho(t),l=o;if(l.length<t.length){const d=Gl(n,l),f=["row","col"];return`
      ${Ul(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${Hl(f,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Vl(n)}
      }
    `;const c=s[0],u=s[1],h=_a(i);return u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));
        return sampleTexture(${i}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${i}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);
        return sampleTexture(${i}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${i}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);
        return sampleTexture(${i}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${i}, uv);
  }
`}function qz(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){const d=t.slice(1),f=[1,2],p=Gl(n,d),m=["b","row","col"];return`
        ${mC(p,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Hl(m,f)});
        }
      `}const a=Zn();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${i}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${i}, uv);
    }
  `}function Xz(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=ho(t),c=a;if(c.length<t.length){const m=Gl(n,c),y=["row","col","depth"];return`
        ${Ul(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Hl(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${o}, 1)));
        ${Vl(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],d=u[1],f=n.shapeInfo.flatOffset;if(d===s&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${i}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${i}, uv);
        }
      `;if(d===o&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${i}, uv);
    }
  `;const p=_a(i);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${i}Shape[1] * ${i}Shape[2];
      int stride1 = ${i}Shape[2];
      int index = row * ${s} + col * ${o} + depth + ${p};
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);
      return sampleTexture(${i}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${i}, uv);
      }
  `}function Yz(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Zn();if(e)return`
    vec4 ${i}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const s=n.shapeInfo.logicalShape,o=s.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),f="int b, int row, int col",p=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)f=`int b${m}, `+f,d*=s[o-m-1],p=`b${m} * ${d} + `+p;return`
    vec4 ${i}(${f}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Kz(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t[3],o=t[2]*s,a=t[1]*o,{newShape:l,keptDims:c}=ho(t);if(l.length<t.length){const v=Gl(n,l),_=["row","col","depth","depth2"];return`
      ${Ul(v,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Hl(_,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${s}, 1)));
        ${Vl(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],f=h[1],p=`int stride2 = ${i}Shape[3];`,m=`int stride1 = ${i}Shape[2] * stride2;`,y=`int stride0 = ${i}Shape[1] * stride1;`;if(f===a&&u==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${p}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(f===s&&u==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${i}, uv);
      }
    `;const g=_a(i);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${m}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${g});
      return sampleTexture(${i}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${g});
      return sampleTexture(${i}, uv);
    }
  `}function Zz(n){const e=n.shapeInfo.logicalShape,t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],s=e[3]*r,o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:c}=ho(e);if(l.length<e.length){const m=Gl(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${Ul(m)}
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        return ${i}(${Hl(y,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${s}, ${r})) +
          depth3;
        ${Vl(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],f=h[1];if(f===a&&u==null)return`
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===r&&u==null)return`
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const p=_a(t);return`
    float ${i}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${s} +
          depth2 * ${r} + depth3 + ${p};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Jz(n){const e=n.shapeInfo.logicalShape,t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:s}=ho(e);if(r.length<e.length){const y=Gl(n,r),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ul(y)}
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${i}(${Hl(g,s)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Vl(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,f=d[0],p=d[1];if(p===u&&h==null)return`
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===o&&h==null)return`
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=_a(t);return`
    float ${i}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Vl(n){const e=n.name,t=we(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Qz(n,e){const t=n.name,i=t.charAt(0).toUpperCase()+t.slice(1),r="get"+i+"AtOutCoords",s=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=pC(n.shapeInfo.logicalShape,e.logicalShape),l=$t(o),c=o-s;let u;const h=["x","y","z","w","u","v"];s===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(v=>`coords.${h[v+c]} = 0;`).join(`
`);let d="";o<2&&s>0?d="coords":d=n.shapeInfo.logicalShape.map((v,_)=>`coords.${h[_+c]}`).join(", ");let f="return outputValue;";const m=we(n.shapeInfo.logicalShape)===1,g=we(e.logicalShape)===1;if(s===1&&!m&&!g)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!g)o===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){const v=s-2,_=s-1;a.indexOf(v)>-1&&a.indexOf(_)>-1?f="return vec4(outputValue.x);":a.indexOf(v)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${i}(${d});
      ${f}
    }
  `}function eU(n,e){const t=n.name,i=t.charAt(0).toUpperCase()+t.slice(1),r="get"+i+"AtOutCoords",s=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&ln(o,s))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=$t(l),u=pC(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const f=["x","y","z","w","u","v"];a===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${f[m+h]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((m,y)=>`coords.${f[y+h]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${i}(${p});
    }
  `}function $t(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Gy(n,e,t){const{newShape:i,keptDims:r}=ho(e),s=e.length,o=n&&s===3&&e[0]===1,a=o?e.slice(1):i,l=!n&&s>1&&!ln(e,t)&&i.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function Gl(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Hl(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n,e,t,i){const r=t.map((u,h)=>{const d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),s=r.map(u=>u.shapeInfo),o={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},a=xz(r,o,e),l=XB(n.gl,a),c=n.createProgram(l);return ne().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},yC(n,e,c))}function yC(n,e,t){const i={},r={},s={},o=[];let a,l,c,u=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ne().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(let f=0;f<e.variableNames.length;f++){const p=e.variableNames[f];i[p]=n.getUniformLocation(t,p,d),i[`offset${p}`]=n.getUniformLocation(t,`offset${p}`,d),e.enableShapeUniforms&&(r[`${p}Shape`]=n.getUniformLocation(t,`${p}Shape`,d),s[`${p}TexShape`]=n.getUniformLocation(t,`${p}TexShape`,d))}return e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",d),c=n.getUniformLocation(t,"outShapeStrides",d),l=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach((f,p)=>{o[p]=n.getUniformLocation(t,f.name,d)}),{uniformLocations:i,customUniformLocations:o,infLoc:u,nanLoc:h,inShapesLocations:r,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function xx(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,i)=>{const r=t.logicalShape,s=e[i],o=s.shape;if(!ln(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&s.isUniform)return;const a=t.texShape,l=s.isUniform?null:s.texData.texShape;if(!ln(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function nU(n,e,t,i,r){e.program.enableShapeUniforms||(xx(e.inShapeInfos,t),xx([e.outShapeInfo],[i]));const s=i.texData.texture,o=i.texData.texShape;i.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):n.setOutputMatrixTexture(s.texture,o[0],o[1]),n.setProgram(e.webGLProgram),ne().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((l,c)=>{const u=e.program.variableNames[c],h=e.uniformLocations[u],d=e.uniformLocations[`offset${u}`],f=e.inShapesLocations[`${u}Shape`],p=e.inTexShapesLocations[`${u}TexShape`];if(f){const{uniformShape:m}=Gy(e.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(f,new Int32Array(m));break;case 2:n.gl.uniform2iv(f,new Int32Array(m));break;case 3:n.gl.uniform3iv(f,new Int32Array(m));break;case 4:n.gl.uniform4iv(f,new Int32Array(m));break}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(we(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(h,m)}return}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,h,c)}});const a=e.outShapeLocation;if(a)switch(i.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(i.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(i.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(i.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(i.shape));break}if(e.outShapeStridesLocation){const l=kn(i.shape);switch(i.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,i.texData.texShape[0],i.texData.texShape[1]),e.program.customUniforms&&r&&e.program.customUniforms.forEach((l,c)=>{const u=e.customUniformLocations[c],h=r[c];if(l.type==="float")n.gl.uniform1fv(u,h);else if(l.type==="vec2")n.gl.uniform2fv(u,h);else if(l.type==="vec3")n.gl.uniform3fv(u,h);else if(l.type==="vec4")n.gl.uniform4fv(u,h);else if(l.type==="int")n.gl.uniform1iv(u,h);else if(l.type==="ivec2")n.gl.uniform2iv(u,h);else if(l.type==="ivec3")n.gl.uniform3iv(u,h);else if(l.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}),n.executeProgram()}function iU(n,e,t){let i="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=Gy(n.packedInputs,o.shape,l);let d="",f="",p="";if(u.length===1&&n.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${S[0]>1}_${S[1]>1}`}else if(u.length===2&&!n.packedInputs)f=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const S=kn(u);p=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const m=o.shape.length,y=u.length===2&&ln(o.shape,l),g=we(o.shape)===1,v=Ed(o.shape,t.shape),_=!n.packedInputs&&m===t.shape.length&&ln(l,t.texData.texShape),b=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;i+=`${m}_${_}_${c?h:""}_${u.length}_${g}_${v}_${y}_${d}_${f}_${p}_${b}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;i+=`${o.shape}_${l}_${a}`}});const r=n.userCode;let s=n.constructor.name;return s+="_"+i+"_"+r+`${ne().getNumber("WEBGL_VERSION")}`,s}function ai(n){return ne().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rU{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=jc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Zn();this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Of(["r","c","d"],e):xa(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sU{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=jc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Zn();this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Of(["r","c","d"],e):xa(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oU{constructor(e){this.variableNames=["A"],this.outTexUsage=Ti.DOWNLOAD;const t=Zn();this.outputShape=e,this.userCode=`
      ${fC}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aU{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ti.DOWNLOAD;const t=Zn();this.outputShape=e,this.userCode=`
      ${fC}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lU{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Zn();this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Vy():Uy(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${i.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cU{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Zn();this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${i.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Vy():Uy(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${i.output} = ${s};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uU(n){const e=Zn(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return qB(n,t)}function hU(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return JB(n,e)}function dU(n){const e=new Uint16Array([0,1,2,2,1,3]);return QB(n,e)}function Du(n,e,t,i,r,s){tz(e,t);const o=ez(n),a=n.TEXTURE_2D;return ke(n,()=>n.bindTexture(a,o)),ke(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ke(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ke(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ke(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ne().getNumber("WEBGL_VERSION")===1?ke(n,()=>n.texImage2D(a,0,i,e,t,0,r,s,null)):ke(n,()=>n.texStorage2D(a,1,i,e,t)),ke(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function vC(n){return n.internalFormatFloat}function fU(n,e,t,i){const[r,s]=Nu(e,t);return Du(n,r,s,vC(i),i.textureFormatFloat,n.FLOAT)}function xC(n){return n.internalFormatHalfFloat}function pU(n,e,t,i){const[r,s]=Nu(e,t);return Du(n,r,s,xC(i),i.textureFormatFloat,i.textureTypeHalfFloat)}function _C(n){return n.downloadTextureFormat}function mU(n,e,t,i){const[r,s]=Nu(e,t);return Du(n,r,s,_C(i),n.RGBA,n.UNSIGNED_BYTE)}function bC(n){return n.internalFormatPackedFloat}function gU(n,e,t,i){const[r,s]=zl(e,t);return Du(n,r,s,bC(i),n.RGBA,n.FLOAT)}function wC(n){return n.internalFormatPackedHalfFloat}function yU(n,e,t,i){const[r,s]=zl(e,t);return Du(n,r,s,wC(i),n.RGBA,i.textureTypeHalfFloat)}function vU(n,e,t){return ke(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),gx(n,e,"clipSpacePos",t,3,20,0)&&gx(n,e,"uv",t,2,20,12)}function xU(n,e,t,i,r,s){ke(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(t*i*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*i*4),a=n.FLOAT,l=s.internalFormatPackedFloat),o.set(r),ne().getNumber("WEBGL_VERSION")===2?ke(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,i,n.RGBA,a,o)):ke(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,i,0,n.RGBA,a,o)),ke(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function _U(n,e,t){ke(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ne().getNumber("WEBGL_VERSION")===2?ke(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):ke(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ne().getNumber("WEBGL_VERSION")===2?ke(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):ke(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ke(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function bU(n,e,t,i){const r=n.createBuffer();ke(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return ke(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ke(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ke(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function wU(n,e,t){const i=n,r=new Float32Array(t);return i.bindBuffer(i.PIXEL_PACK_BUFFER,e),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,r),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),r}function SU(n,e,t,i){const[r,s]=Nu(e,t),o=4,a=new Uint8Array(zB(e*t,o));return ke(n,()=>n.readPixels(0,0,r,s,i.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function TU(n,e,t,i,r,s,o,a){const l=n,c=new Float32Array(UB(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function EU(n,e,t){const i=new Float32Array(e*t*4);return ke(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,i)),i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rp{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=ne().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,FB(t,e)):this.gl=Sr(t);let i="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ne().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=oh(this.gl,s),qi(this.gl,o))this.textureHalfFloatExtension=oh(this.gl,o);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(i),qi(this.gl,r))this.colorBufferHalfFloatExtension=oh(this.gl,r);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(i="EXT_color_buffer_float",qi(this.gl,i))this.colorBufferFloatExtension=this.gl.getExtension(i);else if(qi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=hU(this.gl),this.indexBuffer=dU(this.gl),this.framebuffer=nz(this.gl),this.textureConfig=zy(this.gl,this.textureHalfFloatExtension)}get debug(){return ne().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ke(e,()=>e.finish()),ke(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ke(e,()=>e.deleteFramebuffer(this.framebuffer)),ke(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ke(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ke(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),fU(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),pU(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),mU(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),_U(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,i,r){this.throwIfDisposed(),xU(this.gl,e,t,i,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),yU(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),gU(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(yx(this.gl,this.framebuffer),this.outputTexture=null),ke(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,i){return this.downloadMatrixDriver(e,()=>SU(this.gl,t,i,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,i,r,s,o){return TU(this.gl,e,t,i,r,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return wU(this.gl,e,t)}createBufferFromTexture(e,t,i){this.bindTextureToFrameBuffer(e);const r=bU(this.gl,t,i,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,i;if(ne().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),i=()=>{const o=r.clientWaitSync(s,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=s}else ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),i=()=>this.isQueryAvailable(t,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):i=()=>!0;return{query:t,isFencePassed:i}}downloadMatrixFromPackedTexture(e,t,i){return this.downloadMatrixDriver(e,()=>EU(this.gl,t,i))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=uU(t));const i=KB(t);return ke(t,()=>t.attachShader(i,this.vertexShader)),ke(t,()=>t.attachShader(i,e)),ZB(t,i),this.debug&&Tp(t,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=vU(t,this.program,this.vertexBuffer)),i}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&ke(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Tp(this.gl,this.program),ke(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,i=!0){return this.throwIfDisposed(),i?rz(this.gl,e,t):sz(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ke(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,i){this.throwIfDisposed(),this.throwIfNoProgram(),oz(this.gl,e,t,i)}setOutputMatrixTexture(e,t,i){this.setOutputMatrixTextureDriver(e,i,t)}setOutputPackedMatrixTexture(e,t,i){this.throwIfDisposed();const[r,s]=zl(t,i);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,i,r){this.setOutputMatrixWriteRegionDriver(i,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,i,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Tp(this.gl,this.program),ah(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),ke(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ke(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=oh(this.gl,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const i=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=i.createQuery();return i.beginQuery(r.TIME_ELAPSED_EXT,s),s}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,i=this.getQueryTimerExtensionWebGL2();t.endQuery(i.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await n0(()=>this.disposed||this.isQueryAvailable(e,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const i=this.gl;return i.getQueryParameter(e,i.QUERY_RESULT)/1e6}else{const i=this.getQueryTimerExtensionWebGL1();return i.getQueryObjectEXT(e,i.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const i=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=i.getQueryParameter(e,i.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const i=this.getQueryTimerExtensionWebGL1(),r=i.getQueryObjectEXT(e,i.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=CU(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:i}=this.itemsToPoll[t];i()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&n0(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ep(this.gl,e,this.framebuffer),this.debug&&ah(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ep(this.gl,this.outputTexture,this.framebuffer),this.debug&&ah(this.gl)):yx(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const i=t();return this.unbindTextureToFrameBuffer(),i}setOutputMatrixTextureDriver(e,t,i){this.throwIfDisposed();const r=this.gl;Ep(r,e,this.framebuffer),this.debug&&ah(r),this.outputTexture=e,ke(r,()=>r.viewport(0,0,t,i)),ke(r,()=>r.scissor(0,0,t,i))}setOutputMatrixWriteRegionDriver(e,t,i,r){this.throwIfDisposed(),ke(this.gl,()=>this.gl.scissor(e,t,i,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function CU(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MU(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(n){return(e,t,i,r,s)=>{const o=Et(e,t),a=o.length,l=kn(o),c=we(o),u=Js(s,c),h=e.length,d=t.length,f=kn(e),p=kn(t),m=Ed(e,o),y=Ed(t,o);if(m.length+y.length===0)for(let g=0;g<u.length;++g)u[g]=n(i[g%i.length],r[g%r.length]);else for(let g=0;g<u.length;++g){const v=t1(g,a,l),_=v.slice(-h);m.forEach(T=>_[T]=0);const b=Pm(_,h,f),S=v.slice(-d);y.forEach(T=>S[T]=0);const w=Pm(S,d,p);u[g]=n(i[b],r[w])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AU=ir((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RU(n,e,t,i,r){const s=we(i),o=Qs(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(s>0?o[l]+=e[a]:o[l]+=1)}return o}function IU(n,e,t,i=!1){const r=n.shape[0],s=n.shape[1],o=cn([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<s;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(i?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function po(n){return(e,t,i)=>{const r=Js(t,e.length);for(let s=0;s<e.length;++s)r[s]=n(e[s],i);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PU=po(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(n,e,t,i){const r=Gi(t,we(e));if(i&&t!=="string"){let s=0;n.forEach(o=>{const a=we(o.shape);r.set(o.vals,s),s+=a})}else{let s=0;n.forEach(o=>{const a=t==="string"?Gc(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+s;for(let h=0;h<o.shape[1];++h)r[u+h]=a[l++]}s+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LU=ir((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DU=po(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU=po(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OU=po(n=>Math.floor(n));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(n,e,t,i,r,s,o,a,l){const c=cn([i,s],t);for(let u=0;u<i;u++){const h=[];let d=0;for(let f=0;f<r;f++){const p=n[u*r+f];d+=p*o[f],h.push(p)}if(d<0||d>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let f=0;f<s;f++)c.values[u*s+f]=e.get(...e.indexToLoc(d*s+f))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(n,e,t){const i=cn(t,n.dtype);for(let r=0;r<i.size;++r){const o=i.indexToLoc(r).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(i.values[r]=n.values[u])}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BU=ir((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zU=ir((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UU=ir((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VU=ir((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(n,e,t){const i=(e-n)/(t-1),r=Qs(t,"float32");r[0]=n;for(let s=1;s<r.length;s++)r[s]=r[s-1]+i;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HU=po(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(n,e,t,i){const r=Js(i,we(t));for(let s=0;s<r.length;++s){const o=s*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[s]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jU=ir((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qU=ir((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SC=ir((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XU(n,e,t){const i=kl(-1,t);return SC([],e,i,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YU=ir((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(n,e,t,i,r){const s=e.length,o=we(e),a=kn(e),l=kn(r),c=Js(t,we(r));for(let u=0;u<o;++u){const h=t1(u,s,a),d=new Array(h.length);for(let p=0;p<d.length;p++)d[p]=h[i[p]];const f=Pm(d,s,l);c[f]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n,e,t,i){const[r,s]=Xr(n,i),o=Ur(e,"int32"),a=Qs(we(r),o),l=we(s);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let d=0;d<l;++d)h*=t[u+d];a[c]=h}return{outVals:a,outShape:r,outDtype:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(n,e,t,i){const r=n===e,s=n<e&&t<0,o=e<n&&t>1;if(r||s||o)return Qs(0,i);const a=Math.abs(Math.ceil((e-n)/t)),l=Qs(a,i);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QU=po(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e4(n,e,t,i,r,s,o,a,l,c){const u=[i/r,r],h=n.values,d=e.values;if(i===0)return cn(t,e.dtype);const f=cn(u,e.dtype);typeof l=="string"||typeof l=="number"?f.values.fill(l):typeof l=="boolean"&&f.values.fill(+l);for(let p=0;p<s;p++){const m=[];let y=0;for(let g=0;g<o;g++){const v=h[p*o+g];m.push(v),y+=v*a[g]}if(y<0||y>=i/r)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let g=0;g<r;g++)c?f.values[y*r+g]+=d[p*r+g]:f.values[y*r+g]=e.rank===0?d[0]:d[p*r+g]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t4=po(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n4(n,e,t,i,r){const s=by(i,e,t),o=we(t),a=kn(i);if(s){const h=wy(e,a);return r==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=r==="string"?Gc(n):n,c=cn(i,r,l),u=cn(t,r);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),f=d.map((p,m)=>p+e[m]);u.set(c.get(...f),...d)}return r==="string"?GE(u.values):u.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4(n,e,t,i,r,s,o){const a=e[0],l=s[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(RE(a));const y=Gi(t,0),g=Gi(r,0);return[y,[0,h],g,c,u]}let d=!0,f=0;const p=new Array(l).fill(0);for(let y=0;y<a;++y){const g=n[y*h];if(g<0)throw new Error(IE(y,g));if(g>=l)throw new Error(PE(y,g,l));++p[g],d=d&&g>=f,f=g}let m=!0;for(let y=0;y<l;++y){const g=p[y]===0;c[y]=g,m=m&&!g,p[y]=Math.max(p[y],1),y>0&&(p[y]+=p[y-1])}if(m&&d){const y=n,g=i;for(let v=0;v<a;++v)u[v]=v;return[y,[a,h],g,c,u]}else{const y=p[l-1],g=Gi(t,y*h),v=Gi(r,y),_=new Array(l).fill(0);for(let b=0;b<a;++b){const S=n[b*h],w=_[S],T=(S===0?0:p[S-1])+w;_[S]++;for(let R=0;R<h;++R)g[T*h+R]=n[b*h+R];v[T]=i[b],u[b]=T}for(let b=0;b<l;++b)if(_[b]===0){const w=b===0?0:p[b-1];g[w*h+0]=b;for(let T=1;T<h;++T)g[w*h+T]=0;v[w]=o}return[g,[y,h],v,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(n,e,t,i,r){const s=we(i),o=e[0],a=r.length,l=[];let c=1,u=-1;for(let y=0;y<a;++y){const g=r[y];if(g===-1){if(u!==-1)throw new Error(NE(u,y));u=y,l.push(1)}else{if(g<0)throw new Error(LE(y,g));c*=g,l.push(g)}}if(u!==-1){if(c<=0)throw new Error(DE());const y=Math.trunc(s/c);if(c*y!==s)throw new Error(kE(i,l));l[u]=y}if(we(l)!==s)throw new Error(OE(i,l));const d=i.length,f=[];if(d>0){f[d-1]=1;for(let y=d-2;y>=0;--y)f[y]=f[y+1]*i[y+1]}const p=[];if(a>0){p[a-1]=1;for(let y=a-2;y>=0;--y)p[y]=p[y+1]*l[y+1]}const m=Gi(t,o*a);for(let y=0;y<o;++y){let g=0;for(let v=0;v<d;++v)g+=n[y*d+v]*f[v];for(let v=0;v<a;++v)m[y*a+v]=Math.trunc(g/p[v]),g%=p[v]}return[m,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(n,e,t,i,r,s=!1,o=0){const a=i.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(tg());const d=e.slice();d[0]=h;const f=d.reduce((_,b)=>_*b,1),p=Gi(t,f);if(a===0)return h>0&&p.fill(o),[p,d];if(h<=0)throw new Error(tg());let m=0,y=1,g=0,v=r[m];for(;;){let _=0;if(y<a){if(_=r[y],v===_){++y;continue}if(v>=_)throw new Error(FE())}if(v<0||v>=h)throw new Error($E(v,h));v>g&&p.fill(o,g*c,v*c);for(let b=m;b<y;++b){const S=i[b];if(S<0||S>=l[0])throw new Error(BE(b,i[b],l[0]));for(let w=0;w<c;w++)p[v*c+w]+=n[S*c+w]}if(s)for(let b=0;b<c;b++)p[v*c+b]/=y-m;if(m=y,++y,g=v+1,v=_,y>a)break}return g<h&&p.fill(o,g*c,h*c),[p,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o4=po(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a4=ir((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(n,e,t,i){const r=cn(n,e.dtype);for(let s=0;s<r.size;s++){const o=r.indexToLoc(s),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+i[l];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c4{constructor(e,t,i,r,s,o){this.separator=Go(e),this.nGramWidths=t,this.leftPad=Go(i),this.rightPad=Go(r),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const i=this.getPadWidth(t);return Math.max(0,e+2*i-t+1)}createNGrams(e,t,i,r,s,o){for(let a=0;a<s;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(s-(a+1))),h=o-(c+u),d=t+(c>0?0:a-l);let f=0;f+=c*this.leftPad.length;for(let v=0;v<h;++v)f+=e[d+v].length;f+=u*this.rightPad.length,f+=(c+u+h-1)*this.separator.length,i[r+a]=new Uint8Array(f);const m=i[r+a];let y=0;const g=v=>v.forEach(_=>m[y++]=_);for(let v=0;v<c;++v)g(this.leftPad),g(this.separator);for(let v=0;v<h-1;++v)g(e[d+v]),g(this.separator);if(h>0){g(e[d+h-1]);for(let v=0;v<u;++v)g(this.separator),g(this.rightPad)}else{for(let v=0;v<u-1;++v)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const i=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let u=t[c]>=l;if(u=u&&t[c]<=i,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${i}]`);l=t[c]}if(l!==i)throw new Error(`Last split value must be data size. Expected ${i}, got ${l}`)}const s=r-1,o=Gi("int32",r);if(i===0||r===0){const l=new Array(i);for(let c=0;c<=s;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=s;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[s]);for(let l=0;l<s;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],f=this.getNumNGrams(d,h);this.createNGrams(e,c,a,u,f,h),u+=f}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth,f=1;this.createNGrams(e,c,a,u,f,d)}}return[a,o]}}function u4(n,e,t,i,r,s,o,a){return new c4(t,i,r,s,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h4(n,e,t,i){if(!n.length)return;if(e.length===0){for(let s=0;s<n.length;++s)i.push(n.subarray(s,s+1));return}if(e.length===1){const s=e[0];let o=n.indexOf(s);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&i.push(a),n=n.subarray(o+1),o=n.indexOf(s)}(!t||n.length!==0)&&i.push(n);return}let r=0;for(let s=0;s<n.length+1;s++)if(s===n.length||e.indexOf(n[s])!==-1){const o=n.subarray(r,s);(!t||o.length!==0)&&i.push(o),r=s+1}}function d4(n,e,t){const i=n.length,r=[];let s=0,o=0;const a=new Array(i);for(let d=0;d<i;++d){const f=r.length;h4(n[d],e,t,r);const p=r.length-f;a[d]=p,s+=p,o=Math.max(o,p)}const l=Gi("int32",s*2),c=new Array(s),u=[i,o];let h=0;for(let d=0;d<i;++d)for(let f=0;f<a[d];++f)l[h*2]=d,l[h*2+1]=f,c[h]=r[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(n,e){const t=Gi("int32",n.length);for(let i=0;i<n.length;++i)t[i]=eP(n[i]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p4=ir((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const i=cn(t,n.dtype);for(let r=0;r<i.values.length;++r){const s=i.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=s[l]%n.shape[l];const a=n.locToIndex(o);i.values[r]=n.values[a]}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function TC(n,e,t=0,i=n.length-1){for(;i>t;){if(i-t>600){const a=i-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*u/a+h)),f=Math.min(i,Math.floor(e+(a-l)*u/a+h));TC(n,e,d,f)}const r=n[e];let s=t,o=i;for(sc(n,t,e),Tc(n[i],r)>0&&sc(n,t,i);s<o;){for(sc(n,s,o),s++,o--;Tc(n[s],r)<0;)s=s+1;for(;Tc(n[o],r)>0;)o=o-1}Tc(n[t],r)===0?sc(n,t,o):(o=o+1,sc(n,o,i)),o<=e&&(t=o+1),e<=o&&(i=o-1)}}function g4(n,e,t,i,r){const s=e[e.length-1],[o,a]=[n.length/s,s],l=Js(t,o*i),c=Js("int32",o*i);for(let h=0;h<o;h++){const d=h*a,f=n.subarray(d,d+a);let p=new Array(f.length);f.forEach((v,_)=>p[_]={value:v,index:_}),i<p.length&&(TC(p,i),p=p.slice(0,i)),r&&p.sort(Tc);const m=h*i,y=l.subarray(m,m+i),g=c.subarray(m,m+i);for(let v=0;v<i;v++)y[v]=p[v].value,g[v]=p[v].index}const u=e.slice();return u[u.length-1]=i,[cn(u,t,l),cn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(n,e,t,i){const r=Mn(e,t)[0],s=[1,t[0],1];for(let p=0;p<r;p++)s[0]*=t[p];s[1]=t[r];for(let p=r+1;p<t.length;p++)s[2]*=t[p];const o={},a=new Int32Array(t[r]),l=new Fc(s,i,n),c=[],u=s[0]===1&&s[2]===1;for(let p=0;p<t[r];p++){let m;if(u)m=n[p].toString();else{const y=[];for(let g=0;g<s[0];g++)for(let v=0;v<s[2];v++)y.push(l.get(g,p,v));m=y.join(",")}if(o[m]!==void 0)a[p]=o[m];else{const y=Object.keys(o).length;o[m]=y,a[p]=y,c.push(p)}}const h=s.slice();h[1]=Object.keys(o).length;const d=new Fc(h,i);c.forEach((p,m)=>{for(let y=0;y<s[0];y++)for(let g=0;g<s[2];g++)d.set(l.get(y,p,g),y,m,g)});const f=t.slice();return f[r]=h[1],{outputValues:d.values,outputShape:f,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var v4=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:MU,addImpl:AU,bincountImpl:RU,bincountReduceImpl:IU,ceilImpl:PU,concatImpl:NU,equalImpl:LU,expImpl:DU,expm1Impl:kU,floorImpl:OU,gatherNdImpl:FU,gatherV2Impl:$U,greaterImpl:BU,greaterEqualImpl:zU,lessImpl:UU,lessEqualImpl:VU,linSpaceImpl:GU,logImpl:HU,maxImpl:WU,maximumImpl:jU,minimumImpl:qU,multiplyImpl:SC,negImpl:XU,notEqualImpl:YU,prodImpl:ZU,rangeImpl:JU,rsqrtImpl:QU,scatterImpl:e4,sigmoidImpl:t4,sliceImpl:n4,sparseFillEmptyRowsImpl:i4,sparseReshapeImpl:r4,sparseSegmentReductionImpl:s4,sqrtImpl:o4,squaredDifferenceImpl:a4,stridedSliceImpl:l4,stringNGramsImpl:u4,stringSplitImpl:d4,stringToHashBucketFastImpl:f4,subImpl:p4,tileImpl:m4,topKImpl:g4,transposeImpl:KU,uniqueImpl:y4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:x4,bincountImpl:EC,bincountReduceImpl:_4,ceilImpl:b4,concatImpl:w4,equalImpl:S4,expImpl:T4,expm1Impl:E4,floorImpl:C4,gatherNdImpl:M4,gatherV2Impl:A4,greaterImpl:R4,greaterEqualImpl:I4,lessImpl:P4,lessEqualImpl:N4,linSpaceImpl:L4,logImpl:D4,maxImpl:k4,maximumImpl:O4,minimumImpl:F4,multiplyImpl:$4,negImpl:B4,notEqualImpl:z4,prodImpl:U4,rangeImpl:V4,rsqrtImpl:G4,scatterImpl:H4,sigmoidImpl:W4,simpleAbsImpl:CC,sliceImpl:j4,sparseFillEmptyRowsImpl:q4,sparseReshapeImpl:X4,sparseSegmentReductionImpl:MC,sqrtImpl:Y4,stridedSliceImpl:K4,stringNGramsImpl:Z4,stringSplitImpl:J4,stringToHashBucketFastImpl:Q4,subImpl:eV,tileImpl:tV,topKImpl:nV,transposeImpl:Hy,uniqueImpl:iV}=v4;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AC(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function jn(n,e){return e===1?[n]:AC(n,e)}function rV(n,e){if(n===1)return"rc";let t="";for(let i=0;i<n;i++)t+=e[i],i<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sV{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ai(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=jn("rc",this.rank),i=$t(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let i=0;i<=1;i++)for(let r=0;r<=1;r++){let s=`${i===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${e[e.length-1-o]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let i=this.rank-2;i<this.rank;i++)t+=`${e[i]} >= ${this.enableShapeUniforms?`outShape[${i}]`:this.outputShape[i]}`,i<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),i=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${i};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RC{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length);let i="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),i+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${oV(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Vy():Uy(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${i}

        setOutput(result);
      }
    `}}function oV(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?vz(["r","c","d"],"inputShape"):xa(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aV{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,i){const r=bx(t,i),s=wx(e,r,i);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=_x(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,i);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let a;return r===En.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===En.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===En.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===En.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===En.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,i,r){if(this.freeTextures==null)return;const s=bx(i,r),o=wx(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=_x(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ne().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function lV(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function _x(n,e,t,i,r){const s=cV(e,i);let o;if(r){const[l,c]=zl(n[0],n[1]);o=l*c}else{const[l,c]=Nu(n[0],n[1]);o=l*c}const a=lV(t,s);return o*a}function cV(n,e){switch(n){case En.PACKED_2X2_FLOAT32:return bC(e);case En.PACKED_2X2_FLOAT16:return wC(e);case En.UNPACKED_FLOAT32:return vC(e);case En.UNPACKED_FLOAT16:return xC(e);case En.PACKED_4X1_UNSIGNED_BYTE:return _C(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function uV(n){return ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?En.PACKED_2X2_FLOAT32:En.UNPACKED_FLOAT32:n?En.PACKED_2X2_FLOAT16:En.UNPACKED_FLOAT16}function bx(n,e){if(n===Ti.UPLOAD)return En.PACKED_2X2_FLOAT32;if(n===Ti.RENDER||n==null)return uV(e);if(n===Ti.DOWNLOAD||n===Ti.PIXELS)return En.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function wx(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class us{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const rr="if (isnan(x)) return x;",hV="return x;",Sx="return abs(x);",dV="return (x >= 0.0) ? x : (exp(x) - 1.0);",fV=rr+`
  return (x < 0.0) ? 0.0 : x;
`,pV=rr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ma="return x;",mV="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gV="return x;",yV=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,vV=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xV=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_V="return 1.0 / (1.0 + exp(-1.0 * x));";class $o{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length);const t=e.length,i=jn("rc",t),r=$t(t),s=rV(t,i),o=i.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wV=sE,SV=1e-7,TV=1e-4,ch={};function EV(n){return n in ch||(ch[n]={}),ch[n]}const CV=ne().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),MV=600;function AV(){return ne().global.screen==null?1024:ne().global.screen.height*ne().global.screen.width*window.devicePixelRatio*MV/1024/1024}class Ff extends Kb{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ne().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Rp)t=e;else{const i=Sr(ne().getNumber("WEBGL_VERSION"),e);t=new Rp(i)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const i=Sr(ne().getNumber("WEBGL_VERSION"));t=new Rp(i),this.binaryCache=EV(ne().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new aV(this.gpgpu),this.numMBBeforeWarning=AV(),this.texData=new mI(this,Ds())}nextDataId(){return Ff.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,i){if((ne().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ne().getBool("DEBUG"))&&this.checkNumericalProblems(e),i==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:i,values:e,usage:Ti.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,i,r,s){if(ne().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:i,dtype:r,values:t,usage:Ti.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:i,dtype:r,complexTensorInfos:s,slice:o,shape:a,isPacked:l}=t;if(o!=null){let d;l?d=new $o(a,Ma):d=new us(a,Ma);const f=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),p=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),p}if(i!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return i;const c=this.activeTimers!=null;let u;c&&(u=mr());let h;if(r==="complex64"){const d=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);h=eg(d,f)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=mr()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(m=>p.push(m))}const t=this.texData.get(e),{values:i,shape:r,slice:s,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(s!=null){let p;l?p=new $o(r,Ma):p=new us(r,Ma);const m=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:o}],o),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(i!=null)return this.convertAndCacheOnCPU(e);if(ne().getBool("DEBUG")&&!ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ne().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&ne().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(p.texture.texture,...sh(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=p[0],y=p[1];h=eg(m,y)}else if(c==null)h=this.getValuesFromTexture(e);else{const p=we(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const p=this.gpgpu.gl;ke(p,()=>p.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(e,h),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(p=>p(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ds().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const i=this.texData.get(e),{values:r,shape:s,slice:o,dtype:a,isPacked:l,texture:c}=i;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let f;l?f=new $o(s,Ma):f=new us(s,Ma);const p=this.runWebGLProgram(f,[{dataId:e,shape:s,dtype:a}],a),m=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),m}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=Ds().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const i=t.map(r=>gl(r));return cn(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return cn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const i=e[t];if(!WB(i))throw ne().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:i,isPacked:r}=this.texData.get(e),s=we(t);if(ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),f=this.texData.get(d.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...sh(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),p}const o=ne().getBool("WEBGL_PACK")&&r===!0,a=o?Cp(t):t,l=o?new aU(a):new oU(a),c=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,i=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=i,r=!0):this.activeTimers.push(i),this.activeTimers=i,e();const s=fl(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=fl(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(s);a.kernelMs=gI(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:mr(),endMs:null}}endTimer(e){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=mr(),e)}async getQueryTime(e){if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:i}=this.texData.get(e);return i!=null&&(this.disposeData(i.real.dataId,t),this.disposeData(i.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:i,texShape:r,usage:s,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,i),this.textureManager.releaseTexture(t,r,s,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=CV){return ne().getBool("WEBGL_CPU_FORWARD")&&e.every(i=>this.texData.get(i.dataId).texture==null&&we(i.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){xr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return wV(e.shape,t)}packedUnaryOp(e,t,i){const r=new $o(e.shape,t),s=this.compileAndRun(r,[e],i);return Ds().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=CC(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ne().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Sx,e.dtype);const t=new us(e.shape,Sx),i=this.compileAndRun(t,[e]);return Ds().makeTensorFromTensorInfo(i)}makeTensorInfo(e,t,i){let r;if(t==="string"&&i!=null&&i.length>0&&Sf(i[0])){const s=i.map(o=>Go(o));r=this.write(s,e,t)}else r=this.write(i,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,i){return Ds().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,i),this)}unpackTensor(e){const t=new bV(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new sV(e.shape),i=!0;return this.runWebGLProgram(t,[e],e.dtype,null,i)}packedReshape(e,t){const i=[_l(e.shape),...bl(e.shape)],r={dtype:e.dtype,shape:i,dataId:e.dataId},s=[_l(t),...bl(t)],o=new RC(s,i),a=!0,l=[i],c=this.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const i=this.texData.get(e),{isPacked:r,shape:s,dtype:o}=i;if(t!=null){const d=we(s),f=t[0]*t[1]*4;G(d<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Cp(s);let l;r?l=new sU(a):l=new rU(a);const c=!0,u=[t!=null?t:sh(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:s,dataId:h.dataId}}runWebGLProgram(e,t,i,r,s=!1,o){const a=this.makeTensorInfo(e.outputShape,i),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===jc.DENSE){const g=o!=null?o:sh(e.outputShape);l.texShape=g.map(v=>v*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),we(a.shape)===0)return l.values=Js(a.dtype,0),a;const c=[],u=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(g.dataId);if(v.texture==null){if(!e.packedInputs&&we(g.shape)<=ne().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!v.isPacked!=!!e.packedInputs)g=v.isPacked?this.unpackTensor(g):this.packTensor(g),c.push(g),v=this.texData.get(g.dataId);else if(v.isPacked&&!Nd(v.shape,g.shape)){const _=g,b=g.shape;g.shape=v.shape,g=this.packedReshape(g,b),c.push(g),v=this.texData.get(g.dataId),_.shape=b}return{shape:g.shape,texData:v,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=iU(e,u,h),f=this.getAndSaveBinary(d,()=>tU(this.gpgpu,e,u,h)),p=this.activeTimers!=null;let m;p&&(m=this.startTimer()),ne().get("ENGINE_COMPILE_ONLY")||nU(this.gpgpu,f,u,h,r),c.forEach(g=>this.disposeIntermediateTensorInfo(g)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=ne().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const g=mr();g-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!ne().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){const g=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),g}return a}compileAndRun(e,t,i,r,s=!1){return i=i||t[0].dtype,this.runWebGLProgram(e,t,i,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ne().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=nt(()=>{if(!ne().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ne().getBool("DEBUG");ne().set("DEBUG",!1);const t=this.abs(pt(1e-8)).dataSync()[0];if(ne().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?SV:TV}uploadToGPU(e){const t=this.texData.get(e),{shape:i,dtype:r,values:s,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=mr());let h=t.texShape;if(h==null&&(h=cz(i,l),t.texShape=h),s!=null){const d=Cp(i);let f,p=h[1],m=h[0];const y=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!y)&&([p,m]=zl(h[0],h[1])),l?f=new cU(d,y):f=new lU(d,y);const g=y?[m,p]:h,v=this.makeTensorInfo(g,r),_=this.texData.get(v.dataId);y?_.usage=Ti.PIXELS:_.usage=Ti.UPLOAD,_.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),p,m,s);const b=[[m,p]],S=!0,w=this.runWebGLProgram(f,[v],r,b,S),T=this.texData.get(w.dataId);t.texShape=T.texShape,t.isPacked=T.isPacked,t.usage=T.usage,ne().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(t.texture=T.texture,t.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=mr()-u)}else{const d=this.acquireTexture(h,a,r,l);t.texture=d}}convertAndCacheOnCPU(e,t){const i=this.texData.get(e),{dtype:r}=i;return this.releaseGPUData(e),t!=null&&(i.values=RV(t,r)),i.values}acquireTexture(e,t,i,r){if(this.numBytesInGPU+=this.computeBytes(e,i),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Am(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const i=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(s){throw s}});e.push(i)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await YO(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(dC(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:i,infLoc:r,nanLoc:s,inShapesLocations:o,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:c,outTexShapeLocation:u}=yC(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=i,e.infLoc=r,e.nanLoc=s,e.inShapesLocations=o,e.inTexShapesLocations=a,e.outShapeLocation=l,e.outShapeStridesLocation=c,e.outTexShapeLocation=u}}}Ff.nextDataId=0;function RV(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let i=0;i<t.length;++i)t[i]=Math.round(n[i]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */XS()&&oT("webgl",()=>new Ff,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class wl{constructor(e,t,i){this.variableNames=["A","B"],this.outputShape=Et(t,i),this.enableShapeUniforms=ai(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $f=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class ku{constructor(e,t,i,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Et(t,i);const s=this.outputShape.length;this.enableShapeUniforms=ai(s);let o="";if(r)if(s===0||we(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${$t(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=jn("coords",s);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pi(n){const{inputs:e,backend:t}=n,{x:i}=e;return t.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const IV={kernelName:dy,backendName:"webgl",kernelFunc:pi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mo(n){const{inputs:e,backend:t}=n,{real:i,imag:r}=e,s=t.makeTensorInfo(i.shape,"complex64"),o=t.texData.get(s.dataId),a=pi({inputs:{x:i},backend:t}),l=pi({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:l},s}const PV={kernelName:E1,backendName:"webgl",kernelFunc:mo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PC="return (a < 0.) ? b * a : a;",NC=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function NV(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{alpha:s}=i,o=t.makeTensorInfo([],"float32",kl(s,"float32")),a=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ku(NC,r.shape,o.shape):new wl(PC,r.shape,o.shape),l=t.runWebGLProgram(a,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const LV={kernelName:uw,backendName:"webgl",kernelFunc:NV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LC="return (a < 0.) ? b * a : a;",DC=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function DV(n){const{inputs:e,backend:t}=n,{x:i,alpha:r}=e,s=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ku(DC,i.shape,r.shape):new wl(LC,i.shape,r.shape);return t.runWebGLProgram(s,[i,r],"float32")}const kV={kernelName:Vw,backendName:"webgl",kernelFunc:DV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wl="if (isnan(x)) return x;",OV=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,FV=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function gt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:i}){return({inputs:r,backend:s})=>{const{x:o}=r,a=s,l=i||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),d=t(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const c=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new $o(o.shape,e):u=new us(o.shape,n),a.runWebGLProgram(u,[o],l)}}function An({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:i=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(i&&l.dtype==="complex64"){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[y,g]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(_=>{const[b,S]=_,w={dataId:b.dataId,dtype:b.dtype,shape:l.shape},T={dataId:S.dataId,dtype:S.dtype,shape:c.shape},R=new wl(n,l.shape,c.shape);return u.runWebGLProgram(R,[w,T],Ur(b.dtype,S.dtype))}),v=mo({inputs:{real:y,imag:g},backend:u});return u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo(g),v}const h=s||Ur(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&r!=null){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,y=l.dtype==="string"?Gc(p):p,g=l.dtype==="string"?Gc(m):m,[v,_]=r(l.shape,c.shape,y,g,h),b=u.makeTensorInfo(_,h),S=u.texData.get(b.dataId);return S.values=v,b}const d=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let f;return d?f=new ku(e,l.shape,c.shape,t):f=new wl(n,l.shape,c.shape),u.runWebGLProgram(f,[l,c],h)}}function Bf(n,e=!1){if(n==="linear")return e?gV:hV;if(n==="relu")return e?vV:fV;if(n==="elu")return e?yV:dV;if(n==="relu6")return e?xV:pV;if(n==="prelu")return e?DC:LC;if(n==="leakyrelu")return e?NC:PC;if(n==="sigmoid")return e?_V:mV;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kC{constructor(e,t,i,r=!1,s=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i,this.enableShapeUniforms=ai(this.outputShape.length);const u=r?e[1]:e[2],h=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",g="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,g="result = activation(result);");const v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let _="rc.x",b="rc.x";e[0]<t[0]?_=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(b=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${h}; i++) {
          int batchA = ${_};
          int batchB = ${b};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${g}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tx={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Ex{constructor(e,t,i){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Et(t,i),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cx="return a * b;";function Wy(n){const{inputs:e,backend:t}=n,{a:i,b:r}=e,s=Ur(i.dtype,r.dtype);if(i.dtype==="complex64"){const a=t.texData.get(i.dataId),l=t.texData.get(r.dataId),c=new Ex(Tx.REAL,i.shape,r.shape),u=new Ex(Tx.IMAG,i.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(c,h,"float32"),f=t.runWebGLProgram(u,h,"float32"),p=mo({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),p}if(t.shouldExecuteOnCPU([i,r])){const a=t.texData.get(i.dataId),l=t.texData.get(r.dataId),[c,u]=$4(i.shape,r.shape,a.values,l.values,s),h=t.makeTensorInfo(u,s),d=t.texData.get(h.dataId);return d.values=c,h}let o;return ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new ku(Cx,i.shape,r.shape):o=new wl(Cx,i.shape,r.shape),t.runWebGLProgram(o,[i,r],s)}const $V={kernelName:Pw,backendName:"webgl",kernelFunc:Wy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(n,e,t){const i=[_l(n.shape),...bl(n.shape)],r={dtype:n.dtype,shape:i,dataId:n.dataId},s=[_l(e),...bl(e)],o=new RC(s,i),a=!0,l=[i],c=t.runWebGLProgram(o,[r],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Me(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{shape:s}=i,o=t,a=we(r.shape),l=yI(s,a),c=we(l);G(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(r.dataId);return u.isPacked&&!Nd(r.shape,l)&&!(u.texture!==null&&Nd(u.shape,l))?BV(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const zV={kernelName:Xw,backendName:"webgl",kernelFunc:Me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mx{constructor(e,t){this.variableNames=["x"];const{windowSize:i,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(i/4)*4,l=i%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${Oc(h)?h.toPrecision(2):h}, ones);`}let u="";s%i>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UV{constructor(e,t){this.variableNames=["x"];const{windowSize:i,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(i/4)*4,h=i%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let p="";s%i>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],i=kf(t);e.push({inSize:t,windowSize:i,outSize:Math.ceil(t/i)})}return e}function ba(n,e,t,i){const r=VV(n.shape);let s=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let u,h;t==="mean"?u=o===0?new Mx({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new Mx({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new UV({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=s,s=i.runWebGLProgram(u,[s],e),h.dataId!==n.dataId&&i.disposeIntermediateTensorInfo(h)}return s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GV{constructor(e,t){this.variableNames=["A"];const i=new Array(e.length);for(let o=0;o<i.length;o++)i[o]=e[t[o]];this.outputShape=i,this.rank=i.length;const r=$t(this.rank),s=HV(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}}function HV(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],i=new Array(e);for(let r=0;r<n.length;r++)i[n[r]]=t[r];return i.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const i=new Array(e.length);for(let u=0;u<i.length;u++)i[u]=e[t[u]];if(this.outputShape=i,this.rank=i.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=$t(this.rank),s=AC("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=s[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${i[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${i[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zf(n,e,t){const i=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WV(n.shape,e):new GV(n.shape,e);return t.runWebGLProgram(i,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(n,e,t,i){const r=e,s=n.shape.length,o=Mn(r,n.shape);let a=o;const l=tr(a,s),c=l!=null;let u=n;c&&(u=zf(n,l,i),a=nr(a.length,s)),Pr("sum",a,s);const[h,d]=Xr(u.shape,a);let f=h;t&&(f=er(h,o));const p=we(d),y=we(n.shape)/p,g=Me({inputs:{x:u},attrs:{shape:[y,p]},backend:i}),v=gy(n.dtype),_=ba(g,v,"sum",i),b=Me({inputs:{x:_},attrs:{shape:f},backend:i});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(_),c&&i.disposeIntermediateTensorInfo(u),b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uf(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;return jV(r,s,o,t)}const qV={kernelName:dS,backendName:"webgl",kernelFunc:Uf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function an(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{perm:s}=i,o=t,a=r.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=r.shape[s[u]];let c;if(o.shouldExecuteOnCPU([r])){const h=o.texData.get(r.dataId).values,d=Hy(h,r.shape,r.dtype,s,l);c=o.makeTensorInfo(l,r.dtype);const f=o.texData.get(c.dataId);f.values=d}else c=zf(r,s,o);return c}const XV={kernelName:od,backendName:"webgl",kernelFunc:an};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OC=1e3;function Ld({a:n,b:e,transposeA:t,transposeB:i,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],d=i?e.shape[u-1]:e.shape[u-2],f=t?n.shape[c-1]:n.shape[c-2],p=i?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),y=e.shape.slice(0,-2),g=we(m),v=we(y),b=Et(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,p]);G(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${i} must match.`);const S=t?[g,h,f]:[g,f,h],w=i?[v,p,d]:[v,d,p],T=Me({inputs:{x:n},backend:r,attrs:{shape:S}}),R=Me({inputs:{x:e},backend:r,attrs:{shape:w}}),M=[T,R],P=Math.max(g,v),L=t?T.shape[1]:T.shape[2],$=s!=null,O=o!=null,I=l==="leakyrelu",N=l!=null?Bf(l,!0):null,V=$||O||I||N!=null;let X;if((f===1||p===1)&&L>OC&&V===!1){let W=T,Q=R;t&&(W=an({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),M.push(W)),i&&(Q=an({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),M.push(Q));const re=p!==1,xe=p===1;let Ae=W;re&&(Ae=Me({inputs:{x:W},backend:r,attrs:{shape:[P,L,1]}}),M.push(Ae));const $e=p===1?2:1;let se=Q;xe&&(se=Me({inputs:{x:Q},backend:r,attrs:{shape:[P,1,L]}}),M.push(se));const ht=Wy({inputs:{a:Ae,b:se},backend:r});X=Uf({inputs:{x:ht},backend:r,attrs:{axis:$e,keepDims:!0}}),M.push(ht)}else{const W=Ur(n.dtype,e.dtype),Q=new kC(S,w,[P,f,p],t,i,$,N,O,I),re=[T,R];if(s!=null&&re.push(s),O&&re.push(o),I){const xe=r.makeTensorInfo([],"float32",kl(a,"float32"));re.push(xe),M.push(xe)}X=r.runWebGLProgram(Q,re,W)}const J=Me({inputs:{x:X},backend:r,attrs:{shape:b}});M.push(X);for(const W of M)r.disposeIntermediateTensorInfo(W);return J}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(n){const{inputs:e,backend:t,attrs:i}=n,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=i;return Ld({a:r,b:s,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const KV={kernelName:Lm,backendName:"webgl",kernelFunc:YV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ax="return abs(x);";function ZV(n){const{inputs:e,backend:t}=n,{x:i}=e;if(t.shouldExecuteOnCPU([i])&&i.dtype!=="complex64"){const s=t.texData.get(i.dataId),o=CC(s.values);return t.makeTensorInfo(i.shape,i.dtype,o)}let r;return ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new $o(i.shape,Ax):r=new us(i.shape,Ax),t.runWebGLProgram(r,[i],i.dtype)}const JV={kernelName:r1,backendName:"webgl",kernelFunc:ZV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QV=rr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,eG=gt({opSnippet:QV}),tG={kernelName:s1,backendName:"webgl",kernelFunc:eG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nG=rr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,iG=gt({opSnippet:nG}),rG={kernelName:o1,backendName:"webgl",kernelFunc:iG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rx="return a + b;",sG=An({opSnippet:Rx,packedOpSnippet:Rx,supportsComplex:!0,cpuKernelImpl:x4}),oG={kernelName:uy,backendName:"webgl",kernelFunc:sG};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aG{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);const i=[];this.variableNames.forEach(s=>{i.push(`float v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${i.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lG{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);const i=[];this.variableNames.forEach(s=>{i.push(`vec4 v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${i.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ud(n){const{inputs:e,backend:t}=n,i=e;if(i.length===1)return pi({inputs:{x:i[0]},backend:t});if(i.length>ne().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(i.length/2),c=ud({inputs:i.slice(0,l),backend:t}),u=ud({inputs:i.slice(l),backend:t});return ud({inputs:[c,u],backend:t})}const r=i.map(l=>l.dtype).reduce((l,c)=>Ur(l,c)),s=i.map(l=>l.shape),a=ne().getBool("WEBGL_PACK")?new lG(i[0].shape,s):new aG(i[0].shape,s);return t.runWebGLProgram(a,i,r)}const cG={kernelName:a1,backendName:"webgl",kernelFunc:ud};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uG(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=Mn(s,r.shape);let c=l;const u=tr(c,a);let h=r;u!=null&&(h=an({inputs:{x:r},backend:t,attrs:{perm:u}}),c=nr(c.length,a)),Pr("all",c,a);const[d,f]=Xr(h.shape,c),p=we(f),m=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),y=ba(m,m.dtype,"all",t);let g;if(o){const v=er(d,l);g=Me({inputs:{x:y},backend:t,attrs:{shape:v}})}else g=Me({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),g}const hG={kernelName:l1,backendName:"webgl",kernelFunc:uG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dG(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=Mn(s,r.shape);let c=l;const u=tr(c,a);let h=r;u!=null&&(h=an({inputs:{x:r},backend:t,attrs:{perm:u}}),c=nr(c.length,a)),Pr("any",c,a);const[d,f]=Xr(h.shape,c),p=we(f),m=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),y=ba(m,m.dtype,"any",t);let g;if(o){const v=er(d,l);g=Me({inputs:{x:y},backend:t,attrs:{shape:v}})}else g=Me({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),g}const fG={kernelName:c1,backendName:"webgl",kernelFunc:dG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pG{constructor(e,t,i){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:o}=e;i||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const a=t==="max"?">":"<",l=i?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mG{constructor(e,t,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,G(e.length>2,()=>`Packed arg${i.charAt(0).toUpperCase()+i.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],o=Math.ceil(s/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=$t(l),u=jn("coords",l);let h,d;if(o===1){d=l+1;const R=$t(d);h=`
        ${R} sourceLocR = ${R}(${u.join()}, 0);
        ++${u[l-1]};
        ${R} sourceLocG = ${R}(${u.join()}, 0);
        ++${u[l-2]};
        ${R} sourceLocA = ${R}(${u.join()}, 0);
        --${u[l-1]};
        ${R} sourceLocB = ${R}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,d),p="."+f[d-1],m=f.map(R=>"int "+R),y=jn("sourceLocR",d-1).concat("inIdx.r"),g=jn("sourceLocG",d-1).concat("inIdx.g"),v=jn("sourceLocB",d-1).concat("inIdx.b"),_=jn("sourceLocA",d-1).concat("inIdx.a"),b=i==="max"?"greaterThan":"lessThan",S=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${_.join()})));`,w=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,T=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FC(n,e,t,i=null){let r=e.shape[0],s=e.shape[1];i!=null&&(r=i.shape[0],s=i.shape[1]);const o=kf(s),a={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},l=new pG(a,t,i==null),c=[e];i!=null&&c.push(i);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=FC(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function $C(n,e,t,i=null){const r=i!=null?i.shape:e.shape,s=r[r.length-1],o=kf(s),a=new mG(r,o,t,i==null),l=i==null?[e]:[e,i],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=$C(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function BC(n,e,t,i){const r=[t];if(Pr("arg"+i.charAt(0).toUpperCase()+i.slice(1),r,e.shape.length),!ne().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const s=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),s.push(l));const[c,u]=Xr(l.shape,r),h=we(u),d=Me({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});s.push(d);const f=FC(n,d,i);s.push(f);const p=Me({inputs:{x:f},backend:n,attrs:{shape:c}});return s.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return $C(n,e,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s}=i;let o=Mn(s,r.shape);const a=tr(o,r.shape.length);let l=r;const c=[];a!=null&&(l=an({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=nr(o.length,l.shape.length)),Pr("argMax",[o[0]],l.shape.length);const u=BC(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const yG={kernelName:u1,backendName:"webgl",kernelFunc:gG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vG(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s}=i;let o=Mn(s,r.shape);const a=tr(o,r.shape.length);let l=r;const c=[];a!=null&&(l=an({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=nr(o.length,l.shape.length)),Pr("argMin",[o[0]],l.shape.length);const u=BC(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const xG={kernelName:h1,backendName:"webgl",kernelFunc:vG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _G=rr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bG=gt({opSnippet:_G}),wG={kernelName:d1,backendName:"webgl",kernelFunc:bG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=rr+"return log(x + sqrt(x * x + 1.0));",TG=gt({opSnippet:SG}),EG={kernelName:f1,backendName:"webgl",kernelFunc:TG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG=rr+`
  return atan(x);
`,MG=gt({opSnippet:CG}),AG={kernelName:p1,backendName:"webgl",kernelFunc:MG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG=OV+`
  return atan(a, b);
`,IG=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+FV+`
  return result;
`,PG=An({opSnippet:RG,packedOpSnippet:IG}),NG={kernelName:g1,backendName:"webgl",kernelFunc:PG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG=rr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,DG=gt({opSnippet:LG}),kG={kernelName:m1,backendName:"webgl",kernelFunc:DG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qc{constructor(e,t,i,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&i)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let v="0.0";if(m||(v="-1.0 / 1e-20"),i){const R=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${f}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${R} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?y:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(b="avgValue / count");const S=Math.floor(o/4)*4,w=o%4,T=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${f}, ${p});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${S};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${b});
      }
    `}}class jy{constructor(e,t,i,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&i)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.front,g=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const _=t==="avg";let b="0.0";if(_||(b="-1.0 / 1e-20"),i){const P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${y}, ${g}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / count");const T=Math.floor(o/4)*4,R=o%4,M=`
      if (${_}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${y}, ${g}, ${v});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${T};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${M}
            }
          }
          setOutput(${w});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OG(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e;Lu(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i,c=1;G(Li(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=Fl(r.shape,s,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&ln(u.inShape,u.outShape))return pi({inputs:{x:r},backend:t});const h=new qc(u,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const FG={kernelName:y1,backendName:"webgl",kernelFunc:OG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $G(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i,u=[1,1,1],h=Ru(r.shape,s,o,u,a,l,c),d=new jy(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const BG={kernelName:v1,backendName:"webgl",kernelFunc:$G};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zG{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,d=1/(t*i);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class UG{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,i=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=h-1-e.padInfo.front,m=d-1-e.padInfo.top,y=f-1-e.padInfo.left,g=1/(t*i*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VG(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=[1,1,1],d=Ru(o.shape,a,l,h,c,u),f=new UG(d);return t.runWebGLProgram(f,[r],o.dtype)}const GG={kernelName:PI,backendName:"webgl",kernelFunc:VG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s;Lu([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,u=Fl(o.shape,a,l,1,c),h=new zG(u);return t.runWebGLProgram(h,[r],o.dtype)}const WG={kernelName:II,backendName:"webgl",kernelFunc:HG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jG(n){const{inputs:e,backend:t,attrs:i}=n,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;return Ld({a:r,b:s,transposeA:o,transposeB:a,backend:t})}const qG={kernelName:x1,backendName:"webgl",kernelFunc:jG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XG{constructor(e,t,i,r,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Et(e,t),Et(e,i);let a="0.0";r!=null&&(Et(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(Et(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YG{constructor(e,t,i,r,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Et(e,t),Et(e,i);let a="vec4(0.0)";r!=null&&(Et(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(Et(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KG=({inputs:n,backend:e,attrs:t})=>{const{x:i,mean:r,variance:s,offset:o,scale:a}=n;G(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[i,r,s];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const d=ne().getBool("WEBGL_PACK_NORMALIZATION")?new YG(i.shape,r.shape,s.shape,u,h,l):new XG(i.shape,r.shape,s.shape,u,h,l);return e.runWebGLProgram(d,c,c[0].dtype)},ZG={kernelName:nw,backendName:"webgl",kernelFunc:KG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JG{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=$t(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const i=QG(this.rank);let r;const s=e.map((o,a)=>`sourceLoc.${vg[a]} = start[${a}] + coords.${vg[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${i}));
      }
    `}}const vg=["x","y","z","w","u","v"];function QG(n){if(n===1)return"sourceLoc";if(n<=6)return vg.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eH{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=$t(this.rank),i=jn("coords",this.rank),r=jn("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,a=`
      result.x = ${o};
      if (++${i[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${i[this.rank-1]};
      if (++${i[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${i[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${r[h]} = ${i[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tH(n,e,t,i){const r=i.texData.get(n.dataId),s=i.makeTensorInfo(t,n.dtype),o=i.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=wy(e,kn(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=i.dataRefCount.get(o.slice.origDataId)||1;return i.dataRefCount.set(o.slice.origDataId,l+1),s}function jl(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{begin:s,size:o}=i,[a,l]=wT(r,s,o);if(dT(r,a,l),we(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),d=j4(h.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const{isPacked:c}=t.texData.get(r.dataId),u=by(r.shape,a,l);if(c||!u){const h=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eH(l):new JG(l),d=[a];return t.runWebGLProgram(h,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),tH(r,a,l,t)}const nH={kernelName:sS,backendName:"webgl",kernelFunc:jl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iH=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockShape:s,crops:o}=i;G(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((v,_)=>v*_),l=ky(r.shape,s,a),c=Oy(l.length,s.length),u=Fy(r.shape,s,a),h=fE(o,s.length),d=pE(u,o,s.length),f=[],p=Me({inputs:{x:r},backend:t,attrs:{shape:l}}),m=an({inputs:{x:p},backend:t,attrs:{perm:c}}),y=Me({inputs:{x:m},backend:t,attrs:{shape:u}}),g=jl({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return f.push(p),f.push(m),f.push(y),f.forEach(v=>t.disposeIntermediateTensorInfo(v)),g},rH={kernelName:_1,backendName:"webgl",kernelFunc:iH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,weights:s}=e,{size:o}=i,a=t.readSync(r.dataId),l=t.readSync(s.dataId),c=EC(a,l,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,c)}const oH={kernelName:b1,backendName:"webgl",kernelFunc:sH};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aH(n){const{inputs:e,backend:t}=n,{s0:i,s1:r}=e,s=t.readSync(i.dataId),o=t.readSync(r.dataId),a=Et(Array.from(s),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const lH={kernelName:w1,backendName:"webgl",kernelFunc:aH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cH="return float(a != b);",zC=An({opSnippet:cH,cpuKernelImpl:z4,dtype:"bool"}),uH={kernelName:Lw,backendName:"webgl",kernelFunc:zC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ou(n){const{inputs:e,backend:t}=n,{input:i}=e,r=t.texData.get(i.dataId);return pi({inputs:{x:r.complexTensorInfos.real},backend:t})}const hH={kernelName:Ww,backendName:"webgl",kernelFunc:Ou};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dH="return float(int(x));";function fH(n,e){const t=new us(n.shape,dH),i=e.runWebGLProgram(t,[n],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xg(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{dtype:s}=i;if(s==="complex64"){if(r.dtype==="complex64")return pi({inputs:{x:r},backend:t});const o=no(r.shape),a=xg({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=mo({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=Ou({inputs:{input:r},backend:t}),a=xg({inputs:{x:o},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(o),a}if(!_I(r.dtype,s)){const o=pi({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(s==="int32")return fH(r,t);if(s==="bool"){const o=t.makeTensorInfo([],"bool",Js("bool",1)),l=zC({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}const pH={kernelName:hy,backendName:"webgl",kernelFunc:xg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ix="return ceil(x);",mH=gt({opSnippet:Ix,packedOpSnippet:Ix,cpuKernelImpl:b4}),gH={kernelName:S1,backendName:"webgl",kernelFunc:mH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yH{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vH{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xH(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{clipValueMin:s,clipValueMax:o}=i;let a;ne().getBool("WEBGL_PACK_CLIP")?a=new vH(r.shape):a=new yH(r.shape);const l=[[s],[o]];return t.runWebGLProgram(a,[r],r.dtype,l)}const _H={kernelName:T1,backendName:"webgl",kernelFunc:xH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bH{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Px(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function wH(n){const{inputs:e,backend:t}=n,{x:i}=e,r=t.texData.get(i.dataId),s=new bH(i.shape),o=[Px(i,r.complexTensorInfos.real),Px(i,r.complexTensorInfos.imag)];return t.runWebGLProgram(s,o,o[0].dtype)}const SH={kernelName:C1,backendName:"webgl",kernelFunc:wH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TH{constructor(e){this.outputShape=[],this.outputShape=Qo(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const i=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];i.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=t.length,s=t[t.length-1];i.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${i.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EH{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Qo(e,t);const i=this.outputShape,r=i.length,s=$t(r),o=jn("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const c=a[t],u=a.slice(-2),h=a.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const y=l[m-1];d+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${uh(a,c,y)}),
            vec2(${uh(u,c,y)}));
        }`}const f=l.length,p=l[l.length-1];d+=`
        return getChannel(
          getT${f}(${uh(a,c,p)}),
          vec2(${uh(u,c,p)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${i[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${i[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${i[r-2]} &&
            ${o[r-1]} < ${i[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function uh(n,e,t){const i=n.indexOf(e);return n.map((s,o)=>o===i?`${s} - ${t}`:s).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(n){const{inputs:e,backend:t}=n,{input:i}=e,r=t.texData.get(i.dataId);return pi({inputs:{x:r.complexTensorInfos.imag},backend:t})}const CH={kernelName:lw,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nl(n,e,t){const i=n[0].dtype;if(i==="complex64"){const u=n.map(m=>Ou({inputs:{input:m},backend:t})),h=n.map(m=>Vf({inputs:{input:m},backend:t})),d=nl(u,e,t),f=nl(h,e,t),p=mo({inputs:{real:d,imag:f},backend:t});return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),h.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),p}let r=t.shouldExecuteOnCPU(n);if(i==="string"&&(r=!0),r){const u=n.map(g=>{const v=we(g.shape.slice(e));return Me({inputs:{x:g},backend:t,attrs:{shape:[-1,v]}})}),h=u.map(g=>({vals:t.readSync(g.dataId),shape:g.shape})),d=Qo(u.map(g=>g.shape),1),f=u[0].shape[0]===1,p=w4(h,d,i,f),m=Qo(n.map(g=>g.shape),e),y=t.makeTensorInfo(m,i,p);return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),y}if(n.length>ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(n.length/2),h=nl(n.slice(0,u),e,t),d=nl(n.slice(u),e,t),f=nl([h,d],e,t);return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),f}if(ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const u=new EH(n.map(h=>h.shape),e);return t.runWebGLProgram(u,n,i)}const{tensors2D:s,outShape:o}=MH(n,e,t),a=new TH(s.map(u=>u.shape)),l=t.runWebGLProgram(a,s,i);s.forEach(u=>t.disposeIntermediateTensorInfo(u));const c=Me({inputs:{x:l},attrs:{shape:o},backend:t});return t.disposeIntermediateTensorInfo(l),c}function MH(n,e,t){const i=Qo(n.map(s=>s.shape),e);return{tensors2D:n.map(s=>Me({inputs:{x:s},attrs:{shape:[-1,we(s.shape.slice(e))]},backend:t})),outShape:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(n){const{inputs:e,backend:t,attrs:i}=n,{axis:r}=i,s=Mn(r,e[0].shape)[0],o=Qo(e.map(c=>c.shape),s);if(we(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const a=e.filter(c=>we(c.shape)>0);if(a.length===1)return pi({inputs:{x:a[0]},backend:t});const l=a.map(c=>c.shape);return hE(l,s),nl(a,s,t)}const AH={kernelName:M1,backendName:"webgl",kernelFunc:UC};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VC{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,y=e.dataFormat==="channelsLast",g=y?1:2,v=y?2:3,_=y?3:1;let b="",S="";i&&(r?b=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:s?b=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:b=`
          float activation(float x) {
            ${i}
          }
        `,S="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${_}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${S}
        setOutput(result);
      }
    `}}class RH{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,i=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,f=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${i}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ai(this.outputShape.length);const{dataFormat:i}=t,r=Zn(),s=i==="channelsLast",o=s?0:1,a=s?1:2,l=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.y + ${h};
          pos = rc.x + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GC({x:n,filter:e,convInfo:t,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=i.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,f=t.dataFormat==="channelsLast",p=!1,m=!1;let y;const g=[];if(s!=null&&!f&&s.shape.length===3){const b=an({inputs:{x:s},backend:i,attrs:{perm:[1,2,0]}});g.push(b),s=b}if(!((h===1||d===1)&&u>OC)&&c.isPacked&&f&&c.texture!=null&&l[2]%2!==0&&ln(c.shape.slice(-3),l.slice(-3))){const b=l[0]*l[1]*(l[2]+1),S={dataId:n.dataId,shape:[1,b,t.inChannels],dtype:n.dtype},w=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,G(Nd(c.shape,S.shape),()=>`packed reshape ${c.shape} to ${S.shape} isn't free`);const T=Me({inputs:{x:e},backend:i,attrs:{shape:[1,t.inChannels,t.outChannels]}});g.push(T);const R=Ld({a:S,b:T,backend:i,transposeA:p,transposeB:m,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),M=i.texData.get(R.dataId);G(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=w,M.shape=t.outShape,y=pi({inputs:{x:R},backend:i}),y.shape=t.outShape,g.push(R)}else{const b=f?n:an({inputs:{x:n},backend:i,attrs:{perm:[0,2,3,1]}}),S=b.shape,w=S[0]*S[1]*S[2],T=Me({inputs:{x:b},backend:i,attrs:{shape:[1,w,t.inChannels]}}),R=Me({inputs:{x:e},backend:i,attrs:{shape:[1,t.inChannels,t.outChannels]}}),M=Ld({a:T,b:R,transposeA:p,transposeB:m,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),P=[t.batchSize,t.outHeight,t.outWidth,t.outChannels],L=Me({inputs:{x:M},backend:i,attrs:{shape:P}});y=f?L:an({inputs:{x:L},backend:i,attrs:{perm:[0,3,1,2]}}),f||(g.push(b),g.push(L)),g.push(T),g.push(R),g.push(M)}for(const b of g)i.disposeIntermediateTensorInfo(b);return y}function HC({x:n,filter:e,convInfo:t,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:f}=t,p=f==="channelsLast",m=l*c*u,y=d*h,g=[m,y],v=!0,_=!1,b=[];if(s!=null&&!p&&s.shape.length===3){const re=an({inputs:{x:s},backend:i,attrs:{perm:[1,2,0]}});b.push(re),s=re}const S=Me({inputs:{x:n},backend:i,attrs:{shape:n.shape.slice(1)}}),w=Me({inputs:{x:e},backend:i,attrs:{shape:[1,m,we(e.shape)/m]}});b.push(S),b.push(w);const T=new IH(g,t),R=[S.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],M=i.runWebGLProgram(T,[S],"float32",R),P=Me({inputs:{x:M},backend:i,attrs:{shape:[1,g[0],g[1]]}});b.push(M),b.push(P);const L=r!=null,$=s!=null,O=a==="leakyrelu",I=a?Bf(a,!0):null,N=new kC(P.shape,w.shape,[1,y,t.outChannels],v,_,L,I,$,O),V=[P,w];if(r&&V.push(r),$&&V.push(s),O){const re=i.makeTensorInfo([],"float32",kl(o,"float32"));V.push(re),b.push(re)}const X=i.runWebGLProgram(N,V,"float32"),J=[1,d,h,t.outChannels],W=Me({inputs:{x:X},backend:i,attrs:{shape:J}}),Q=p?W:an({inputs:{x:W},backend:i,attrs:{perm:[0,3,1,2]}});p||b.push(W),b.push(X);for(const re of b)i.disposeIntermediateTensorInfo(re);return Q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=i,h=$l(l),d=Ni(r.shape,s.shape,o,c,a,u,!1,h);let f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=GC({x:r,filter:s,convInfo:d,backend:t});else if(ne().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)f=HC({x:r,filter:s,convInfo:d,backend:t});else{const m=new VC(d);f=t.runWebGLProgram(m,[r,s],"float32")}const p=Me({inputs:{x:f},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(f),p}const NH={kernelName:A1,backendName:"webgl",kernelFunc:PH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LH{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,i=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${i} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class DH{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=i-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${i} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kH{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${i} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class OH{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,i=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=i-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${i}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${i} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=i,h=$l(l),d=Ni(r.shape,u,o,1,a,c,!1,h),f=new LH(d);return t.runWebGLProgram(f,[r,s],"float32")}const $H={kernelName:R1,backendName:"webgl",kernelFunc:FH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BH(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=i,h=$l(c),d=Ni(o,s.shape,a,1,l,u,!1,h),f=new DH(d);return t.runWebGLProgram(f,[r,s],"float32")}const zH={kernelName:I1,backendName:"webgl",kernelFunc:BH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UH(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=Iu(r.shape,s.shape,o,l,a),u=new RH(c);return t.runWebGLProgram(u,[r,s],"float32")}const VH={kernelName:P1,backendName:"webgl",kernelFunc:UH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GH(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i,c=Iu(r.shape,l,o,1,a),u=new kH(c);return t.runWebGLProgram(u,[r,s],"float32")}const HH={kernelName:NI,backendName:"webgl",kernelFunc:GH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WH(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{pad:o,strides:a,inputShape:l}=i,c=Iu(l,s.shape,a,1,o),u=new OH(c);return t.runWebGLProgram(u,[r,s],"float32")}const jH={kernelName:LI,backendName:"webgl",kernelFunc:WH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH=Wl+`
  return cos(x);
`,XH=gt({opSnippet:qH}),YH={kernelName:N1,backendName:"webgl",kernelFunc:XH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KH=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,ZH=gt({opSnippet:KH}),JH={kernelName:L1,backendName:"webgl",kernelFunc:ZH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QH{constructor(e,t,i,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,d]=i;this.outputShape=[u,h,d,c];const f=r==="bilinear"?1:0,[p,m]=[`${a-1}.0`,`${l-1}.0`],[y,g,v]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[_,b,S]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${_});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${b};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eW=n=>{const{inputs:e,backend:t,attrs:i}=n,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=i,u=new QH(r.shape,s.shape,a,l,c);return t.runWebGLProgram(u,[r,s,o],"float32")},tW={kernelName:O1,backendName:"webgl",kernelFunc:eW};var Xc;(function(n){n.Prod="*",n.Sum="+"})(Xc||(Xc={}));class Nx{constructor(e,t,i,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,o=this.op===Xc.Prod?"1.0":"0.0",a=i?o:`getX(${Lx(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";i?(c=r?`end != ${l-1}`:"end != 0",u=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${$t(s)} coords = getOutputCoords();
        int end = ${Dx(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${Dx(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${Lx(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Lx(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Dx(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n,e,t,i,r,s){const o=e.shape.length,a=tr([i],o);let l=e;a!=null&&(l=an({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=nr(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${i}`);const u=l.shape[c];let h=pi({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const f=new Nx(n,l.shape,!1,s),p=[[d]],m=h;h=t.runWebGLProgram(f,[h],h.dtype,p),t.disposeIntermediateTensorInfo(m)}if(r){const d=new Nx(n,l.shape,r,s),f=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(f)}if(a!=null){const d=My(a),f=an({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return WC(Xc.Prod,r,t,s,o,a)}const iW={kernelName:D1,backendName:"webgl",kernelFunc:nW};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return WC(Xc.Sum,r,t,s,o,a)}const sW={kernelName:k1,backendName:"webgl",kernelFunc:rW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(r.shape.length===1){const l=t.readSync(r.dataId),c=t.readSync(s.dataId),u=EC(l,c,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,u)}else if(r.shape.length===2){const l=t.bufferSync(r),c=t.bufferSync(s),u=_4(l,c,o,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const aW={kernelName:F1,backendName:"webgl",kernelFunc:oW};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lW{constructor(e,t,i){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=i,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockSize:s,dataFormat:o}=i,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],u=o==="NHWC"?r.shape[3]:r.shape[1],h=l*s,d=c*s,f=u/(s*s),p=o==="NHWC"?[a,h,d,f]:[a,f,h,d],m=new lW(p,s,o);return t.runWebGLProgram(m,[r],r.dtype)}const uW={kernelName:$1,backendName:"webgl",kernelFunc:cW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jC{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ai(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";i&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:s?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:c=`
          float activation(float x) {
            ${i}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qC{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ai(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,d=h;let f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<h;g++)f+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;f+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<h;g++)f+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){const v=g*2;if(f+=`
          xC = xCCorner + ${v*c};
          `,l===1){if(v<h&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,c===1&&v>0?f+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<h)){const _=a%2===0?Zb(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${_};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,c>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                      xTexelC${v} = getX(batch, xR, xCOffset, d1);
                      xTexelC${v}Ready = 1;
                    }
                    `),f+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                  `):_===1?f+=`
                    xC${v+1} = xTexelC${v};
                    `:f+=`
                    xCOffset = xC + ${_};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<h&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<h&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<h&&(f+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<h&&(f+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<h&&(f+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let p="",m="";i&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:p=`vec4 activation(vec4 x) {
          ${i}
        }`,m="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=i;let u=l;u==null&&(u=[1,1]),G(Li(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=Ni(r.shape,s.shape,o,u,a,c,!0);let d;ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new qC(h):d=new jC(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[r,s],"float32",f)}const dW={kernelName:B1,backendName:"webgl",kernelFunc:hW};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,i=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${i} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.top,a=i-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${i} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=i,h=Ni(r.shape,u,o,a,l,c,!0),d=new fW(h);return t.runWebGLProgram(d,[r,s],"float32")}const gW={kernelName:z1,backendName:"webgl",kernelFunc:mW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=i,h=Ni(u,s.shape,o,a,l,c,!0),d=new pW(h);return t.runWebGLProgram(d,[r,s],"float32")}const vW={kernelName:U1,backendName:"webgl",kernelFunc:yW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xW{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _W(n){const{inputs:e,backend:t}=n,{x:i}=e,r=[...i.shape,...i.shape],s=we(i.shape),o=Me({inputs:{x:i},backend:t,attrs:{shape:[s]}}),a=new xW(s),l=t.runWebGLProgram(a,[o],o.dtype),c=Me({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const bW={kernelName:DI,backendName:"webgl",kernelFunc:_W};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:i,padInfo:r,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${i}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=CT(r.shape,s.shape,o,a,"NHWC",l);let u;const h=new wW(c);u=t.runWebGLProgram(h,[r,s],"float32");const d=Me({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),d}const TW={kernelName:V1,backendName:"webgl",kernelFunc:SW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(n){const{inputs:e,backend:t,attrs:i}=n,{equation:r}=i,s=e,{allDims:o,summedDims:a,idDims:l}=SE(r,s.length);EE(o.length,l,s);const{path:c,steps:u}=CE(a,l),h=u.length;let d=null,f=o.length;const p=[];for(let m=0;m<h;++m){for(const y of u[m]){const{permutationIndices:g,expandDims:v}=TE(f,l[y]);let _;ME(g)?_=s[y]:(_=an({inputs:{x:s[y]},backend:t,attrs:{perm:g}}),p.push(_));const b=_.shape.slice();for(let S=0;S<v.length;++S)b.splice(v[S],0,1);ln(_.shape,b)||(_=Me({inputs:{x:_},backend:t,attrs:{shape:b}}),p.push(_)),d===null?d=_:(d=Wy({inputs:{a:_,b:d},backend:t}),p.push(d))}m<h-1&&(c[m]>=0&&(d=Uf({inputs:{x:d},backend:t,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(d)),f--)}for(const m of p)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const CW={kernelName:H1,backendName:"webgl",kernelFunc:EW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MW="return (x >= 0.0) ? x : (exp(x) - 1.0);",AW=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,RW=gt({opSnippet:MW,packedOpSnippet:AW}),IW={kernelName:W1,backendName:"webgl",kernelFunc:RW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW="return (b >= 1.0) ? a : a * (b + 1.0);",NW=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,LW=n=>{const{inputs:e,backend:t}=n,{dy:i,y:r}=e,s=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ku(NW,i.shape,r.shape):new wl(PW,i.shape,r.shape);return t.runWebGLProgram(s,[i,r],i.dtype)},DW={kernelName:kI,backendName:"webgl",kernelFunc:LW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kW=`
  return vec4(equal(a, b));
`,OW="return float(a == b);",FW=An({opSnippet:OW,packedOpSnippet:kW,dtype:"bool",cpuKernelImpl:S4}),$W={kernelName:q1,backendName:"webgl",kernelFunc:FW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BW=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${yE};
  float a1 = ${vE};
  float a2 = ${xE};
  float a3 = ${_E};
  float a4 = ${bE};
  float a5 = ${wE};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,zW=gt({opSnippet:BW}),UW={kernelName:j1,backendName:"webgl",kernelFunc:zW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW=Wl+`
  return exp(x);
`,GW=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,XC=gt({opSnippet:VW,packedOpSnippet:GW,cpuKernelImpl:T4,dtype:"float32"}),HW={kernelName:X1,backendName:"webgl",kernelFunc:XC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _g(n){const{inputs:e,attrs:t,backend:i}=n,{dim:r}=t,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=r;return r<0&&(G(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Me({inputs:{x:s},backend:i,attrs:{shape:a}})}const WW={kernelName:Y1,backendName:"webgl",kernelFunc:_g};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kx="return exp(x) - 1.0;",jW=gt({opSnippet:kx,packedOpSnippet:kx,cpuKernelImpl:E4}),qW={kernelName:K1,backendName:"webgl",kernelFunc:jW};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ox{constructor(e,t,i){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=i?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=i?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YC(n,e,t){const i=t.texData.get(n.dataId),r=we(n.shape),s=n.shape[n.shape.length-1],o=r/s,a=Me({inputs:{x:n},backend:t,attrs:{shape:[o,s]}}),l=a.shape,c=new Ox("real",l,e),u=new Ox("imag",l,e),h=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:l},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(c,h,"float32"),f=t.runWebGLProgram(u,h,"float32"),p=mo({inputs:{real:d,imag:f},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f);const m=Me({inputs:{x:p},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(n){const{inputs:e,backend:t}=n,{input:i}=e;return YC(i,!1,t)}const YW={kernelName:Z1,backendName:"webgl",kernelFunc:XW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KW{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fu(n){const{backend:e,attrs:t}=n,{shape:i,value:r}=t;let{dtype:s}=t;if(s=s||Tf(r),s==="string"){const o=Gi(s,we(i));return o.fill(r),e.makeTensorInfo(i,s,o)}else{const o=new KW(i,r),a=[[r]];return e.runWebGLProgram(o,[],s,a)}}const ZW={kernelName:J1,backendName:"webgl",kernelFunc:Fu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JW{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QW={kernelName:Q1,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,i=e,r=new JW(t.shape);return i.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fx="return floor(x);",e5=gt({opSnippet:Fx,packedOpSnippet:Fx,cpuKernelImpl:C4}),t5={kernelName:ew,backendName:"webgl",kernelFunc:e5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n5=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,i5=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,r5=An({opSnippet:n5,packedOpSnippet:i5,dtype:"int32"}),s5={kernelName:tw,backendName:"webgl",kernelFunc:r5};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o5{constructor(e){this.variableNames=["A"];const t=Zn(),[i,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${i}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a5{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Zn(),[i,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${i}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l5={kernelName:Nm,backendName:"webgl",kernelFunc:c5};let Aa;function c5(n){const{inputs:e,backend:t,attrs:i}=n;let{pixels:r}=e;const{numChannels:s}=i,o=typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,s];(a||o)&&(Aa==null&&(Aa=document.createElement("canvas").getContext("2d")),Aa.canvas.width=l,Aa.canvas.height=c,Aa.drawImage(r,0,0,l,c),r=Aa.canvas);const d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=Ti.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const f=ne().getBool("WEBGL_PACK")?new a5(h):new o5(h),p=t.runWebGLProgram(f,[d],"int32");return t.disposeData(d.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u5(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=i,m=$l(u),y=Ni(r.shape,s.shape,l,h,c,d,!1,m);let g;const v=[];if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))g=GC({x:r,filter:s,convInfo:y,backend:t,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else if(ne().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)g=HC({x:r,filter:s,convInfo:y,backend:t,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const b=o!=null,S=a!=null,w=f==="leakyrelu",T=f?Bf(f,!1):null,R=new VC(y,b,T,S,w),M=[r,s],P=(L,$)=>{if($==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){const O=Me({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return v.push(O),O}return L};if(b&&M.push(P(o,u)),S&&M.push(P(a,u)),w){const L=t.makeTensorInfo([],"float32",kl(p,"float32"));M.push(L),v.push(L)}g=t.runWebGLProgram(R,M,"float32")}const _=Me({inputs:{x:g},backend:t,attrs:{shape:y.outShape}});return v.push(g),v.forEach(b=>t.disposeIntermediateTensorInfo(b)),_}const h5={kernelName:Dm,backendName:"webgl",kernelFunc:u5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:f}=i,p=[];let m=u;m==null&&(m=[1,1]),G(Li(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const y=Ni(r.shape,s.shape,l,m,c,h,!0),g=ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=d?Bf(d,g):null,_=[r,s],b=o!=null,S=a!=null,w=d==="leakyrelu";if(b&&_.push(o),S&&_.push(a),w){const P=t.makeTensorInfo([],"float32",kl(f,"float32"));_.push(P),p.push(P)}let T;g?T=new qC(y,b,v,S,w):T=new jC(y,b,v,S,w);const R=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],M=t.runWebGLProgram(T,_,"float32",R);return p.forEach(P=>t.disposeIntermediateTensorInfo(P)),M}const f5={kernelName:km,backendName:"webgl",kernelFunc:d5};class p5{constructor(e,t,i){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=i;const r=$t(t.length),s=$t(i.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${r} strides = ${r}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${o};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5(n){const{inputs:e,backend:t}=n,{params:i,indices:r}=e,s=r.shape,o=s[s.length-1],a=we(i.shape),[l,c,u,h]=cT(i,r),d=Me({inputs:{x:r},backend:t,attrs:{shape:[c,o]}}),f=Me({inputs:{x:i},backend:t,attrs:{shape:[we(i.shape)/u,u]}});if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const g=t.readSync(r.dataId),v=t.bufferSync(i),_=M4(g,v,i.dtype,c,o,u,h,i.shape,a);return t.makeTensorInfo(l,i.dtype,_.values)}const p=new p5(o,h,[c,u]),m=t.runWebGLProgram(p,[f,d],f.dtype),y=Me({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),y}const g5={kernelName:rw,backendName:"webgl",kernelFunc:m5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y5{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const i=$t(this.rank),r=v5(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function v5(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let r=0;r<n.length;r++)r===2?i.push("index"):i.push(`${t[r]}`);return i.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KC(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,indices:s}=e,{axis:o,batchDims:a}=i,l=Mn(o,r.shape)[0];if(ne().get("DEBUG")){const v=t.readSync(s.dataId),_=r.shape[l];for(let b=0;b<v.length;++b){const S=v[b];G(S<=_-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${_-1}]`)}}const c=VE(r,s,l,a),u=we(s.shape),h=[],d=Me({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=Me({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(f);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const v=t.bufferSync(f),_=t.bufferSync(d),b=A4(_,v,p);return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(c.outputShape,b.dtype,b.values)}const m=new y5(d.shape,p),y=t.runWebGLProgram(m,[d,f],d.dtype);h.push(y);const g=Me({inputs:{x:y},backend:t,attrs:{shape:c.outputShape}});return h.forEach(v=>t.disposeIntermediateTensorInfo(v)),g}const x5={kernelName:iw,backendName:"webgl",kernelFunc:KC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _5="return float(a > b);",b5=`
  return vec4(greaterThan(a, b));
`,w5=An({opSnippet:_5,packedOpSnippet:b5,cpuKernelImpl:R4,dtype:"bool"}),S5={kernelName:sw,backendName:"webgl",kernelFunc:w5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T5="return float(a >= b);",E5=`
  return vec4(greaterThanEqual(a, b));
`,C5=An({opSnippet:T5,packedOpSnippet:E5,dtype:"bool",cpuKernelImpl:I4}),M5={kernelName:ow,backendName:"webgl",kernelFunc:C5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(n){const{inputs:e,backend:t}=n,{input:i}=e;return YC(i,!0,t)}const R5={kernelName:aw,backendName:"webgl",kernelFunc:A5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I5="return float(!isnan(x) && !isinf(x));",P5=gt({opSnippet:I5,dtype:"bool"}),N5={kernelName:OI,backendName:"webgl",kernelFunc:P5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L5="return float(isinf(x));",D5=gt({opSnippet:L5,dtype:"bool"}),k5={kernelName:FI,backendName:"webgl",kernelFunc:D5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O5="return float(isnan(x));",F5=gt({opSnippet:O5,dtype:"bool"}),$5={kernelName:cw,backendName:"webgl",kernelFunc:F5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B5="return float(a < b);",z5=`
  return vec4(lessThan(a, b));
`,U5=An({opSnippet:B5,packedOpSnippet:z5,cpuKernelImpl:P4,dtype:"bool"}),V5={kernelName:hw,backendName:"webgl",kernelFunc:U5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G5="return float(a <= b);",H5=`
  return vec4(lessThanEqual(a, b));
`,W5=An({opSnippet:G5,packedOpSnippet:H5,cpuKernelImpl:N4,dtype:"bool"}),j5={kernelName:dw,backendName:"webgl",kernelFunc:W5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5(n){const{backend:e,attrs:t}=n,{start:i,stop:r,num:s}=t,o=L4(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}const X5={kernelName:fw,backendName:"webgl",kernelFunc:q5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y5=Wl+`
  return x < 0.0 ? 0./0. : log(x);
`,K5=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Z5=gt({opSnippet:Y5,packedOpSnippet:K5,cpuKernelImpl:D4}),J5={kernelName:pw,backendName:"webgl",kernelFunc:Z5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q5=Wl+`
  return log(1.0 + x);
`,e6=gt({opSnippet:Q5}),t6={kernelName:mw,backendName:"webgl",kernelFunc:e6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n6="return float(a >= 1.0 && b >= 1.0);",i6=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,r6=An({opSnippet:n6,packedOpSnippet:i6,dtype:"bool"}),s6={kernelName:gw,backendName:"webgl",kernelFunc:r6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o6="return float(!(x >= 1.0));",a6=gt({opSnippet:o6}),l6={kernelName:yw,backendName:"webgl",kernelFunc:a6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c6="return float(a >= 1.0 || b >= 1.0);",u6=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,h6=An({opSnippet:c6,packedOpSnippet:u6,dtype:"bool"}),d6={kernelName:vw,backendName:"webgl",kernelFunc:h6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f6{constructor(e,t,i,r,s){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${i}) + float(${r}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p6{constructor(e,t,i,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${i}) + float(${r}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m6=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i,c=ne().getBool("WEBGL_PACK_NORMALIZATION")?new p6(r.shape,s,o,a,l):new f6(r.shape,s,o,a,l);return t.runWebGLProgram(c,[r],r.dtype)},g6={kernelName:xw,backendName:"webgl",kernelFunc:m6};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y6{constructor(e,t,i,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=i,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${i});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v6=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=i,h=new y6(r.shape,a,l,c,u);return t.runWebGLProgram(h,[r,s,o],r.dtype)},x6={kernelName:$I,backendName:"webgl",kernelFunc:v6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6(n,e,t,i){const r=we(e),o=we(n.shape)/r,a=Me({inputs:{x:n},attrs:{shape:[o,r]},backend:i}),l=ba(a,n.dtype,"max",i),c=Me({inputs:{x:l},attrs:{shape:t},backend:i});return i.disposeIntermediateTensorInfo(a),i.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{reductionIndices:s,keepDims:o}=i,a=r.shape.length,l=Mn(s,r.shape);let c=l;const u=tr(c,a),h=u!=null,d=t.shouldExecuteOnCPU([r]);let f=r;if(h){if(d){const _=t.texData.get(f.dataId).values,b=new Array(a);for(let T=0;T<b.length;T++)b[T]=r.shape[u[T]];const S=Hy(_,r.shape,r.dtype,u,b);f=t.makeTensorInfo(b,r.dtype);const w=t.texData.get(f.dataId);w.values=S}else f=zf(r,u,t);c=nr(c.length,a)}Pr("max",c,a);const[p,m]=Xr(f.shape,c);let y=p;o&&(y=er(p,l));let g;if(d){const _=t.texData.get(f.dataId).values,b=k4(_,we(m),y,r.dtype);g=t.makeTensorInfo(y,r.dtype);const S=t.texData.get(g.dataId);S.values=b}else g=_6(f,m,y,t);return h&&t.disposeIntermediateTensorInfo(f),g}const b6={kernelName:_w,backendName:"webgl",kernelFunc:ZC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w6=IC+`
  return max(a, b);
`,S6=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+$f+`
  return result;
`,T6=An({opSnippet:w6,packedOpSnippet:S6,cpuKernelImpl:O4}),E6={kernelName:bw,backendName:"webgl",kernelFunc:T6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C6(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e;Lu(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i,c=1;G(Li(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=Fl(r.shape,s,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&ln(u.inShape,u.outShape))return pi({inputs:{x:r},backend:t});const h=new qc(u,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const M6={kernelName:ww,backendName:"webgl",kernelFunc:C6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A6(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=i,u=[1,1,1],h=Ru(r.shape,s,o,u,a,c,l),d=new jy(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const R6={kernelName:Sw,backendName:"webgl",kernelFunc:A6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I6{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,i=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=s-1-e.padInfo.top,l=o-1-e.padInfo.left,c=s*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class P6{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=c-1-e.padInfo.top,f=u-1-e.padInfo.left,p=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N6(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=[1,1,1],d=Ru(o.shape,a,l,h,c,u),f=new jy(d,"max",!0),p=t.runWebGLProgram(f,[o],o.dtype),m=new P6(d),y=t.runWebGLProgram(m,[r,p],o.dtype);return t.disposeIntermediateTensorInfo(p),y}const L6={kernelName:zI,backendName:"webgl",kernelFunc:N6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D6(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s,output:o}=e,a=s;Lu([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=i,d=Fl(a.shape,l,c,1,u,h),f=!0,p=new qc(d,"max",f),m=t.runWebGLProgram(p,[a],a.dtype),y=new I6(d),g=t.runWebGLProgram(y,[r,m],a.dtype);return t.disposeIntermediateTensorInfo(m),g}const k6={kernelName:BI,backendName:"webgl",kernelFunc:D6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O6(n,e,t,i){let r=new qc(t,"max",!1);const s=i.runWebGLProgram(r,[n],"float32");r=new qc(t,"max",!0,!0,e);const o=i.runWebGLProgram(r,[n],"float32");return[s,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F6={kernelName:Tw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:i}=n,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=e,l=t;G(i.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);const c=[1,1];G(Li(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const u=Fl(i.shape,r,s,c,o),[h,d]=O6(i,a,u,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6(n,e,t,i){const r=we(e),o=we(n.shape)/r,a=Me({inputs:{x:n},attrs:{shape:[o,r]},backend:i}),l=ba(a,"float32","mean",i),c=Me({inputs:{x:l},attrs:{shape:t},backend:i});return i.disposeIntermediateTensorInfo(a),i.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B6={kernelName:Ew,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:i}=n,{keepDims:r,axis:s}=e,o=t,a=i.shape.length,l=Mn(s,i.shape);let c=l;const u=tr(c,a),h=u!=null,d=o.shouldExecuteOnCPU([i]),f=[];let p=i;if(h){if(d){const b=o.texData.get(p.dataId).values,S=new Array(a);for(let R=0;R<S.length;R++)S[R]=i.shape[u[R]];const w=Hy(b,i.shape,i.dtype,u,S);p=o.makeTensorInfo(S,i.dtype);const T=o.texData.get(p.dataId);T.values=w}else p=zf(i,u,o);f.push(p),c=nr(c.length,a)}Pr("sum",c,a);const[m,y]=Xr(p.shape,c);let g=m;r&&(g=er(m,l));const v=$6(p,y,g,o);for(const _ of f)o.disposeIntermediateTensorInfo(_);return v}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z6(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=Mn(s,r.shape);let c=l;const u=tr(c,a);let h=r;u!=null&&(h=an({inputs:{x:r},backend:t,attrs:{perm:u}}),c=nr(c.length,r.shape.length)),Pr("min",c,a);const[d,f]=Xr(h.shape,c),p=we(f),m=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),y=ba(m,m.dtype,"min",t);let g;if(o){const v=er(d,l);g=Me({inputs:{x:y},backend:t,attrs:{shape:v}})}else g=Me({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),g}const U6={kernelName:Cw,backendName:"webgl",kernelFunc:z6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V6=IC+`
  return min(a, b);
`,G6=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+$f+`
  return result;
`,H6=An({opSnippet:V6,packedOpSnippet:G6,cpuKernelImpl:F4}),W6={kernelName:Mw,backendName:"webgl",kernelFunc:H6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j6{constructor(e,t,i){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const r=e.length,s=$t(r),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=i==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q6{constructor(e,t,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);const r=e.length,s=$t(r),o=t.map(p=>p[0]).join(","),a=t.map((p,m)=>p[0]+e[m]).join(","),l=jn("rc",r),c=jn("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=i==="reflect"?0:1;let f="";if(r===1){const p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[r-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X6=({inputs:n,backend:e,attrs:t})=>{const{x:i}=n,{paddings:r,mode:s}=t,o=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new q6(i.shape,r,s):new j6(i.shape,r,s);return e.runWebGLProgram(o,[i],i.dtype)},Y6={kernelName:Aw,backendName:"webgl",kernelFunc:X6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K6=`if (b == 0.0) return NAN;
  return mod(a, b);`,Z6=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+$f+`
  return result;
`,J6=An({opSnippet:K6,packedOpSnippet:Z6}),Q6={kernelName:Rw,backendName:"webgl",kernelFunc:J6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e8{constructor(e,t,i){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,i],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t8=`
if (a == b) {
  return 1.0;
};
return a / b;`,n8=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,JC=An({opSnippet:t8,packedOpSnippet:n8,checkOutOfBounds:!0}),i8={kernelName:G1,backendName:"webgl",kernelFunc:JC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $x="return a - b;",QC=An({opSnippet:$x,packedOpSnippet:$x,supportsComplex:!0,cpuKernelImpl:eV}),r8={kernelName:CS,backendName:"webgl",kernelFunc:QC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eM(n){const{inputs:e,backend:t,attrs:i}=n,{logits:r}=e,{dim:s}=i,o=Mn([s],r.shape),a=ZC({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=er(a.shape,o),c=Me({inputs:{x:a},backend:t,attrs:{shape:l}}),u=QC({inputs:{a:r,b:c},backend:t}),h=XC({inputs:{x:u},backend:t}),d=Uf({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),f=Me({inputs:{x:d},backend:t,attrs:{shape:l}}),p=JC({inputs:{a:h,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),p}const s8={kernelName:mS,backendName:"webgl",kernelFunc:eM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n){const{inputs:e,backend:t,attrs:i}=n,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i,l=a?r:eM({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new e8(c,u,s),d=[[o]],f=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),f}const a8={kernelName:Iw,backendName:"webgl",kernelFunc:o8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l8=rr+`
  return -x;
`,c8=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function u8(n){const{inputs:e,backend:t}=n,{x:i}=e;if(t.shouldExecuteOnCPU([i])){const s=t.texData.get(i.dataId),[o,a]=B4(s.values,i.shape,i.dtype);return t.makeTensorInfo(a,i.dtype,o)}let r;return ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new $o(i.shape,c8):r=new us(i.shape,l8),t.runWebGLProgram(r,[i],i.dtype)}const h8={kernelName:Nw,backendName:"webgl",kernelFunc:u8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d8=lE;function f8(n){xr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i,c=t.readSync(r.dataId),u=t.readSync(s.dataId),{selectedIndices:h}=d8(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const p8={kernelName:Dw,backendName:"webgl",kernelFunc:f8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m8=cE;function g8(n){xr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i,u=t.readSync(r.dataId),h=t.readSync(s.dataId),{selectedIndices:d,validOutputs:f}=m8(u,h,o,a,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}const y8={kernelName:kw,backendName:"webgl",kernelFunc:g8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v8=uE;function x8(n){xr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i,u=t.readSync(r.dataId),h=t.readSync(s.dataId),d=o,f=a,p=l,m=c,{selectedIndices:y,selectedScores:g}=v8(u,h,d,f,p,m);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const _8={kernelName:Ow,backendName:"webgl",kernelFunc:x8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b8{constructor(e,t,i,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${i}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w8=n=>{const{inputs:e,backend:t,attrs:i}=n,{indices:r}=e,{depth:s,onValue:o,offValue:a}=i,l=we(r.shape),c=new b8(l,s,o,a),u=Me({inputs:{x:r},backend:t,attrs:{shape:[l]}}),h=t.runWebGLProgram(c,[u],r.dtype);t.disposeIntermediateTensorInfo(u);const d=[...r.shape,s],f=Me({inputs:{x:h},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),f},S8={kernelName:$w,backendName:"webgl",kernelFunc:w8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(n){const{inputs:e,backend:t}=n,{x:i}=e;if(i.dtype==="complex64"){const r=Ou({inputs:{input:i},backend:t}),s=Dd({inputs:{x:r},backend:t}),o=Vf({inputs:{input:i},backend:t}),a=Dd({inputs:{x:o},backend:t}),l=mo({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Fu({attrs:{shape:i.shape,dtype:i.dtype,value:i.dtype==="string"?"":0},backend:t})}const T8={kernelName:LS,backendName:"webgl",kernelFunc:Dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(n){const{inputs:e,backend:t}=n,{x:i}=e;if(i.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(i.dtype==="complex64"){const r=Ou({inputs:{input:i},backend:t}),s=tM({inputs:{x:r},backend:t}),o=Vf({inputs:{input:i},backend:t}),a=Dd({inputs:{x:o},backend:t}),l=mo({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Fu({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:t})}const E8={kernelName:Fw,backendName:"webgl",kernelFunc:tM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C8(n){const{inputs:e,backend:t,attrs:i}=n,{axis:r}=i;if(e.length===1)return _g({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const s=e[0].shape,o=e[0].dtype;e.forEach(u=>{Rr(s,u.shape,"All tensors passed to stack must have matching shapes"),G(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=_g({inputs:{input:u},backend:t,attrs:{dim:r}});return a.push(h),h}),c=UC({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const M8={kernelName:Bw,backendName:"webgl",kernelFunc:C8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A8{constructor(e,t,i){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const r=e.length,s=$t(r),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R8{constructor(e,t,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,y)=>m[0]+e[y]+m[1]);const r=e.length,s=$t(r),o=t.map(m=>m[0]).join(","),a=t.map((m,y)=>m[0]+e[y]).join(","),l=jn("rc",r),c=jn("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${u}) {`],f=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,y=r===1?2:4;m<y;m++)p+=`
        ${d[m]}
        if (${f}) {
          result[${m}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{paddings:s,constantValue:o}=i;if(we(r.shape)===0){const c=s.map((u,h)=>u[0]+r.shape[h]+u[1]);return Fu({backend:t,attrs:{shape:c,value:o,dtype:r.dtype}})}const a=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new R8(r.shape,s,o):new A8(r.shape,s,o),l=[[o]];return t.runWebGLProgram(a,[r],r.dtype,l)},I8={kernelName:zw,backendName:"webgl",kernelFunc:nM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P8=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,N8=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+$f+`
  return result;
`,L8=An({opSnippet:P8,packedOpSnippet:N8}),D8={kernelName:Uw,backendName:"webgl",kernelFunc:L8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k8(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=[],c=Mn(s,r.shape);let u=c;const h=tr(u,a);let d=r;h!=null&&(d=an({inputs:{x:r},backend:t,attrs:{perm:h}}),u=nr(u.length,a),l.push(d)),Pr("prod",u,a);let f;if(t.shouldExecuteOnCPU([d])){const p=t.texData.get(d.dataId).values,{outVals:m,outShape:y,outDtype:g}=U4(d.shape,d.dtype,p,u);f=t.makeTensorInfo(y,g,m)}else{const[p,m]=Xr(d.shape,u),y=we(m),g=Me({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}}),v=gy(r.dtype),_=ba(g,v,"prod",t);f=Me({inputs:{x:_},backend:t,attrs:{shape:p}}),l.push(g),l.push(_)}if(o){l.push(f);const p=er(f.shape,c);f=Me({inputs:{x:f},backend:t,attrs:{shape:p}})}return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),f}const O8={kernelName:Gw,backendName:"webgl",kernelFunc:k8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iM=n=>{const{backend:e,attrs:t}=n,{start:i,stop:r,step:s,dtype:o}=t,a=V4(i,r,s,o);return e.makeTensorInfo([a.length],o,a)},F8={kernelName:Hw,backendName:"webgl",kernelFunc:iM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $8="return 1.0 / x;",B8=gt({opSnippet:$8}),z8={kernelName:jw,backendName:"webgl",kernelFunc:B8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U8=rr+`
  return (x < 0.0) ? 0.0 : x;
`,V8=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,G8=gt({opSnippet:U8,packedOpSnippet:V8}),H8={kernelName:qw,backendName:"webgl",kernelFunc:G8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W8=rr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,j8=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,q8=gt({opSnippet:W8,packedOpSnippet:j8}),X8={kernelName:Zw,backendName:"webgl",kernelFunc:q8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y8{constructor(e,t,i,r,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,i,c];const u=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i];let d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K8{constructor(e,t,i,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,i,c];const u=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i];let d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${i-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(n){const{inputs:e,backend:t,attrs:i}=n,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new K8(r.shape,l,c,s,o):new Y8(r.shape,l,c,s,o);return t.runWebGLProgram(u,[r],"float32")}const J8={kernelName:Kw,backendName:"webgl",kernelFunc:Z8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q8{constructor(e,t,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,a]=e,l=[i&&o>1?r-1:r,i&&a>1?s-1:s],c=[i&&o>1?o-1:o,i&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,f=1/h,p=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ej(n){const{inputs:e,backend:t,attrs:i}=n,{images:r,dy:s}=e,{alignCorners:o}=i,a=new Q8(s.shape,r.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const tj={kernelName:VI,backendName:"webgl",kernelFunc:ej};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nj{constructor(e,t,i,r,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,i,c];const u=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i],d=r?"0.5":"0.0";let f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ij{constructor(e,t,i,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,i,c];const u=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i],d=r?"0.5":"0.0";let f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${i-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rj(n){const{inputs:e,backend:t,attrs:i}=n,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ij(r.shape,l,c,s,o):new nj(r.shape,l,c,s,o);return t.runWebGLProgram(u,[r],r.dtype)}const sj={kernelName:Yw,backendName:"webgl",kernelFunc:rj};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oj{constructor(e,t,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,a]=e,l=[i&&o>1?r-1:r,i&&a>1?s-1:s],c=[i&&o>1?o-1:o,i&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,f=1/h,p=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${i} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${i} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(n){const{inputs:e,backend:t,attrs:i}=n,{images:r,dy:s}=e,{alignCorners:o}=i,a=new oj(s.shape,r.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const lj={kernelName:UI,backendName:"webgl",kernelFunc:aj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cj{constructor(e,t){this.variableNames=["x"];const i=e.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);if(this.outputShape=e,i===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,l)=>r(l)).join(","),o=$t(i);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uj{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const i=e.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);this.outputShape=e;const r=jn("rc",i),s=`${r[i-1]} + 1 < ${this.outputShape[i-1]}`,o=`${r[i-2]} + 1 < ${this.outputShape[i-2]}`,a=$t(i);i===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${s}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${u(r.slice())};
            if(${s}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return d(p)}function c(p){return p[i-1]="("+p[i-1]+" + 1)",d(p)}function u(p){return p[i-2]="("+p[i-2]+" + 1)",d(p)}function h(p){return p[i-1]="("+p[i-1]+" + 1)",p[i-2]="("+p[i-2]+" + 1)",d(p)}function d(p){const m=e.map((v,_)=>f(_,p)),y=m.join(","),g=m.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${g}))`}function f(p,m){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${m[p]} - 1`:`${m[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hj(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{dims:s}=i,o=r.shape.length,a=Mn(s,r.shape);if(o===0)return pi({inputs:{x:r},backend:t});const l=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uj(r.shape,a):new cj(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const dj={kernelName:Jw,backendName:"webgl",kernelFunc:hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fj{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const i=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${i}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pj={kernelName:kS,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:i}=n,{radians:r,fillValue:s,center:o}=e,a=t,l=new fj(i.shape,s),[c,u]=dE(o,i.shape[1],i.shape[2]),h=[[c,u,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[i],i.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mj=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,gj=gt({opSnippet:mj}),yj={kernelName:Qw,backendName:"webgl",kernelFunc:gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vj="return inversesqrt(x);",xj=gt({opSnippet:vj,cpuKernelImpl:G4}),_j={kernelName:eS,backendName:"webgl",kernelFunc:xj};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rM{constructor(e,t,i,r,s,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=$t(s.length),c=$t(o.length);let u="";i===1?u="i":i===2&&(u="i, j");const h=`getIndices(${u})`;let d="";r===1?d="i":r===2&&(d="i, coords[1]");const f=`getUpdates(${d})`,p=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${p};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bj(n){const{inputs:e,backend:t,attrs:i}=n,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=_y(s,r,o),d=[h/c,c];if(h===0)return t.makeTensorInfo(o,r.dtype);const f=Me({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),p=Me({inputs:{x:s},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new rM(l,a,f.shape.length,p.shape.length,u,d),g=t.runWebGLProgram(y,[p,f,m],p.dtype),v=Me({inputs:{x:g},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),v}const wj={kernelName:tS,backendName:"webgl",kernelFunc:bj};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sj{constructor(e,t,i,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,i];const s="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=ne().getNumber("WEBGL_VERSION")===2?s:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(n){const{inputs:e,backend:t,attrs:i}=n,{sortedSequence:r,values:s}=e,{side:o}=i,a=new Sj(r.shape[0],r.shape[1],s.shape[1],o),l=[[r.shape[1]]];return t.runWebGLProgram(a,[r,s],"int32",l)}const Ej={kernelName:nS,backendName:"webgl",kernelFunc:Tj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cj{constructor(e,t,i){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(i>4)throw Error(`Where for rank ${i} is not yet supported`);if(i===1)s="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);r=l.join(),s=c.join()}const o=$t(i);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mj(n){const{inputs:e,backend:t}=n,{condition:i,t:r,e:s}=e,o=new Cj(i.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[i,r,s],Ur(r.dtype,s.dtype))}const Aj={kernelName:iS,backendName:"webgl",kernelFunc:Mj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rj=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${mE};
  float scale = ${gE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Ij=gt({opSnippet:Rj}),Pj={kernelName:rS,backendName:"webgl",kernelFunc:Ij};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nj=Wl+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Lj=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dj=gt({opSnippet:Nj,packedOpSnippet:Lj,cpuKernelImpl:W4}),kj={kernelName:cS,backendName:"webgl",kernelFunc:Dj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oj=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Fj=gt({opSnippet:Oj}),$j={kernelName:lS,backendName:"webgl",kernelFunc:Fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bj=Wl+`
  return sin(x);
`,zj=gt({opSnippet:Bj}),Uj={kernelName:oS,backendName:"webgl",kernelFunc:zj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vj=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Gj=gt({opSnippet:Vj}),Hj={kernelName:aS,backendName:"webgl",kernelFunc:Gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wj=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,jj=gt({opSnippet:Wj}),qj={kernelName:uS,backendName:"webgl",kernelFunc:jj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xj=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockShape:s,paddings:o}=i;G(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((g,v)=>g*v),l=[[0,0]];l.push(...o);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);const c=[],u=nM({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=ky(u.shape,s,a,!1),d=Oy(h.length,s.length,!1),f=Fy(u.shape,s,a,!1),p=Me({inputs:{x:u},backend:t,attrs:{shape:h}}),m=an({inputs:{x:p},backend:t,attrs:{perm:d}}),y=Me({inputs:{x:m},backend:t,attrs:{shape:f}});return c.push(u),c.push(p),c.push(m),c.forEach(g=>t.disposeIntermediateTensorInfo(g)),y},Yj={kernelName:fS,backendName:"webgl",kernelFunc:Xj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kj(n){const{inputs:e,backend:t}=n,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(r.dataId),c=t.readSync(s.dataId),u=t.readSync(o.dataId)[0],[h,d,f,p,m]=q4(a,i.shape,i.dtype,l,r.dtype,c,u);return[t.makeTensorInfo(d,i.dtype,h),t.makeTensorInfo([d[0]],r.dtype,f),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(y=>Number(y)))),t.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}const Zj={kernelName:gS,backendName:"webgl",kernelFunc:Kj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jj(n){const{inputs:e,backend:t}=n,{inputIndices:i,inputShape:r,newShape:s}=e;if(i.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(t.readSync(r.dataId)),a=t.readSync(i.dataId),l=Array.from(t.readSync(s.dataId)),[c,u,h]=X4(a,i.shape,i.dtype,o,l);return[t.makeTensorInfo(u,i.dtype,c),t.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const Qj={kernelName:yS,backendName:"webgl",kernelFunc:Jj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eq(n){const{inputs:e,backend:t}=n,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const o=t.readSync(i.dataId),a=t.readSync(r.dataId),l=t.readSync(s.dataId),[c,u]=MC(o,i.shape,i.dtype,a,l,!0);return t.makeTensorInfo(u,i.dtype,c)}const tq={kernelName:vS,backendName:"webgl",kernelFunc:eq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nq(n){const{inputs:e,backend:t}=n,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const o=t.readSync(i.dataId),a=t.readSync(r.dataId),l=t.readSync(s.dataId),[c,u]=MC(o,i.shape,i.dtype,a,l);return t.makeTensorInfo(u,i.dtype,c)}const iq={kernelName:xS,backendName:"webgl",kernelFunc:nq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rq(n){const{inputs:e,backend:t,attrs:i}=n,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=_y(s,r,a),f=!1;if(s.dtype==="string"){const g=t.bufferSync(r),v=t.bufferSync(s),_=gl(t.readSync(o.dataId)[0]),b=H4(g,v,a,d,u,c,l,h,_,f);return t.makeTensorInfo(a,b.dtype,b.values)}const p=new rM(c,l,r.shape.length,s.shape.length,h,[d,1],f),m=t.runWebGLProgram(p,[s,r,o],s.dtype),y=Me({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),y}const sq={kernelName:_S,backendName:"webgl",kernelFunc:rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oq(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{numOrSizeSplits:s,axis:o}=i,a=Mn(o,r.shape)[0],l=AE(r,s,a),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map(d=>{const f=[...h];f[a]=d;const p=jl({inputs:{x:r},backend:t,attrs:{begin:u,size:f}});return u[a]+=d,p})}const aq={kernelName:pS,backendName:"webgl",kernelFunc:oq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bx="return sqrt(x);",lq=gt({opSnippet:Bx,packedOpSnippet:Bx,cpuKernelImpl:Y4}),cq={kernelName:hS,backendName:"webgl",kernelFunc:lq};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uq="return x * x;",hq=gt({opSnippet:uq}),dq={kernelName:GI,backendName:"webgl",kernelFunc:hq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zx="return (a - b) * (a - b);",fq=An({opSnippet:zx,packedOpSnippet:zx}),pq={kernelName:bS,backendName:"webgl",kernelFunc:fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mq({inputs:n,attrs:e,backend:t}){const{x:i}=n,r=rr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new us(i.shape,r);return t.runWebGLProgram(s,[i],i.dtype)}const gq={kernelName:DS,backendName:"webgl",kernelFunc:mq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yq{constructor(e,t,i){this.variableNames=["x"],this.outputShape=i;const r=i.length,s=$t(i.length),o=$t(i.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=i.map((c,u)=>(l++,i.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=i,{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:v,end:_,strides:b}=ST(r.shape,s,o,a,l,c,u,h,d);let S;if(m)S=Me({inputs:{x:r},backend:t,attrs:{shape:p}});else if(y||g){G(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const T=fT(v,_,b),R=jl({inputs:{x:r},backend:t,attrs:{begin:v,size:T}});S=Me({inputs:{x:R},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(R)}else if(t.shouldExecuteOnCPU([r])){const R=t.readSync(r.dataId),M=cn(r.shape,r.dtype,R),P=K4(f,M,b,v);S=t.makeTensorInfo(p,r.dtype,P.values)}else{const R=new yq(v,b,f);S=t.runWebGLProgram(R,[r],r.dtype)}const w=Me({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(S),w}const xq={kernelName:wS,backendName:"webgl",kernelFunc:vq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _q(n){const{inputs:e,backend:t,attrs:i}=n,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:u,dataSplits:h}=e,d=t.readSync(u.dataId),f=t.readSync(h.dataId),[p,m]=Z4(d,f,r,s,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const bq={kernelName:SS,backendName:"webgl",kernelFunc:_q};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wq(n){const{inputs:e,backend:t,attrs:i}=n,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=J4(a,l,r),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const Sq={kernelName:TS,backendName:"webgl",kernelFunc:wq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tq(n){const{inputs:e,backend:t,attrs:i}=n,{numBuckets:r}=i,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(s.dataId),a=Q4(o,r);return t.makeTensorInfo(s.shape,"int32",a)}const Eq={kernelName:ES,backendName:"webgl",kernelFunc:Tq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cq="return tan(x);",Mq=gt({opSnippet:Cq}),Aq={kernelName:MS,backendName:"webgl",kernelFunc:Mq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rq=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Iq=gt({opSnippet:Rq}),Pq={kernelName:AS,backendName:"webgl",kernelFunc:Iq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nq{constructor(e,t){this.variableNames=["A"];const i=new Array(e.length);for(let o=0;o<i.length;o++)i[o]=e[o]*t[o];this.outputShape=i,this.rank=i.length;const r=$t(this.rank),s=Lq(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function Lq(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],i=[];for(let r=0;r<n.length;r++)i.push(`imod(${t[r]}, ${n[r]})`);return i.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{reps:s}=i;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),c=r.dtype==="string"?l.map(d=>gl(d)):l,u=cn(r.shape,r.dtype,c),h=tV(u,s);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new Nq(r.shape,s);return t.runWebGLProgram(o,[r],r.dtype)}const Dq={kernelName:fy,backendName:"webgl",kernelFunc:sM};class kq{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Oq{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xo(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Ux(n){let e=1;for(;e<n;)e*=2;return e}function Fq(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{k:s,sorted:o}=i,a=ne().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ne().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([r])||u<a||s>l){const P=t.readSync(r.dataId),[L,$]=nV(P,c,r.dtype,s,o);return[t.makeTensorInfo(L.shape,L.dtype,L.values),t.makeTensorInfo($.shape,$.dtype,$.values)]}if(s===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[r,Fu({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),d=h!==null&&h.isPacked,f=d?t.unpackTensor(r):r,m=we(c)/u,y=Me({inputs:{x:f},attrs:{shape:[m,u]},backend:t});d&&xo(t,f);const g=Ux(s),v=Ux(u);let _=null;const b=()=>_===null?[y,y]:[y,_],S=(P,L,$)=>{const O=b(),I=new kq($),V=[[u],[_===null?1:0],[Number.NEGATIVE_INFINITY],[P],[L]],X=_;_=t.runWebGLProgram(I,O,"int32",V),xo(t,X)};for(let P=1;P<g;P*=2){const L=P*2;for(let $=P;$>=1;$/=2)S(L,$,[m,v])}for(let P=v;P>g;P/=2){const L=b(),$=new Oq([m,P/2]),I=[[u],[_===null?1:0],[g]],N=_;_=t.runWebGLProgram($,L,"int32",I),xo(t,N);const V=g/2,X=V*2;for(let J=V;J>=1;J/=2)S(X,J,_.shape)}let w=_;_=jl({inputs:{x:_},backend:t,attrs:{begin:0,size:[m,s]}}),xo(t,w);let T=KC({inputs:{x:y,indices:_},backend:t,attrs:{axis:1,batchDims:1}});xo(t,y);const R=c.slice(0,-1);R.push(s),w=_,_=Me({inputs:{x:_},attrs:{shape:R},backend:t}),xo(t,w);const M=T;return T=Me({inputs:{x:T},attrs:{shape:R},backend:t}),xo(t,M),[T,_]}const $q={kernelName:RS,backendName:"webgl",kernelFunc:Fq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bq{constructor(e,t,i,r,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=i==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(n){const{inputs:e,backend:t,attrs:i}=n,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=i,[u,h,d,f]=r.shape,[p,m]=c!=null?c:[h,d],y=[u,p,m,f],g=new Bq(h,d,o,a,l,y);return t.runWebGLProgram(g,[r,s],"float32")}const Uq={kernelName:IS,backendName:"webgl",kernelFunc:zq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vq(n){const{inputs:e,attrs:t,backend:i}=n,{axis:r}=t,{x:s}=e;Lu(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=i.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=iV(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}const Gq={kernelName:PS,backendName:"webgl",kernelFunc:Vq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hq(n){const{inputs:e,backend:t,attrs:i}=n,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[s],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==s&&(c[u++]=o.shape[m]);const h=[],d=new Array(a).fill(0),f=o.shape.slice();f[s]=1;const p=new Array(l);for(let m=0;m<p.length;m++){d[s]=m;const y=jl({inputs:{x:o},backend:t,attrs:{begin:d,size:f}}),g=Me({inputs:{x:y},backend:t,attrs:{shape:c}});p[m]=g,h.push(y)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const Wq={kernelName:NS,backendName:"webgl",kernelFunc:Hq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jq{constructor(e,t){this.variableNames=["x","segmentIds"];const i=e.windowSize,r=e.batchSize,s=e.inSize,o=e.numSegments,a=o*Math.ceil(s/i);this.outputShape=[r,a];const l="0.0",c="sumValue",u=Math.floor(i/4)*4,h=i%4,d=`
        sumValue += dot(values, segFilter);
    `;let f="";s%i>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%i>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${i}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qq(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,segmentIds:s}=e,{numSegments:o}=i,a=r.shape.length,l=[];let c=0;const u=tr([c],a);let h=r;u!=null&&(h=an({inputs:{x:r},backend:t,attrs:{perm:u}}),l.push(h),c=nr(1,a)[0]);const d=UE(h.shape,c,o),f=we([h.shape[c]]),p=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}});l.push(p);const m=gy(r.dtype),y=(b,S,w,T,R)=>{const M=b.shape[0],P=b.shape[1],L=zE(P,R),$={windowSize:L,inSize:P,batchSize:M,numSegments:R},O=new jq($,S),I=t.compileAndRun(O,[b,w],T);if(l.push(I),I.shape[1]===R)return I;const N=iM({backend:t,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),V=sM({inputs:{x:N},backend:t,attrs:{reps:[P/L]}});return l.push(N),l.push(V),y(I,S,V,T,R)},g=y(p,"unsortedSegmentSum",s,m,o),v=Me({inputs:{x:g},backend:t,attrs:{shape:d}});let _=v;if(u!=null){l.push(v);const b=My(u);_=an({inputs:{x:_},backend:t,attrs:{perm:b}})}return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),_}const Xq={kernelName:HI,backendName:"webgl",kernelFunc:qq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yq=[KV,JV,tG,rG,oG,cG,hG,fG,yG,xG,wG,EG,AG,NG,kG,FG,BG,GG,WG,qG,ZG,rH,oH,lH,pH,gH,_H,PV,SH,AH,NH,$H,zH,VH,HH,jH,YH,JH,tW,iW,sW,aW,uW,dW,gW,vW,bW,TW,CW,IW,DW,$W,UW,HW,WW,qW,YW,ZW,QW,t5,s5,l5,h5,f5,g5,x5,S5,M5,IV,R5,CH,N5,k5,$5,LV,V5,j5,X5,J5,t6,s6,l6,d6,g6,x6,b6,E6,M6,R6,L6,k6,F6,B6,U6,W6,Y6,Q6,a8,$V,h8,p8,y8,_8,uH,S8,E8,M8,I8,D8,kV,O8,F8,hH,i8,z8,H8,X8,zV,J8,tj,sj,lj,dj,pj,yj,_j,wj,Ej,Aj,Pj,kj,$j,Uj,Hj,nH,s8,qj,Yj,Zj,Qj,tq,iq,sq,aq,cq,dq,pq,gq,xq,bq,Sq,Eq,r8,qV,Aq,Pq,Dq,$q,Uq,XV,Gq,Wq,Xq,T8];for(const n of Yq)qI(n);let oM=!0,aM=!0;function hd(n,e,t){const i=n.match(e);return i&&i.length>=t&&parseInt(i[t],10)}function ql(n,e,t){if(!n.RTCPeerConnection)return;const i=n.RTCPeerConnection.prototype,r=i.addEventListener;i.addEventListener=function(o,a){if(o!==e)return r.apply(this,arguments);const l=c=>{const u=t(c);u&&(a.handleEvent?a.handleEvent(u):a(u))};return this._eventMap=this._eventMap||{},this._eventMap[e]||(this._eventMap[e]=new Map),this._eventMap[e].set(a,l),r.apply(this,[o,l])};const s=i.removeEventListener;i.removeEventListener=function(o,a){if(o!==e||!this._eventMap||!this._eventMap[e])return s.apply(this,arguments);if(!this._eventMap[e].has(a))return s.apply(this,arguments);const l=this._eventMap[e].get(a);return this._eventMap[e].delete(a),this._eventMap[e].size===0&&delete this._eventMap[e],Object.keys(this._eventMap).length===0&&delete this._eventMap,s.apply(this,[o,l])},Object.defineProperty(i,"on"+e,{get(){return this["_on"+e]},set(o){this["_on"+e]&&(this.removeEventListener(e,this["_on"+e]),delete this["_on"+e]),o&&this.addEventListener(e,this["_on"+e]=o)},enumerable:!0,configurable:!0})}function Kq(n){return typeof n!="boolean"?new Error("Argument type: "+typeof n+". Please use a boolean."):(oM=n,n?"adapter.js logging disabled":"adapter.js logging enabled")}function Zq(n){return typeof n!="boolean"?new Error("Argument type: "+typeof n+". Please use a boolean."):(aM=!n,"adapter.js deprecation warnings "+(n?"disabled":"enabled"))}function lM(){if(typeof window=="object"){if(oM)return;typeof console!="undefined"&&typeof console.log=="function"&&console.log.apply(console,arguments)}}function qy(n,e){!aM||console.warn(n+" is deprecated, please use "+e+" instead.")}function Jq(n){const e={browser:null,version:null};if(typeof n=="undefined"||!n.navigator)return e.browser="Not a browser.",e;const{navigator:t}=n;if(t.mozGetUserMedia)e.browser="firefox",e.version=hd(t.userAgent,/Firefox\/(\d+)\./,1);else if(t.webkitGetUserMedia||n.isSecureContext===!1&&n.webkitRTCPeerConnection&&!n.RTCIceGatherer)e.browser="chrome",e.version=hd(t.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else if(n.RTCPeerConnection&&t.userAgent.match(/AppleWebKit\/(\d+)\./))e.browser="safari",e.version=hd(t.userAgent,/AppleWebKit\/(\d+)\./,1),e.supportsUnifiedPlan=n.RTCRtpTransceiver&&"currentDirection"in n.RTCRtpTransceiver.prototype;else return e.browser="Not a supported browser.",e;return e}function Vx(n){return Object.prototype.toString.call(n)==="[object Object]"}function cM(n){return Vx(n)?Object.keys(n).reduce(function(e,t){const i=Vx(n[t]),r=i?cM(n[t]):n[t],s=i&&!Object.keys(r).length;return r===void 0||s?e:Object.assign(e,{[t]:r})},{}):n}function bg(n,e,t){!e||t.has(e.id)||(t.set(e.id,e),Object.keys(e).forEach(i=>{i.endsWith("Id")?bg(n,n.get(e[i]),t):i.endsWith("Ids")&&e[i].forEach(r=>{bg(n,n.get(r),t)})}))}function Gx(n,e,t){const i=t?"outbound-rtp":"inbound-rtp",r=new Map;if(e===null)return r;const s=[];return n.forEach(o=>{o.type==="track"&&o.trackIdentifier===e.id&&s.push(o)}),s.forEach(o=>{n.forEach(a=>{a.type===i&&a.trackId===o.id&&bg(n,a,r)})}),r}const Hx=lM;function uM(n,e){const t=n&&n.navigator;if(!t.mediaDevices)return;const i=function(a){if(typeof a!="object"||a.mandatory||a.optional)return a;const l={};return Object.keys(a).forEach(c=>{if(c==="require"||c==="advanced"||c==="mediaSource")return;const u=typeof a[c]=="object"?a[c]:{ideal:a[c]};u.exact!==void 0&&typeof u.exact=="number"&&(u.min=u.max=u.exact);const h=function(d,f){return d?d+f.charAt(0).toUpperCase()+f.slice(1):f==="deviceId"?"sourceId":f};if(u.ideal!==void 0){l.optional=l.optional||[];let d={};typeof u.ideal=="number"?(d[h("min",c)]=u.ideal,l.optional.push(d),d={},d[h("max",c)]=u.ideal,l.optional.push(d)):(d[h("",c)]=u.ideal,l.optional.push(d))}u.exact!==void 0&&typeof u.exact!="number"?(l.mandatory=l.mandatory||{},l.mandatory[h("",c)]=u.exact):["min","max"].forEach(d=>{u[d]!==void 0&&(l.mandatory=l.mandatory||{},l.mandatory[h(d,c)]=u[d])})}),a.advanced&&(l.optional=(l.optional||[]).concat(a.advanced)),l},r=function(a,l){if(e.version>=61)return l(a);if(a=JSON.parse(JSON.stringify(a)),a&&typeof a.audio=="object"){const c=function(u,h,d){h in u&&!(d in u)&&(u[d]=u[h],delete u[h])};a=JSON.parse(JSON.stringify(a)),c(a.audio,"autoGainControl","googAutoGainControl"),c(a.audio,"noiseSuppression","googNoiseSuppression"),a.audio=i(a.audio)}if(a&&typeof a.video=="object"){let c=a.video.facingMode;c=c&&(typeof c=="object"?c:{ideal:c});const u=e.version<66;if(c&&(c.exact==="user"||c.exact==="environment"||c.ideal==="user"||c.ideal==="environment")&&!(t.mediaDevices.getSupportedConstraints&&t.mediaDevices.getSupportedConstraints().facingMode&&!u)){delete a.video.facingMode;let h;if(c.exact==="environment"||c.ideal==="environment"?h=["back","rear"]:(c.exact==="user"||c.ideal==="user")&&(h=["front"]),h)return t.mediaDevices.enumerateDevices().then(d=>{d=d.filter(p=>p.kind==="videoinput");let f=d.find(p=>h.some(m=>p.label.toLowerCase().includes(m)));return!f&&d.length&&h.includes("back")&&(f=d[d.length-1]),f&&(a.video.deviceId=c.exact?{exact:f.deviceId}:{ideal:f.deviceId}),a.video=i(a.video),Hx("chrome: "+JSON.stringify(a)),l(a)})}a.video=i(a.video)}return Hx("chrome: "+JSON.stringify(a)),l(a)},s=function(a){return e.version>=64?a:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[a.name]||a.name,message:a.message,constraint:a.constraint||a.constraintName,toString(){return this.name+(this.message&&": ")+this.message}}},o=function(a,l,c){r(a,u=>{t.webkitGetUserMedia(u,l,h=>{c&&c(s(h))})})};if(t.getUserMedia=o.bind(t),t.mediaDevices.getUserMedia){const a=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(l){return r(l,c=>a(c).then(u=>{if(c.audio&&!u.getAudioTracks().length||c.video&&!u.getVideoTracks().length)throw u.getTracks().forEach(h=>{h.stop()}),new DOMException("","NotFoundError");return u},u=>Promise.reject(s(u))))}}}function Qq(n,e){if(!(n.navigator.mediaDevices&&"getDisplayMedia"in n.navigator.mediaDevices)&&!!n.navigator.mediaDevices){if(typeof e!="function"){console.error("shimGetDisplayMedia: getSourceId argument is not a function");return}n.navigator.mediaDevices.getDisplayMedia=function(i){return e(i).then(r=>{const s=i.video&&i.video.width,o=i.video&&i.video.height,a=i.video&&i.video.frameRate;return i.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:r,maxFrameRate:a||3}},s&&(i.video.mandatory.maxWidth=s),o&&(i.video.mandatory.maxHeight=o),n.navigator.mediaDevices.getUserMedia(i)})}}}function hM(n){n.MediaStream=n.MediaStream||n.webkitMediaStream}function dM(n){if(typeof n=="object"&&n.RTCPeerConnection&&!("ontrack"in n.RTCPeerConnection.prototype)){Object.defineProperty(n.RTCPeerConnection.prototype,"ontrack",{get(){return this._ontrack},set(t){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=t)},enumerable:!0,configurable:!0});const e=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(){return this._ontrackpoly||(this._ontrackpoly=i=>{i.stream.addEventListener("addtrack",r=>{let s;n.RTCPeerConnection.prototype.getReceivers?s=this.getReceivers().find(a=>a.track&&a.track.id===r.track.id):s={track:r.track};const o=new Event("track");o.track=r.track,o.receiver=s,o.transceiver={receiver:s},o.streams=[i.stream],this.dispatchEvent(o)}),i.stream.getTracks().forEach(r=>{let s;n.RTCPeerConnection.prototype.getReceivers?s=this.getReceivers().find(a=>a.track&&a.track.id===r.id):s={track:r};const o=new Event("track");o.track=r,o.receiver=s,o.transceiver={receiver:s},o.streams=[i.stream],this.dispatchEvent(o)})},this.addEventListener("addstream",this._ontrackpoly)),e.apply(this,arguments)}}else ql(n,"track",e=>(e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e))}function fM(n){if(typeof n=="object"&&n.RTCPeerConnection&&!("getSenders"in n.RTCPeerConnection.prototype)&&"createDTMFSender"in n.RTCPeerConnection.prototype){const e=function(r,s){return{track:s,get dtmf(){return this._dtmf===void 0&&(s.kind==="audio"?this._dtmf=r.createDTMFSender(s):this._dtmf=null),this._dtmf},_pc:r}};if(!n.RTCPeerConnection.prototype.getSenders){n.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};const r=n.RTCPeerConnection.prototype.addTrack;n.RTCPeerConnection.prototype.addTrack=function(a,l){let c=r.apply(this,arguments);return c||(c=e(this,a),this._senders.push(c)),c};const s=n.RTCPeerConnection.prototype.removeTrack;n.RTCPeerConnection.prototype.removeTrack=function(a){s.apply(this,arguments);const l=this._senders.indexOf(a);l!==-1&&this._senders.splice(l,1)}}const t=n.RTCPeerConnection.prototype.addStream;n.RTCPeerConnection.prototype.addStream=function(s){this._senders=this._senders||[],t.apply(this,[s]),s.getTracks().forEach(o=>{this._senders.push(e(this,o))})};const i=n.RTCPeerConnection.prototype.removeStream;n.RTCPeerConnection.prototype.removeStream=function(s){this._senders=this._senders||[],i.apply(this,[s]),s.getTracks().forEach(o=>{const a=this._senders.find(l=>l.track===o);a&&this._senders.splice(this._senders.indexOf(a),1)})}}else if(typeof n=="object"&&n.RTCPeerConnection&&"getSenders"in n.RTCPeerConnection.prototype&&"createDTMFSender"in n.RTCPeerConnection.prototype&&n.RTCRtpSender&&!("dtmf"in n.RTCRtpSender.prototype)){const e=n.RTCPeerConnection.prototype.getSenders;n.RTCPeerConnection.prototype.getSenders=function(){const i=e.apply(this,[]);return i.forEach(r=>r._pc=this),i},Object.defineProperty(n.RTCRtpSender.prototype,"dtmf",{get(){return this._dtmf===void 0&&(this.track.kind==="audio"?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}})}}function pM(n){if(!n.RTCPeerConnection)return;const e=n.RTCPeerConnection.prototype.getStats;n.RTCPeerConnection.prototype.getStats=function(){const[i,r,s]=arguments;if(arguments.length>0&&typeof i=="function")return e.apply(this,arguments);if(e.length===0&&(arguments.length===0||typeof i!="function"))return e.apply(this,[]);const o=function(l){const c={};return l.result().forEach(h=>{const d={id:h.id,timestamp:h.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[h.type]||h.type};h.names().forEach(f=>{d[f]=h.stat(f)}),c[d.id]=d}),c},a=function(l){return new Map(Object.keys(l).map(c=>[c,l[c]]))};if(arguments.length>=2){const l=function(c){r(a(o(c)))};return e.apply(this,[l,i])}return new Promise((l,c)=>{e.apply(this,[function(u){l(a(o(u)))},c])}).then(r,s)}}function mM(n){if(!(typeof n=="object"&&n.RTCPeerConnection&&n.RTCRtpSender&&n.RTCRtpReceiver))return;if(!("getStats"in n.RTCRtpSender.prototype)){const t=n.RTCPeerConnection.prototype.getSenders;t&&(n.RTCPeerConnection.prototype.getSenders=function(){const s=t.apply(this,[]);return s.forEach(o=>o._pc=this),s});const i=n.RTCPeerConnection.prototype.addTrack;i&&(n.RTCPeerConnection.prototype.addTrack=function(){const s=i.apply(this,arguments);return s._pc=this,s}),n.RTCRtpSender.prototype.getStats=function(){const s=this;return this._pc.getStats().then(o=>Gx(o,s.track,!0))}}if(!("getStats"in n.RTCRtpReceiver.prototype)){const t=n.RTCPeerConnection.prototype.getReceivers;t&&(n.RTCPeerConnection.prototype.getReceivers=function(){const r=t.apply(this,[]);return r.forEach(s=>s._pc=this),r}),ql(n,"track",i=>(i.receiver._pc=i.srcElement,i)),n.RTCRtpReceiver.prototype.getStats=function(){const r=this;return this._pc.getStats().then(s=>Gx(s,r.track,!1))}}if(!("getStats"in n.RTCRtpSender.prototype&&"getStats"in n.RTCRtpReceiver.prototype))return;const e=n.RTCPeerConnection.prototype.getStats;n.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof n.MediaStreamTrack){const i=arguments[0];let r,s,o;return this.getSenders().forEach(a=>{a.track===i&&(r?o=!0:r=a)}),this.getReceivers().forEach(a=>(a.track===i&&(s?o=!0:s=a),a.track===i)),o||r&&s?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):r?r.getStats():s?s.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}return e.apply(this,arguments)}}function gM(n){n.RTCPeerConnection.prototype.getLocalStreams=function(){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(o=>this._shimmedLocalStreams[o][0])};const e=n.RTCPeerConnection.prototype.addTrack;n.RTCPeerConnection.prototype.addTrack=function(o,a){if(!a)return e.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};const l=e.apply(this,arguments);return this._shimmedLocalStreams[a.id]?this._shimmedLocalStreams[a.id].indexOf(l)===-1&&this._shimmedLocalStreams[a.id].push(l):this._shimmedLocalStreams[a.id]=[a,l],l};const t=n.RTCPeerConnection.prototype.addStream;n.RTCPeerConnection.prototype.addStream=function(o){this._shimmedLocalStreams=this._shimmedLocalStreams||{},o.getTracks().forEach(c=>{if(this.getSenders().find(h=>h.track===c))throw new DOMException("Track already exists.","InvalidAccessError")});const a=this.getSenders();t.apply(this,arguments);const l=this.getSenders().filter(c=>a.indexOf(c)===-1);this._shimmedLocalStreams[o.id]=[o].concat(l)};const i=n.RTCPeerConnection.prototype.removeStream;n.RTCPeerConnection.prototype.removeStream=function(o){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[o.id],i.apply(this,arguments)};const r=n.RTCPeerConnection.prototype.removeTrack;n.RTCPeerConnection.prototype.removeTrack=function(o){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},o&&Object.keys(this._shimmedLocalStreams).forEach(a=>{const l=this._shimmedLocalStreams[a].indexOf(o);l!==-1&&this._shimmedLocalStreams[a].splice(l,1),this._shimmedLocalStreams[a].length===1&&delete this._shimmedLocalStreams[a]}),r.apply(this,arguments)}}function yM(n,e){if(!n.RTCPeerConnection)return;if(n.RTCPeerConnection.prototype.addTrack&&e.version>=65)return gM(n);const t=n.RTCPeerConnection.prototype.getLocalStreams;n.RTCPeerConnection.prototype.getLocalStreams=function(){const u=t.apply(this);return this._reverseStreams=this._reverseStreams||{},u.map(h=>this._reverseStreams[h.id])};const i=n.RTCPeerConnection.prototype.addStream;n.RTCPeerConnection.prototype.addStream=function(u){if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},u.getTracks().forEach(h=>{if(this.getSenders().find(f=>f.track===h))throw new DOMException("Track already exists.","InvalidAccessError")}),!this._reverseStreams[u.id]){const h=new n.MediaStream(u.getTracks());this._streams[u.id]=h,this._reverseStreams[h.id]=u,u=h}i.apply(this,[u])};const r=n.RTCPeerConnection.prototype.removeStream;n.RTCPeerConnection.prototype.removeStream=function(u){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},r.apply(this,[this._streams[u.id]||u]),delete this._reverseStreams[this._streams[u.id]?this._streams[u.id].id:u.id],delete this._streams[u.id]},n.RTCPeerConnection.prototype.addTrack=function(u,h){if(this.signalingState==="closed")throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");const d=[].slice.call(arguments,1);if(d.length!==1||!d[0].getTracks().find(m=>m===u))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");if(this.getSenders().find(m=>m.track===u))throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};const p=this._streams[h.id];if(p)p.addTrack(u),Promise.resolve().then(()=>{this.dispatchEvent(new Event("negotiationneeded"))});else{const m=new n.MediaStream([u]);this._streams[h.id]=m,this._reverseStreams[m.id]=h,this.addStream(m)}return this.getSenders().find(m=>m.track===u)};function s(c,u){let h=u.sdp;return Object.keys(c._reverseStreams||[]).forEach(d=>{const f=c._reverseStreams[d],p=c._streams[f.id];h=h.replace(new RegExp(p.id,"g"),f.id)}),new RTCSessionDescription({type:u.type,sdp:h})}function o(c,u){let h=u.sdp;return Object.keys(c._reverseStreams||[]).forEach(d=>{const f=c._reverseStreams[d],p=c._streams[f.id];h=h.replace(new RegExp(f.id,"g"),p.id)}),new RTCSessionDescription({type:u.type,sdp:h})}["createOffer","createAnswer"].forEach(function(c){const u=n.RTCPeerConnection.prototype[c],h={[c](){const d=arguments;return arguments.length&&typeof arguments[0]=="function"?u.apply(this,[p=>{const m=s(this,p);d[0].apply(null,[m])},p=>{d[1]&&d[1].apply(null,p)},arguments[2]]):u.apply(this,arguments).then(p=>s(this,p))}};n.RTCPeerConnection.prototype[c]=h[c]});const a=n.RTCPeerConnection.prototype.setLocalDescription;n.RTCPeerConnection.prototype.setLocalDescription=function(){return!arguments.length||!arguments[0].type?a.apply(this,arguments):(arguments[0]=o(this,arguments[0]),a.apply(this,arguments))};const l=Object.getOwnPropertyDescriptor(n.RTCPeerConnection.prototype,"localDescription");Object.defineProperty(n.RTCPeerConnection.prototype,"localDescription",{get(){const c=l.get.apply(this);return c.type===""?c:s(this,c)}}),n.RTCPeerConnection.prototype.removeTrack=function(u){if(this.signalingState==="closed")throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!u._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(!(u._pc===this))throw new DOMException("Sender was not created by this connection.","InvalidAccessError");this._streams=this._streams||{};let d;Object.keys(this._streams).forEach(f=>{this._streams[f].getTracks().find(m=>u.track===m)&&(d=this._streams[f])}),d&&(d.getTracks().length===1?this.removeStream(this._reverseStreams[d.id]):d.removeTrack(u.track),this.dispatchEvent(new Event("negotiationneeded")))}}function wg(n,e){!n.RTCPeerConnection&&n.webkitRTCPeerConnection&&(n.RTCPeerConnection=n.webkitRTCPeerConnection),!!n.RTCPeerConnection&&e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(t){const i=n.RTCPeerConnection.prototype[t],r={[t](){return arguments[0]=new(t==="addIceCandidate"?n.RTCIceCandidate:n.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};n.RTCPeerConnection.prototype[t]=r[t]})}function vM(n,e){ql(n,"negotiationneeded",t=>{const i=t.target;if(!((e.version<72||i.getConfiguration&&i.getConfiguration().sdpSemantics==="plan-b")&&i.signalingState!=="stable"))return t})}var Wx=Object.freeze(Object.defineProperty({__proto__:null,shimMediaStream:hM,shimOnTrack:dM,shimGetSendersWithDtmf:fM,shimGetStats:pM,shimSenderReceiverGetStats:mM,shimAddTrackRemoveTrackWithNative:gM,shimAddTrackRemoveTrack:yM,shimPeerConnection:wg,fixNegotiationNeeded:vM,shimGetUserMedia:uM,shimGetDisplayMedia:Qq},Symbol.toStringTag,{value:"Module"}));function xM(n,e){const t=n&&n.navigator,i=n&&n.MediaStreamTrack;if(t.getUserMedia=function(r,s,o){qy("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),t.mediaDevices.getUserMedia(r).then(s,o)},!(e.version>55&&"autoGainControl"in t.mediaDevices.getSupportedConstraints())){const r=function(o,a,l){a in o&&!(l in o)&&(o[l]=o[a],delete o[a])},s=t.mediaDevices.getUserMedia.bind(t.mediaDevices);if(t.mediaDevices.getUserMedia=function(o){return typeof o=="object"&&typeof o.audio=="object"&&(o=JSON.parse(JSON.stringify(o)),r(o.audio,"autoGainControl","mozAutoGainControl"),r(o.audio,"noiseSuppression","mozNoiseSuppression")),s(o)},i&&i.prototype.getSettings){const o=i.prototype.getSettings;i.prototype.getSettings=function(){const a=o.apply(this,arguments);return r(a,"mozAutoGainControl","autoGainControl"),r(a,"mozNoiseSuppression","noiseSuppression"),a}}if(i&&i.prototype.applyConstraints){const o=i.prototype.applyConstraints;i.prototype.applyConstraints=function(a){return this.kind==="audio"&&typeof a=="object"&&(a=JSON.parse(JSON.stringify(a)),r(a,"autoGainControl","mozAutoGainControl"),r(a,"noiseSuppression","mozNoiseSuppression")),o.apply(this,[a])}}}}function eX(n,e){n.navigator.mediaDevices&&"getDisplayMedia"in n.navigator.mediaDevices||!n.navigator.mediaDevices||(n.navigator.mediaDevices.getDisplayMedia=function(i){if(!(i&&i.video)){const r=new DOMException("getDisplayMedia without video constraints is undefined");return r.name="NotFoundError",r.code=8,Promise.reject(r)}return i.video===!0?i.video={mediaSource:e}:i.video.mediaSource=e,n.navigator.mediaDevices.getUserMedia(i)})}function _M(n){typeof n=="object"&&n.RTCTrackEvent&&"receiver"in n.RTCTrackEvent.prototype&&!("transceiver"in n.RTCTrackEvent.prototype)&&Object.defineProperty(n.RTCTrackEvent.prototype,"transceiver",{get(){return{receiver:this.receiver}}})}function Sg(n,e){if(typeof n!="object"||!(n.RTCPeerConnection||n.mozRTCPeerConnection))return;!n.RTCPeerConnection&&n.mozRTCPeerConnection&&(n.RTCPeerConnection=n.mozRTCPeerConnection),e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(r){const s=n.RTCPeerConnection.prototype[r],o={[r](){return arguments[0]=new(r==="addIceCandidate"?n.RTCIceCandidate:n.RTCSessionDescription)(arguments[0]),s.apply(this,arguments)}};n.RTCPeerConnection.prototype[r]=o[r]});const t={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},i=n.RTCPeerConnection.prototype.getStats;n.RTCPeerConnection.prototype.getStats=function(){const[s,o,a]=arguments;return i.apply(this,[s||null]).then(l=>{if(e.version<53&&!o)try{l.forEach(c=>{c.type=t[c.type]||c.type})}catch(c){if(c.name!=="TypeError")throw c;l.forEach((u,h)=>{l.set(h,Object.assign({},u,{type:t[u.type]||u.type}))})}return l}).then(o,a)}}function bM(n){if(!(typeof n=="object"&&n.RTCPeerConnection&&n.RTCRtpSender)||n.RTCRtpSender&&"getStats"in n.RTCRtpSender.prototype)return;const e=n.RTCPeerConnection.prototype.getSenders;e&&(n.RTCPeerConnection.prototype.getSenders=function(){const r=e.apply(this,[]);return r.forEach(s=>s._pc=this),r});const t=n.RTCPeerConnection.prototype.addTrack;t&&(n.RTCPeerConnection.prototype.addTrack=function(){const r=t.apply(this,arguments);return r._pc=this,r}),n.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}}function wM(n){if(!(typeof n=="object"&&n.RTCPeerConnection&&n.RTCRtpSender)||n.RTCRtpSender&&"getStats"in n.RTCRtpReceiver.prototype)return;const e=n.RTCPeerConnection.prototype.getReceivers;e&&(n.RTCPeerConnection.prototype.getReceivers=function(){const i=e.apply(this,[]);return i.forEach(r=>r._pc=this),i}),ql(n,"track",t=>(t.receiver._pc=t.srcElement,t)),n.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}}function SM(n){!n.RTCPeerConnection||"removeStream"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.removeStream=function(t){qy("removeStream","removeTrack"),this.getSenders().forEach(i=>{i.track&&t.getTracks().includes(i.track)&&this.removeTrack(i)})})}function TM(n){n.DataChannel&&!n.RTCDataChannel&&(n.RTCDataChannel=n.DataChannel)}function EM(n){if(!(typeof n=="object"&&n.RTCPeerConnection))return;const e=n.RTCPeerConnection.prototype.addTransceiver;e&&(n.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];const i=arguments[1],r=i&&"sendEncodings"in i;r&&i.sendEncodings.forEach(o=>{if("rid"in o&&!/^[a-z0-9]{0,16}$/i.test(o.rid))throw new TypeError("Invalid RID value provided.");if("scaleResolutionDownBy"in o&&!(parseFloat(o.scaleResolutionDownBy)>=1))throw new RangeError("scale_resolution_down_by must be >= 1.0");if("maxFramerate"in o&&!(parseFloat(o.maxFramerate)>=0))throw new RangeError("max_framerate must be >= 0.0")});const s=e.apply(this,arguments);if(r){const{sender:o}=s,a=o.getParameters();(!("encodings"in a)||a.encodings.length===1&&Object.keys(a.encodings[0]).length===0)&&(a.encodings=i.sendEncodings,o.sendEncodings=i.sendEncodings,this.setParametersPromises.push(o.setParameters(a).then(()=>{delete o.sendEncodings}).catch(()=>{delete o.sendEncodings})))}return s})}function CM(n){if(!(typeof n=="object"&&n.RTCRtpSender))return;const e=n.RTCRtpSender.prototype.getParameters;e&&(n.RTCRtpSender.prototype.getParameters=function(){const i=e.apply(this,arguments);return"encodings"in i||(i.encodings=[].concat(this.sendEncodings||[{}])),i})}function MM(n){if(!(typeof n=="object"&&n.RTCPeerConnection))return;const e=n.RTCPeerConnection.prototype.createOffer;n.RTCPeerConnection.prototype.createOffer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(()=>e.apply(this,arguments)).finally(()=>{this.setParametersPromises=[]}):e.apply(this,arguments)}}function AM(n){if(!(typeof n=="object"&&n.RTCPeerConnection))return;const e=n.RTCPeerConnection.prototype.createAnswer;n.RTCPeerConnection.prototype.createAnswer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(()=>e.apply(this,arguments)).finally(()=>{this.setParametersPromises=[]}):e.apply(this,arguments)}}var jx=Object.freeze(Object.defineProperty({__proto__:null,shimOnTrack:_M,shimPeerConnection:Sg,shimSenderGetStats:bM,shimReceiverGetStats:wM,shimRemoveStream:SM,shimRTCDataChannel:TM,shimAddTransceiver:EM,shimGetParameters:CM,shimCreateOffer:MM,shimCreateAnswer:AM,shimGetUserMedia:xM,shimGetDisplayMedia:eX},Symbol.toStringTag,{value:"Module"}));function RM(n){if(!(typeof n!="object"||!n.RTCPeerConnection)){if("getLocalStreams"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!("addStream"in n.RTCPeerConnection.prototype)){const e=n.RTCPeerConnection.prototype.addTrack;n.RTCPeerConnection.prototype.addStream=function(i){this._localStreams||(this._localStreams=[]),this._localStreams.includes(i)||this._localStreams.push(i),i.getAudioTracks().forEach(r=>e.call(this,r,i)),i.getVideoTracks().forEach(r=>e.call(this,r,i))},n.RTCPeerConnection.prototype.addTrack=function(i,...r){return r&&r.forEach(s=>{this._localStreams?this._localStreams.includes(s)||this._localStreams.push(s):this._localStreams=[s]}),e.apply(this,arguments)}}"removeStream"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.removeStream=function(t){this._localStreams||(this._localStreams=[]);const i=this._localStreams.indexOf(t);if(i===-1)return;this._localStreams.splice(i,1);const r=t.getTracks();this.getSenders().forEach(s=>{r.includes(s.track)&&this.removeTrack(s)})})}}function IM(n){if(!(typeof n!="object"||!n.RTCPeerConnection)&&("getRemoteStreams"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!("onaddstream"in n.RTCPeerConnection.prototype))){Object.defineProperty(n.RTCPeerConnection.prototype,"onaddstream",{get(){return this._onaddstream},set(t){this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=t),this.addEventListener("track",this._onaddstreampoly=i=>{i.streams.forEach(r=>{if(this._remoteStreams||(this._remoteStreams=[]),this._remoteStreams.includes(r))return;this._remoteStreams.push(r);const s=new Event("addstream");s.stream=r,this.dispatchEvent(s)})})}});const e=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(){const i=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(r){r.streams.forEach(s=>{if(i._remoteStreams||(i._remoteStreams=[]),i._remoteStreams.indexOf(s)>=0)return;i._remoteStreams.push(s);const o=new Event("addstream");o.stream=s,i.dispatchEvent(o)})}),e.apply(i,arguments)}}}function PM(n){if(typeof n!="object"||!n.RTCPeerConnection)return;const e=n.RTCPeerConnection.prototype,t=e.createOffer,i=e.createAnswer,r=e.setLocalDescription,s=e.setRemoteDescription,o=e.addIceCandidate;e.createOffer=function(c,u){const h=arguments.length>=2?arguments[2]:arguments[0],d=t.apply(this,[h]);return u?(d.then(c,u),Promise.resolve()):d},e.createAnswer=function(c,u){const h=arguments.length>=2?arguments[2]:arguments[0],d=i.apply(this,[h]);return u?(d.then(c,u),Promise.resolve()):d};let a=function(l,c,u){const h=r.apply(this,[l]);return u?(h.then(c,u),Promise.resolve()):h};e.setLocalDescription=a,a=function(l,c,u){const h=s.apply(this,[l]);return u?(h.then(c,u),Promise.resolve()):h},e.setRemoteDescription=a,a=function(l,c,u){const h=o.apply(this,[l]);return u?(h.then(c,u),Promise.resolve()):h},e.addIceCandidate=a}function NM(n){const e=n&&n.navigator;if(e.mediaDevices&&e.mediaDevices.getUserMedia){const t=e.mediaDevices,i=t.getUserMedia.bind(t);e.mediaDevices.getUserMedia=r=>i(LM(r))}!e.getUserMedia&&e.mediaDevices&&e.mediaDevices.getUserMedia&&(e.getUserMedia=function(i,r,s){e.mediaDevices.getUserMedia(i).then(r,s)}.bind(e))}function LM(n){return n&&n.video!==void 0?Object.assign({},n,{video:cM(n.video)}):n}function DM(n){if(!n.RTCPeerConnection)return;const e=n.RTCPeerConnection;n.RTCPeerConnection=function(i,r){if(i&&i.iceServers){const s=[];for(let o=0;o<i.iceServers.length;o++){let a=i.iceServers[o];!a.hasOwnProperty("urls")&&a.hasOwnProperty("url")?(qy("RTCIceServer.url","RTCIceServer.urls"),a=JSON.parse(JSON.stringify(a)),a.urls=a.url,delete a.url,s.push(a)):s.push(i.iceServers[o])}i.iceServers=s}return new e(i,r)},n.RTCPeerConnection.prototype=e.prototype,"generateCertificate"in e&&Object.defineProperty(n.RTCPeerConnection,"generateCertificate",{get(){return e.generateCertificate}})}function kM(n){typeof n=="object"&&n.RTCTrackEvent&&"receiver"in n.RTCTrackEvent.prototype&&!("transceiver"in n.RTCTrackEvent.prototype)&&Object.defineProperty(n.RTCTrackEvent.prototype,"transceiver",{get(){return{receiver:this.receiver}}})}function OM(n){const e=n.RTCPeerConnection.prototype.createOffer;n.RTCPeerConnection.prototype.createOffer=function(i){if(i){typeof i.offerToReceiveAudio!="undefined"&&(i.offerToReceiveAudio=!!i.offerToReceiveAudio);const r=this.getTransceivers().find(o=>o.receiver.track.kind==="audio");i.offerToReceiveAudio===!1&&r?r.direction==="sendrecv"?r.setDirection?r.setDirection("sendonly"):r.direction="sendonly":r.direction==="recvonly"&&(r.setDirection?r.setDirection("inactive"):r.direction="inactive"):i.offerToReceiveAudio===!0&&!r&&this.addTransceiver("audio",{direction:"recvonly"}),typeof i.offerToReceiveVideo!="undefined"&&(i.offerToReceiveVideo=!!i.offerToReceiveVideo);const s=this.getTransceivers().find(o=>o.receiver.track.kind==="video");i.offerToReceiveVideo===!1&&s?s.direction==="sendrecv"?s.setDirection?s.setDirection("sendonly"):s.direction="sendonly":s.direction==="recvonly"&&(s.setDirection?s.setDirection("inactive"):s.direction="inactive"):i.offerToReceiveVideo===!0&&!s&&this.addTransceiver("video",{direction:"recvonly"})}return e.apply(this,arguments)}}function FM(n){typeof n!="object"||n.AudioContext||(n.AudioContext=n.webkitAudioContext)}var qx=Object.freeze(Object.defineProperty({__proto__:null,shimLocalStreamsAPI:RM,shimRemoteStreamsAPI:IM,shimCallbacksAPI:PM,shimGetUserMedia:NM,shimConstraints:LM,shimRTCIceServerUrls:DM,shimTrackEventTransceiver:kM,shimCreateOfferLegacy:OM,shimAudioContext:FM},Symbol.toStringTag,{value:"Module"})),Xy={exports:{}};(function(n){const e={};e.generateIdentifier=function(){return Math.random().toString(36).substr(2,10)},e.localCName=e.generateIdentifier(),e.splitLines=function(t){return t.trim().split(`
`).map(i=>i.trim())},e.splitSections=function(t){return t.split(`
m=`).map((r,s)=>(s>0?"m="+r:r).trim()+`\r
`)},e.getDescription=function(t){const i=e.splitSections(t);return i&&i[0]},e.getMediaSections=function(t){const i=e.splitSections(t);return i.shift(),i},e.matchPrefix=function(t,i){return e.splitLines(t).filter(r=>r.indexOf(i)===0)},e.parseCandidate=function(t){let i;t.indexOf("a=candidate:")===0?i=t.substring(12).split(" "):i=t.substring(10).split(" ");const r={foundation:i[0],component:{1:"rtp",2:"rtcp"}[i[1]]||i[1],protocol:i[2].toLowerCase(),priority:parseInt(i[3],10),ip:i[4],address:i[4],port:parseInt(i[5],10),type:i[7]};for(let s=8;s<i.length;s+=2)switch(i[s]){case"raddr":r.relatedAddress=i[s+1];break;case"rport":r.relatedPort=parseInt(i[s+1],10);break;case"tcptype":r.tcpType=i[s+1];break;case"ufrag":r.ufrag=i[s+1],r.usernameFragment=i[s+1];break;default:r[i[s]]===void 0&&(r[i[s]]=i[s+1]);break}return r},e.writeCandidate=function(t){const i=[];i.push(t.foundation);const r=t.component;r==="rtp"?i.push(1):r==="rtcp"?i.push(2):i.push(r),i.push(t.protocol.toUpperCase()),i.push(t.priority),i.push(t.address||t.ip),i.push(t.port);const s=t.type;return i.push("typ"),i.push(s),s!=="host"&&t.relatedAddress&&t.relatedPort&&(i.push("raddr"),i.push(t.relatedAddress),i.push("rport"),i.push(t.relatedPort)),t.tcpType&&t.protocol.toLowerCase()==="tcp"&&(i.push("tcptype"),i.push(t.tcpType)),(t.usernameFragment||t.ufrag)&&(i.push("ufrag"),i.push(t.usernameFragment||t.ufrag)),"candidate:"+i.join(" ")},e.parseIceOptions=function(t){return t.substr(14).split(" ")},e.parseRtpMap=function(t){let i=t.substr(9).split(" ");const r={payloadType:parseInt(i.shift(),10)};return i=i[0].split("/"),r.name=i[0],r.clockRate=parseInt(i[1],10),r.channels=i.length===3?parseInt(i[2],10):1,r.numChannels=r.channels,r},e.writeRtpMap=function(t){let i=t.payloadType;t.preferredPayloadType!==void 0&&(i=t.preferredPayloadType);const r=t.channels||t.numChannels||1;return"a=rtpmap:"+i+" "+t.name+"/"+t.clockRate+(r!==1?"/"+r:"")+`\r
`},e.parseExtmap=function(t){const i=t.substr(9).split(" ");return{id:parseInt(i[0],10),direction:i[0].indexOf("/")>0?i[0].split("/")[1]:"sendrecv",uri:i[1]}},e.writeExtmap=function(t){return"a=extmap:"+(t.id||t.preferredId)+(t.direction&&t.direction!=="sendrecv"?"/"+t.direction:"")+" "+t.uri+`\r
`},e.parseFmtp=function(t){const i={};let r;const s=t.substr(t.indexOf(" ")+1).split(";");for(let o=0;o<s.length;o++)r=s[o].trim().split("="),i[r[0].trim()]=r[1];return i},e.writeFmtp=function(t){let i="",r=t.payloadType;if(t.preferredPayloadType!==void 0&&(r=t.preferredPayloadType),t.parameters&&Object.keys(t.parameters).length){const s=[];Object.keys(t.parameters).forEach(o=>{t.parameters[o]!==void 0?s.push(o+"="+t.parameters[o]):s.push(o)}),i+="a=fmtp:"+r+" "+s.join(";")+`\r
`}return i},e.parseRtcpFb=function(t){const i=t.substr(t.indexOf(" ")+1).split(" ");return{type:i.shift(),parameter:i.join(" ")}},e.writeRtcpFb=function(t){let i="",r=t.payloadType;return t.preferredPayloadType!==void 0&&(r=t.preferredPayloadType),t.rtcpFeedback&&t.rtcpFeedback.length&&t.rtcpFeedback.forEach(s=>{i+="a=rtcp-fb:"+r+" "+s.type+(s.parameter&&s.parameter.length?" "+s.parameter:"")+`\r
`}),i},e.parseSsrcMedia=function(t){const i=t.indexOf(" "),r={ssrc:parseInt(t.substr(7,i-7),10)},s=t.indexOf(":",i);return s>-1?(r.attribute=t.substr(i+1,s-i-1),r.value=t.substr(s+1)):r.attribute=t.substr(i+1),r},e.parseSsrcGroup=function(t){const i=t.substr(13).split(" ");return{semantics:i.shift(),ssrcs:i.map(r=>parseInt(r,10))}},e.getMid=function(t){const i=e.matchPrefix(t,"a=mid:")[0];if(i)return i.substr(6)},e.parseFingerprint=function(t){const i=t.substr(14).split(" ");return{algorithm:i[0].toLowerCase(),value:i[1].toUpperCase()}},e.getDtlsParameters=function(t,i){const r=e.matchPrefix(t+i,"a=fingerprint:");return{role:"auto",fingerprints:r.map(e.parseFingerprint)}},e.writeDtlsParameters=function(t,i){let r="a=setup:"+i+`\r
`;return t.fingerprints.forEach(s=>{r+="a=fingerprint:"+s.algorithm+" "+s.value+`\r
`}),r},e.parseCryptoLine=function(t){const i=t.substr(9).split(" ");return{tag:parseInt(i[0],10),cryptoSuite:i[1],keyParams:i[2],sessionParams:i.slice(3)}},e.writeCryptoLine=function(t){return"a=crypto:"+t.tag+" "+t.cryptoSuite+" "+(typeof t.keyParams=="object"?e.writeCryptoKeyParams(t.keyParams):t.keyParams)+(t.sessionParams?" "+t.sessionParams.join(" "):"")+`\r
`},e.parseCryptoKeyParams=function(t){if(t.indexOf("inline:")!==0)return null;const i=t.substr(7).split("|");return{keyMethod:"inline",keySalt:i[0],lifeTime:i[1],mkiValue:i[2]?i[2].split(":")[0]:void 0,mkiLength:i[2]?i[2].split(":")[1]:void 0}},e.writeCryptoKeyParams=function(t){return t.keyMethod+":"+t.keySalt+(t.lifeTime?"|"+t.lifeTime:"")+(t.mkiValue&&t.mkiLength?"|"+t.mkiValue+":"+t.mkiLength:"")},e.getCryptoParameters=function(t,i){return e.matchPrefix(t+i,"a=crypto:").map(e.parseCryptoLine)},e.getIceParameters=function(t,i){const r=e.matchPrefix(t+i,"a=ice-ufrag:")[0],s=e.matchPrefix(t+i,"a=ice-pwd:")[0];return r&&s?{usernameFragment:r.substr(12),password:s.substr(10)}:null},e.writeIceParameters=function(t){let i="a=ice-ufrag:"+t.usernameFragment+`\r
a=ice-pwd:`+t.password+`\r
`;return t.iceLite&&(i+=`a=ice-lite\r
`),i},e.parseRtpParameters=function(t){const i={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},s=e.splitLines(t)[0].split(" ");for(let o=3;o<s.length;o++){const a=s[o],l=e.matchPrefix(t,"a=rtpmap:"+a+" ")[0];if(l){const c=e.parseRtpMap(l),u=e.matchPrefix(t,"a=fmtp:"+a+" ");switch(c.parameters=u.length?e.parseFmtp(u[0]):{},c.rtcpFeedback=e.matchPrefix(t,"a=rtcp-fb:"+a+" ").map(e.parseRtcpFb),i.codecs.push(c),c.name.toUpperCase()){case"RED":case"ULPFEC":i.fecMechanisms.push(c.name.toUpperCase());break}}}return e.matchPrefix(t,"a=extmap:").forEach(o=>{i.headerExtensions.push(e.parseExtmap(o))}),i},e.writeRtpDescription=function(t,i){let r="";r+="m="+t+" ",r+=i.codecs.length>0?"9":"0",r+=" UDP/TLS/RTP/SAVPF ",r+=i.codecs.map(o=>o.preferredPayloadType!==void 0?o.preferredPayloadType:o.payloadType).join(" ")+`\r
`,r+=`c=IN IP4 0.0.0.0\r
`,r+=`a=rtcp:9 IN IP4 0.0.0.0\r
`,i.codecs.forEach(o=>{r+=e.writeRtpMap(o),r+=e.writeFmtp(o),r+=e.writeRtcpFb(o)});let s=0;return i.codecs.forEach(o=>{o.maxptime>s&&(s=o.maxptime)}),s>0&&(r+="a=maxptime:"+s+`\r
`),i.headerExtensions&&i.headerExtensions.forEach(o=>{r+=e.writeExtmap(o)}),r},e.parseRtpEncodingParameters=function(t){const i=[],r=e.parseRtpParameters(t),s=r.fecMechanisms.indexOf("RED")!==-1,o=r.fecMechanisms.indexOf("ULPFEC")!==-1,a=e.matchPrefix(t,"a=ssrc:").map(d=>e.parseSsrcMedia(d)).filter(d=>d.attribute==="cname"),l=a.length>0&&a[0].ssrc;let c;const u=e.matchPrefix(t,"a=ssrc-group:FID").map(d=>d.substr(17).split(" ").map(p=>parseInt(p,10)));u.length>0&&u[0].length>1&&u[0][0]===l&&(c=u[0][1]),r.codecs.forEach(d=>{if(d.name.toUpperCase()==="RTX"&&d.parameters.apt){let f={ssrc:l,codecPayloadType:parseInt(d.parameters.apt,10)};l&&c&&(f.rtx={ssrc:c}),i.push(f),s&&(f=JSON.parse(JSON.stringify(f)),f.fec={ssrc:l,mechanism:o?"red+ulpfec":"red"},i.push(f))}}),i.length===0&&l&&i.push({ssrc:l});let h=e.matchPrefix(t,"b=");return h.length&&(h[0].indexOf("b=TIAS:")===0?h=parseInt(h[0].substr(7),10):h[0].indexOf("b=AS:")===0?h=parseInt(h[0].substr(5),10)*1e3*.95-50*40*8:h=void 0,i.forEach(d=>{d.maxBitrate=h})),i},e.parseRtcpParameters=function(t){const i={},r=e.matchPrefix(t,"a=ssrc:").map(a=>e.parseSsrcMedia(a)).filter(a=>a.attribute==="cname")[0];r&&(i.cname=r.value,i.ssrc=r.ssrc);const s=e.matchPrefix(t,"a=rtcp-rsize");i.reducedSize=s.length>0,i.compound=s.length===0;const o=e.matchPrefix(t,"a=rtcp-mux");return i.mux=o.length>0,i},e.writeRtcpParameters=function(t){let i="";return t.reducedSize&&(i+=`a=rtcp-rsize\r
`),t.mux&&(i+=`a=rtcp-mux\r
`),t.ssrc!==void 0&&t.cname&&(i+="a=ssrc:"+t.ssrc+" cname:"+t.cname+`\r
`),i},e.parseMsid=function(t){let i;const r=e.matchPrefix(t,"a=msid:");if(r.length===1)return i=r[0].substr(7).split(" "),{stream:i[0],track:i[1]};const s=e.matchPrefix(t,"a=ssrc:").map(o=>e.parseSsrcMedia(o)).filter(o=>o.attribute==="msid");if(s.length>0)return i=s[0].value.split(" "),{stream:i[0],track:i[1]}},e.parseSctpDescription=function(t){const i=e.parseMLine(t),r=e.matchPrefix(t,"a=max-message-size:");let s;r.length>0&&(s=parseInt(r[0].substr(19),10)),isNaN(s)&&(s=65536);const o=e.matchPrefix(t,"a=sctp-port:");if(o.length>0)return{port:parseInt(o[0].substr(12),10),protocol:i.fmt,maxMessageSize:s};const a=e.matchPrefix(t,"a=sctpmap:");if(a.length>0){const l=a[0].substr(10).split(" ");return{port:parseInt(l[0],10),protocol:l[1],maxMessageSize:s}}},e.writeSctpDescription=function(t,i){let r=[];return t.protocol!=="DTLS/SCTP"?r=["m="+t.kind+" 9 "+t.protocol+" "+i.protocol+`\r
`,`c=IN IP4 0.0.0.0\r
`,"a=sctp-port:"+i.port+`\r
`]:r=["m="+t.kind+" 9 "+t.protocol+" "+i.port+`\r
`,`c=IN IP4 0.0.0.0\r
`,"a=sctpmap:"+i.port+" "+i.protocol+` 65535\r
`],i.maxMessageSize!==void 0&&r.push("a=max-message-size:"+i.maxMessageSize+`\r
`),r.join("")},e.generateSessionId=function(){return Math.random().toString().substr(2,21)},e.writeSessionBoilerplate=function(t,i,r){let s;const o=i!==void 0?i:2;return t?s=t:s=e.generateSessionId(),`v=0\r
o=`+(r||"thisisadapterortc")+" "+s+" "+o+` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`},e.getDirection=function(t,i){const r=e.splitLines(t);for(let s=0;s<r.length;s++)switch(r[s]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return r[s].substr(2)}return i?e.getDirection(i):"sendrecv"},e.getKind=function(t){return e.splitLines(t)[0].split(" ")[0].substr(2)},e.isRejected=function(t){return t.split(" ",2)[1]==="0"},e.parseMLine=function(t){const r=e.splitLines(t)[0].substr(2).split(" ");return{kind:r[0],port:parseInt(r[1],10),protocol:r[2],fmt:r.slice(3).join(" ")}},e.parseOLine=function(t){const r=e.matchPrefix(t,"o=")[0].substr(2).split(" ");return{username:r[0],sessionId:r[1],sessionVersion:parseInt(r[2],10),netType:r[3],addressType:r[4],address:r[5]}},e.isValidSDP=function(t){if(typeof t!="string"||t.length===0)return!1;const i=e.splitLines(t);for(let r=0;r<i.length;r++)if(i[r].length<2||i[r].charAt(1)!=="=")return!1;return!0},n.exports=e})(Xy);var Rc=Xy.exports,tX=Xb({__proto__:null,default:Rc},[Xy.exports]);function dd(n){if(!n.RTCIceCandidate||n.RTCIceCandidate&&"foundation"in n.RTCIceCandidate.prototype)return;const e=n.RTCIceCandidate;n.RTCIceCandidate=function(i){if(typeof i=="object"&&i.candidate&&i.candidate.indexOf("a=")===0&&(i=JSON.parse(JSON.stringify(i)),i.candidate=i.candidate.substr(2)),i.candidate&&i.candidate.length){const r=new e(i),s=Rc.parseCandidate(i.candidate),o=Object.assign(r,s);return o.toJSON=function(){return{candidate:o.candidate,sdpMid:o.sdpMid,sdpMLineIndex:o.sdpMLineIndex,usernameFragment:o.usernameFragment}},o}return new e(i)},n.RTCIceCandidate.prototype=e.prototype,ql(n,"icecandidate",t=>(t.candidate&&Object.defineProperty(t,"candidate",{value:new n.RTCIceCandidate(t.candidate),writable:"false"}),t))}function fd(n,e){if(!n.RTCPeerConnection)return;"sctp"in n.RTCPeerConnection.prototype||Object.defineProperty(n.RTCPeerConnection.prototype,"sctp",{get(){return typeof this._sctp=="undefined"?null:this._sctp}});const t=function(a){if(!a||!a.sdp)return!1;const l=Rc.splitSections(a.sdp);return l.shift(),l.some(c=>{const u=Rc.parseMLine(c);return u&&u.kind==="application"&&u.protocol.indexOf("SCTP")!==-1})},i=function(a){const l=a.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(l===null||l.length<2)return-1;const c=parseInt(l[1],10);return c!==c?-1:c},r=function(a){let l=65536;return e.browser==="firefox"&&(e.version<57?a===-1?l=16384:l=2147483637:e.version<60?l=e.version===57?65535:65536:l=2147483637),l},s=function(a,l){let c=65536;e.browser==="firefox"&&e.version===57&&(c=65535);const u=Rc.matchPrefix(a.sdp,"a=max-message-size:");return u.length>0?c=parseInt(u[0].substr(19),10):e.browser==="firefox"&&l!==-1&&(c=2147483637),c},o=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,e.browser==="chrome"&&e.version>=76){const{sdpSemantics:l}=this.getConfiguration();l==="plan-b"&&Object.defineProperty(this,"sctp",{get(){return typeof this._sctp=="undefined"?null:this._sctp},enumerable:!0,configurable:!0})}if(t(arguments[0])){const l=i(arguments[0]),c=r(l),u=s(arguments[0],l);let h;c===0&&u===0?h=Number.POSITIVE_INFINITY:c===0||u===0?h=Math.max(c,u):h=Math.min(c,u);const d={};Object.defineProperty(d,"maxMessageSize",{get(){return h}}),this._sctp=d}return o.apply(this,arguments)}}function pd(n){if(!(n.RTCPeerConnection&&"createDataChannel"in n.RTCPeerConnection.prototype))return;function e(i,r){const s=i.send;i.send=function(){const a=arguments[0],l=a.length||a.size||a.byteLength;if(i.readyState==="open"&&r.sctp&&l>r.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+r.sctp.maxMessageSize+" bytes)");return s.apply(i,arguments)}}const t=n.RTCPeerConnection.prototype.createDataChannel;n.RTCPeerConnection.prototype.createDataChannel=function(){const r=t.apply(this,arguments);return e(r,this),r},ql(n,"datachannel",i=>(e(i.channel,i.target),i))}function Tg(n){if(!n.RTCPeerConnection||"connectionState"in n.RTCPeerConnection.prototype)return;const e=n.RTCPeerConnection.prototype;Object.defineProperty(e,"connectionState",{get(){return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(e,"onconnectionstatechange",{get(){return this._onconnectionstatechange||null},set(t){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),t&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=t)},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach(t=>{const i=e[t];e[t]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=r=>{const s=r.target;if(s._lastConnectionState!==s.connectionState){s._lastConnectionState=s.connectionState;const o=new Event("connectionstatechange",r);s.dispatchEvent(o)}return r},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),i.apply(this,arguments)}})}function Eg(n,e){if(!n.RTCPeerConnection||e.browser==="chrome"&&e.version>=71||e.browser==="safari"&&e.version>=605)return;const t=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(r){if(r&&r.sdp&&r.sdp.indexOf(`
a=extmap-allow-mixed`)!==-1){const s=r.sdp.split(`
`).filter(o=>o.trim()!=="a=extmap-allow-mixed").join(`
`);n.RTCSessionDescription&&r instanceof n.RTCSessionDescription?arguments[0]=new n.RTCSessionDescription({type:r.type,sdp:s}):r.sdp=s}return t.apply(this,arguments)}}function md(n,e){if(!(n.RTCPeerConnection&&n.RTCPeerConnection.prototype))return;const t=n.RTCPeerConnection.prototype.addIceCandidate;!t||t.length===0||(n.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?(e.browser==="chrome"&&e.version<78||e.browser==="firefox"&&e.version<68||e.browser==="safari")&&arguments[0]&&arguments[0].candidate===""?Promise.resolve():t.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())})}function gd(n,e){if(!(n.RTCPeerConnection&&n.RTCPeerConnection.prototype))return;const t=n.RTCPeerConnection.prototype.setLocalDescription;!t||t.length===0||(n.RTCPeerConnection.prototype.setLocalDescription=function(){let r=arguments[0]||{};if(typeof r!="object"||r.type&&r.sdp)return t.apply(this,arguments);if(r={type:r.type,sdp:r.sdp},!r.type)switch(this.signalingState){case"stable":case"have-local-offer":case"have-remote-pranswer":r.type="offer";break;default:r.type="answer";break}return r.sdp||r.type!=="offer"&&r.type!=="answer"?t.apply(this,[r]):(r.type==="offer"?this.createOffer:this.createAnswer).apply(this).then(o=>t.apply(this,[o]))})}var nX=Object.freeze(Object.defineProperty({__proto__:null,shimRTCIceCandidate:dd,shimMaxMessageSize:fd,shimSendThrowTypeError:pd,shimConnectionState:Tg,removeExtmapAllowMixed:Eg,shimAddIceCandidateNullOrEmpty:md,shimParameterlessSetLocalDescription:gd},Symbol.toStringTag,{value:"Module"}));function iX({window:n}={},e={shimChrome:!0,shimFirefox:!0,shimSafari:!0}){const t=lM,i=Jq(n),r={browserDetails:i,commonShim:nX,extractVersion:hd,disableLog:Kq,disableWarnings:Zq,sdp:tX};switch(i.browser){case"chrome":if(!Wx||!wg||!e.shimChrome)return t("Chrome shim is not included in this adapter release."),r;if(i.version===null)return t("Chrome shim can not determine version, not shimming."),r;t("adapter.js shimming chrome."),r.browserShim=Wx,md(n,i),gd(n),uM(n,i),hM(n),wg(n,i),dM(n),yM(n,i),fM(n),pM(n),mM(n),vM(n,i),dd(n),Tg(n),fd(n,i),pd(n),Eg(n,i);break;case"firefox":if(!jx||!Sg||!e.shimFirefox)return t("Firefox shim is not included in this adapter release."),r;t("adapter.js shimming firefox."),r.browserShim=jx,md(n,i),gd(n),xM(n,i),Sg(n,i),_M(n),SM(n),bM(n),wM(n),TM(n),EM(n),CM(n),MM(n),AM(n),dd(n),Tg(n),fd(n,i),pd(n);break;case"safari":if(!qx||!e.shimSafari)return t("Safari shim is not included in this adapter release."),r;t("adapter.js shimming safari."),r.browserShim=qx,md(n,i),gd(n),DM(n),OM(n),PM(n),RM(n),IM(n),kM(n),NM(n),FM(n),dd(n),fd(n,i),pd(n),Eg(n,i);break;default:t("Unsupported browser!");break}return r}iX({window:typeof window=="undefined"?void 0:window});class rX{constructor(e=60){this.time={stopped:!1,previous:null,current:null,elapsed:null,interval:1e3/e}}start(e=!1){this.time.stopped=!1,this.time.previous=Date.now(),this.func=e,this.func&&typeof this.func=="function"&&this.update()}stop(){this.time.stopped=!0}update(){this.time.stopped||(window.requestAnimationFrame(()=>this.update()),this.time.current=Date.now(),this.time.elapsed=this.time.current-this.time.previous,this.time.elapsed>=this.time.interval&&(this.time.previous=this.time.current-this.time.elapsed%this.time.interval,this.func()))}}var Yy={},Ky={},Zy={};const Jy="125",sX={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},oX={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},$M=0,Cg=1,BM=2,aX=3,lX=0,Qy=1,zM=2,rl=3,Xl=0,un=1,$u=2,ev=1,cX=2,hs=0,ul=1,Mg=2,Ag=3,Rg=4,UM=5,Lo=100,VM=101,GM=102,Ig=103,Pg=104,HM=200,WM=201,jM=202,qM=203,tv=204,nv=205,XM=206,YM=207,KM=208,ZM=209,JM=210,QM=0,e2=1,t2=2,kd=3,n2=4,i2=5,r2=6,s2=7,Bu=0,o2=1,a2=2,qo=0,l2=1,c2=2,u2=3,h2=4,d2=5,Gf=300,zu=301,Uu=302,Od=303,Fd=304,Yl=306,Vu=307,Yc=1e3,ii=1001,Kc=1002,bn=1003,$d=1004,uX=1004,Bd=1005,hX=1005,Cn=1006,iv=1007,dX=1007,Kl=1008,fX=1008,Zl=1009,f2=1010,p2=1011,Zc=1012,m2=1013,Ic=1014,ls=1015,Jc=1016,g2=1017,y2=1018,v2=1019,hl=1020,x2=1021,js=1022,Mi=1023,_2=1024,b2=1025,w2=Mi,Xo=1026,Sl=1027,S2=1028,T2=1029,E2=1030,C2=1031,M2=1032,A2=1033,Ng=33776,Lg=33777,Dg=33778,kg=33779,Og=35840,Fg=35841,$g=35842,Bg=35843,R2=36196,zg=37492,Ug=37496,I2=37808,P2=37809,N2=37810,L2=37811,D2=37812,k2=37813,O2=37814,F2=37815,$2=37816,B2=37817,z2=37818,U2=37819,V2=37820,G2=37821,H2=36492,W2=37840,j2=37841,q2=37842,X2=37843,Y2=37844,K2=37845,Z2=37846,J2=37847,Q2=37848,eA=37849,tA=37850,nA=37851,iA=37852,rA=37853,sA=2200,oA=2201,aA=2202,Qc=2300,Pc=2301,yd=2302,Bo=2400,zo=2401,eu=2402,Hf=2500,rv=2501,lA=0,pX=1,mX=2,ri=3e3,Gu=3001,Wf=3007,jf=3002,cA=3003,sv=3004,ov=3005,av=3006,uA=3200,hA=3201,wa=0,dA=1,gX=0,vd=7680,yX=7681,vX=7682,xX=7683,_X=34055,bX=34056,wX=5386,SX=512,TX=513,EX=514,CX=515,MX=516,AX=517,RX=518,fA=519,Hu=35044,ta=35048,IX=35040,PX=35045,NX=35049,LX=35041,DX=35046,kX=35050,OX=35042,FX="100",Vg="300 es";function _s(){}Object.assign(_s.prototype,{addEventListener:function(n,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[n]===void 0&&(t[n]=[]),t[n].indexOf(e)===-1&&t[n].push(e)},hasEventListener:function(n,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[n]!==void 0&&t[n].indexOf(e)!==-1},removeEventListener:function(n,e){if(this._listeners===void 0)return;const i=this._listeners[n];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}},dispatchEvent:function(n){if(this._listeners===void 0)return;const t=this._listeners[n.type];if(t!==void 0){n.target=this;const i=t.slice(0);for(let r=0,s=i.length;r<s;r++)i[r].call(this,n)}}});const Nn=[];for(let n=0;n<256;n++)Nn[n]=(n<16?"0":"")+n.toString(16);let hh=1234567;const Ze={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Nn[n&255]+Nn[n>>8&255]+Nn[n>>16&255]+Nn[n>>24&255]+"-"+Nn[e&255]+Nn[e>>8&255]+"-"+Nn[e>>16&15|64]+Nn[e>>24&255]+"-"+Nn[t&63|128]+Nn[t>>8&255]+"-"+Nn[t>>16&255]+Nn[t>>24&255]+Nn[i&255]+Nn[i>>8&255]+Nn[i>>16&255]+Nn[i>>24&255]).toUpperCase()},clamp:function(n,e,t){return Math.max(e,Math.min(t,n))},euclideanModulo:function(n,e){return(n%e+e)%e},mapLinear:function(n,e,t,i,r){return i+(n-e)*(r-i)/(t-e)},lerp:function(n,e,t){return(1-t)*n+t*e},damp:function(n,e,t,i){return Ze.lerp(n,e,1-Math.exp(-t*i))},pingpong:function(n,e=1){return e-Math.abs(Ze.euclideanModulo(n,e*2)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){return n!==void 0&&(hh=n%2147483647),hh=hh*16807%2147483647,(hh-1)/2147483646},degToRad:function(n){return n*Ze.DEG2RAD},radToDeg:function(n){return n*Ze.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)===0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))},setQuaternionFromProperEuler:function(n,e,t,i,r){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),c=s((e+i)/2),u=o((e+i)/2),h=s((e-i)/2),d=o((e-i)/2),f=s((i-e)/2),p=o((i-e)/2);switch(r){case"XYX":n.set(a*u,l*h,l*d,a*c);break;case"YZY":n.set(l*d,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*d,a*u,a*c);break;case"XZX":n.set(a*u,l*p,l*f,a*c);break;case"YXY":n.set(l*f,a*u,l*p,a*c);break;case"ZYZ":n.set(l*p,l*f,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class fe{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class Ei{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=r,u[2]=a,u[3]=t,u[4]=s,u[5]=l,u[6]=i,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],u=i[4],h=i[7],d=i[2],f=i[5],p=i[8],m=r[0],y=r[3],g=r[6],v=r[1],_=r[4],b=r[7],S=r[2],w=r[5],T=r[8];return s[0]=o*m+a*v+l*S,s[3]=o*y+a*_+l*w,s[6]=o*g+a*b+l*T,s[1]=c*m+u*v+h*S,s[4]=c*y+u*_+h*w,s[7]=c*g+u*b+h*T,s[2]=d*m+f*v+p*S,s[5]=d*y+f*_+p*w,s[8]=d*g+f*b+p*T,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-i*s*u+i*a*l+r*s*c-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*s,f=c*s-o*l,p=t*h+i*d+r*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(r*c-u*i)*m,e[2]=(a*i-r*o)*m,e[3]=d*m,e[4]=(u*t-r*l)*m,e[5]=(r*s-a*t)*m,e[6]=f*m,e[7]=(i*l-c*t)*m,e[8]=(o*t-i*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),r=this.elements,s=r[0],o=r[3],a=r[6],l=r[1],c=r[4],u=r[7];return r[0]=t*s+i*l,r[3]=t*o+i*c,r[6]=t*a+i*u,r[1]=-i*s+t*l,r[4]=-i*o+t*c,r[7]=-i*a+t*u,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}}let Ra;const Sa={getDataURL:function(n){if(/^data:/i.test(n.src)||typeof HTMLCanvasElement=="undefined")return n.src;let e;if(n instanceof HTMLCanvasElement)e=n;else{Ra===void 0&&(Ra=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Ra.width=n.width,Ra.height=n.height;const t=Ra.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=Ra}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let $X=0;function Bt(n=Bt.DEFAULT_IMAGE,e=Bt.DEFAULT_MAPPING,t=ii,i=ii,r=Cn,s=Kl,o=Mi,a=Zl,l=1,c=ri){Object.defineProperty(this,"id",{value:$X++}),this.uuid=Ze.generateUUID(),this.name="",this.image=n,this.mipmaps=[],this.mapping=e,this.wrapS=t,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new fe(0,0),this.repeat=new fe(1,1),this.center=new fe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ei,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}Bt.DEFAULT_IMAGE=void 0;Bt.DEFAULT_MAPPING=Gf;Bt.prototype=Object.assign(Object.create(_s.prototype),{constructor:Bt,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.name=n.name,this.image=n.image,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this},toJSON:function(n){const e=n===void 0||typeof n=="string";if(!e&&n.textures[this.uuid]!==void 0)return n.textures[this.uuid];const t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=Ze.generateUUID()),!e&&n.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let s=0,o=i.length;s<o;s++)i[s].isDataTexture?r.push(Ip(i[s].image)):r.push(Ip(i[s]))}else r=Ip(i);n.images[i.uuid]={uuid:i.uuid,url:r}}t.image=i.uuid}return e||(n.textures[this.uuid]=t),t},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(n){if(this.mapping!==Gf)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case Yc:n.x=n.x-Math.floor(n.x);break;case ii:n.x=n.x<0?0:1;break;case Kc:Math.abs(Math.floor(n.x)%2)===1?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x);break}if(n.y<0||n.y>1)switch(this.wrapT){case Yc:n.y=n.y-Math.floor(n.y);break;case ii:n.y=n.y<0?0:1;break;case Kc:Math.abs(Math.floor(n.y)%2)===1?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y);break}return this.flipY&&(n.y=1-n.y),n}});Object.defineProperty(Bt.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function Ip(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?Sa.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class kt{constructor(e=0,t=0,i=0,r=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*i+o[11]*r+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,s;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],f=l[5],p=l[9],m=l[2],y=l[6],g=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-m)<.01&&Math.abs(p-y)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+m)<.1&&Math.abs(p+y)<.1&&Math.abs(c+f+g-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const _=(c+1)/2,b=(f+1)/2,S=(g+1)/2,w=(u+d)/4,T=(h+m)/4,R=(p+y)/4;return _>b&&_>S?_<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(_),r=w/i,s=T/i):b>S?b<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(b),i=w/r,s=R/r):S<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),i=T/s,r=R/s),this.set(i,r,s,t),this}let v=Math.sqrt((y-p)*(y-p)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(v)<.001&&(v=1),this.x=(y-p)/v,this.y=(h-m)/v,this.z=(d-u)/v,this.w=Math.acos((c+f+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class qs extends _s{constructor(e,t,i){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=e,this.height=t,this.scissor=new kt(0,0,e,t),this.scissorTest=!1,this.viewport=new kt(0,0,e,t),i=i||{},this.texture=new Bt(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:Cn,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null}setSize(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class BX extends qs{constructor(e,t,i){super(e,t,i),Object.defineProperty(this,"isWebGLMultisampleRenderTarget",{value:!0}),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}class Xn{constructor(e=0,t=0,i=0,r=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=i,this._w=r}static slerp(e,t,i,r){return i.copy(e).slerp(t,r)}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],c=i[r+1],u=i[r+2],h=i[r+3];const d=s[o+0],f=s[o+1],p=s[o+2],m=s[o+3];if(h!==m||l!==d||c!==f||u!==p){let y=1-a;const g=l*d+c*f+u*p+h*m,v=g>=0?1:-1,_=1-g*g;if(_>Number.EPSILON){const S=Math.sqrt(_),w=Math.atan2(S,g*v);y=Math.sin(y*w)/S,a=Math.sin(a*w)/S}const b=a*v;if(l=l*y+d*b,c=c*y+f*b,u=u*y+p*b,h=h*y+m*b,y===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],u=i[r+3],h=s[o],d=s[o+1],f=s[o+2],p=s[o+3];return e[t]=a*p+u*h+l*f-c*d,e[t+1]=l*p+u*d+c*h-a*f,e[t+2]=c*p+u*f+a*d-l*h,e[t+3]=u*p-a*h-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),u=a(r/2),h=a(s/2),d=l(i/2),f=l(r/2),p=l(s/2);switch(o){case"XYZ":this._x=d*u*h+c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h-d*f*p;break;case"YXZ":this._x=d*u*h+c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h+d*f*p;break;case"ZXY":this._x=d*u*h-c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h-d*f*p;break;case"ZYX":this._x=d*u*h-c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h+d*f*p;break;case"YZX":this._x=d*u*h+c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h-d*f*p;break;case"XZY":this._x=d*u*h-c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=i+a+h;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(u-l)*f,this._y=(s-c)*f,this._z=(o-r)*f}else if(i>a&&i>h){const f=2*Math.sqrt(1+i-a-h);this._w=(u-l)/f,this._x=.25*f,this._y=(r+o)/f,this._z=(s+c)/f}else if(a>h){const f=2*Math.sqrt(1+a-i-h);this._w=(s-c)/f,this._x=(r+o)/f,this._y=.25*f,this._z=(l+u)/f}else{const f=2*Math.sqrt(1+h-i-a);this._w=(o-r)/f,this._x=(s+c)/f,this._y=(l+u)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let r=e.dot(t)+1;return r<1e-6?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ze.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=i*u+o*a+r*c-s*l,this._y=r*u+o*l+s*a-i*c,this._z=s*u+o*c+i*l-r*a,this._w=o*u-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-t;return this._w=f*o+t*this._w,this._x=f*i+t*this._x,this._y=f*r+t*this._y,this._z=f*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=i*h+this._x*d,this._y=r*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class k{constructor(e=0,t=0,i=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Xx.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Xx.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*r-a*i,u=l*i+a*t-s*r,h=l*r+s*i-o*t,d=-s*t-o*i-a*r;return this.x=c*l+d*-s+u*-a-h*-o,this.y=u*l+d*-o+h*-s-c*-a,this.z=h*l+d*-a+c*-o-u*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return Pp.copy(this).projectOnVector(e),this.sub(Pp)}reflect(e){return this.sub(Pp.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(Ze.clamp(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const Pp=new k,Xx=new Xn;class bs{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=e!==void 0?e:new k(1/0,1/0,1/0),this.max=t!==void 0?t:new k(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<i&&(i=h),d<r&&(r=d),u>s&&(s=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,i,r),this.max.set(s,o,a),this}setFromBufferAttribute(e){let t=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<i&&(i=h),d<r&&(r=d),u>s&&(s=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,i,r),this.max.set(s,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=cc.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new k),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new k),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),Lp.copy(t.boundingBox),Lp.applyMatrix4(e.matrixWorld),this.union(Lp));const i=e.children;for(let r=0,s=i.length;r<s;r++)this.expandByObject(i[r]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new k),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,cc),cc.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(uc),dh.subVectors(this.max,uc),Ia.subVectors(e.a,uc),Pa.subVectors(e.b,uc),Na.subVectors(e.c,uc),Es.subVectors(Pa,Ia),Cs.subVectors(Na,Pa),_o.subVectors(Ia,Na);let t=[0,-Es.z,Es.y,0,-Cs.z,Cs.y,0,-_o.z,_o.y,Es.z,0,-Es.x,Cs.z,0,-Cs.x,_o.z,0,-_o.x,-Es.y,Es.x,0,-Cs.y,Cs.x,0,-_o.y,_o.x,0];return!Np(t,Ia,Pa,Na,dh)||(t=[1,0,0,0,1,0,0,0,1],!Np(t,Ia,Pa,Na,dh))?!1:(fh.crossVectors(Es,Cs),t=[fh.x,fh.y,fh.z],Np(t,Ia,Pa,Na,dh))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new k),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return cc.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(cc).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Kr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Kr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Kr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Kr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Kr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Kr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Kr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Kr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Kr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function Np(n,e,t,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){bo.fromArray(n,s);const a=r.x*Math.abs(bo.x)+r.y*Math.abs(bo.y)+r.z*Math.abs(bo.z),l=e.dot(bo),c=t.dot(bo),u=i.dot(bo);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const Kr=[new k,new k,new k,new k,new k,new k,new k,new k],cc=new k,Lp=new bs,Ia=new k,Pa=new k,Na=new k,Es=new k,Cs=new k,_o=new k,uc=new k,dh=new k,fh=new k,bo=new k,zX=new bs;class go{constructor(e,t){this.center=e!==void 0?e:new k,this.radius=t!==void 0?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):zX.setFromPoints(e).getCenter(i);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,i.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new k),t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new bs),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const Zr=new k,Dp=new k,ph=new k,Ms=new k,kp=new k,mh=new k,Op=new k;class Jl{constructor(e,t){this.origin=e!==void 0?e:new k,this.direction=t!==void 0?t:new k(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new k),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Zr)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new k),t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Zr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Zr.copy(this.direction).multiplyScalar(t).add(this.origin),Zr.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){Dp.copy(e).add(t).multiplyScalar(.5),ph.copy(t).sub(e).normalize(),Ms.copy(this.origin).sub(Dp);const s=e.distanceTo(t)*.5,o=-this.direction.dot(ph),a=Ms.dot(this.direction),l=-Ms.dot(ph),c=Ms.lengthSq(),u=Math.abs(1-o*o);let h,d,f,p;if(u>0)if(h=o*l-a,d=o*a-l,p=s*u,h>=0)if(d>=-p)if(d<=p){const m=1/u;h*=m,d*=m,f=h*(h+o*d+2*a)+d*(o*h+d+2*l)+c}else d=s,h=Math.max(0,-(o*d+a)),f=-h*h+d*(d+2*l)+c;else d=-s,h=Math.max(0,-(o*d+a)),f=-h*h+d*(d+2*l)+c;else d<=-p?(h=Math.max(0,-(-o*s+a)),d=h>0?-s:Math.min(Math.max(-s,-l),s),f=-h*h+d*(d+2*l)+c):d<=p?(h=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(h=Math.max(0,-(o*s+a)),d=h>0?s:Math.min(Math.max(-s,-l),s),f=-h*h+d*(d+2*l)+c);else d=o>0?-s:s,h=Math.max(0,-(o*d+a)),f=-h*h+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(ph).multiplyScalar(d).add(Dp),f}intersectSphere(e,t){Zr.subVectors(e.center,this.origin);const i=Zr.dot(this.direction),r=Zr.dot(Zr)-i*i,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,s,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(i=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(i=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),u>=0?(s=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(s=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),i>o||s>r||((s>i||i!==i)&&(i=s),(o<r||r!==r)&&(r=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,t)}intersectsBox(e){return this.intersectBox(e,Zr)!==null}intersectTriangle(e,t,i,r,s){kp.subVectors(t,e),mh.subVectors(i,e),Op.crossVectors(kp,mh);let o=this.direction.dot(Op),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Ms.subVectors(this.origin,e);const l=a*this.direction.dot(mh.crossVectors(Ms,mh));if(l<0)return null;const c=a*this.direction.dot(kp.cross(Ms));if(c<0||l+c>o)return null;const u=-a*Ms.dot(Op);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class ut{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c,u,h,d,f,p,m,y){const g=this.elements;return g[0]=e,g[4]=t,g[8]=i,g[12]=r,g[1]=s,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=f,g[7]=p,g[11]=m,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ut().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/La.setFromMatrixColumn(e,0).length(),s=1/La.setFromMatrixColumn(e,1).length(),o=1/La.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),u=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const d=o*u,f=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=f+p*c,t[5]=d-m*c,t[9]=-a*l,t[2]=m-d*c,t[6]=p+f*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,f=l*h,p=c*u,m=c*h;t[0]=d+m*a,t[4]=p*a-f,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=f*a-p,t[6]=m+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,f=l*h,p=c*u,m=c*h;t[0]=d-m*a,t[4]=-o*h,t[8]=p+f*a,t[1]=f+p*a,t[5]=o*u,t[9]=m-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,f=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=p*c-f,t[8]=d*c+m,t[1]=l*h,t[5]=m*c+d,t[9]=f*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,f=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=m-d*h,t[8]=p*h+f,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=f*h+p,t[10]=d-m*h}else if(e.order==="XZY"){const d=o*l,f=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+m,t[5]=o*u,t[9]=f*h-p,t[2]=p*h-f,t[6]=a*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(UX,e,VX)}lookAt(e,t,i){const r=this.elements;return _i.subVectors(e,t),_i.lengthSq()===0&&(_i.z=1),_i.normalize(),As.crossVectors(i,_i),As.lengthSq()===0&&(Math.abs(i.z)===1?_i.x+=1e-4:_i.z+=1e-4,_i.normalize(),As.crossVectors(i,_i)),As.normalize(),gh.crossVectors(_i,As),r[0]=As.x,r[4]=gh.x,r[8]=_i.x,r[1]=As.y,r[5]=gh.y,r[9]=_i.y,r[2]=As.z,r[6]=gh.z,r[10]=_i.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],u=i[1],h=i[5],d=i[9],f=i[13],p=i[2],m=i[6],y=i[10],g=i[14],v=i[3],_=i[7],b=i[11],S=i[15],w=r[0],T=r[4],R=r[8],M=r[12],P=r[1],L=r[5],$=r[9],O=r[13],I=r[2],N=r[6],V=r[10],X=r[14],J=r[3],W=r[7],Q=r[11],re=r[15];return s[0]=o*w+a*P+l*I+c*J,s[4]=o*T+a*L+l*N+c*W,s[8]=o*R+a*$+l*V+c*Q,s[12]=o*M+a*O+l*X+c*re,s[1]=u*w+h*P+d*I+f*J,s[5]=u*T+h*L+d*N+f*W,s[9]=u*R+h*$+d*V+f*Q,s[13]=u*M+h*O+d*X+f*re,s[2]=p*w+m*P+y*I+g*J,s[6]=p*T+m*L+y*N+g*W,s[10]=p*R+m*$+y*V+g*Q,s[14]=p*M+m*O+y*X+g*re,s[3]=v*w+_*P+b*I+S*J,s[7]=v*T+_*L+b*N+S*W,s[11]=v*R+_*$+b*V+S*Q,s[15]=v*M+_*O+b*X+S*re,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],f=e[14],p=e[3],m=e[7],y=e[11],g=e[15];return p*(+s*l*h-r*c*h-s*a*d+i*c*d+r*a*f-i*l*f)+m*(+t*l*f-t*c*d+s*o*d-r*o*f+r*c*u-s*l*u)+y*(+t*c*h-t*a*f-s*o*h+i*o*f+s*a*u-i*c*u)+g*(-r*a*u-t*l*h+t*a*d+r*o*h-i*o*d+i*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],y=e[14],g=e[15],v=h*y*c-m*d*c+m*l*f-a*y*f-h*l*g+a*d*g,_=p*d*c-u*y*c-p*l*f+o*y*f+u*l*g-o*d*g,b=u*m*c-p*h*c+p*a*f-o*m*f-u*a*g+o*h*g,S=p*h*l-u*m*l-p*a*d+o*m*d+u*a*y-o*h*y,w=t*v+i*_+r*b+s*S;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/w;return e[0]=v*T,e[1]=(m*d*s-h*y*s-m*r*f+i*y*f+h*r*g-i*d*g)*T,e[2]=(a*y*s-m*l*s+m*r*c-i*y*c-a*r*g+i*l*g)*T,e[3]=(h*l*s-a*d*s-h*r*c+i*d*c+a*r*f-i*l*f)*T,e[4]=_*T,e[5]=(u*y*s-p*d*s+p*r*f-t*y*f-u*r*g+t*d*g)*T,e[6]=(p*l*s-o*y*s-p*r*c+t*y*c+o*r*g-t*l*g)*T,e[7]=(o*d*s-u*l*s+u*r*c-t*d*c-o*r*f+t*l*f)*T,e[8]=b*T,e[9]=(p*h*s-u*m*s-p*i*f+t*m*f+u*i*g-t*h*g)*T,e[10]=(o*m*s-p*a*s+p*i*c-t*m*c-o*i*g+t*a*g)*T,e[11]=(u*a*s-o*h*s-u*i*c+t*h*c+o*i*f-t*a*f)*T,e[12]=S*T,e[13]=(u*m*r-p*h*r+p*i*d-t*m*d-u*i*y+t*h*y)*T,e[14]=(p*a*r-o*m*r-p*i*l+t*m*l+o*i*y-t*a*y)*T,e[15]=(o*h*r-u*a*r+u*i*l-t*h*l-o*i*d+t*a*d)*T,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,c=s*o,u=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,u*a+i,u*l-r*o,0,c*l-r*a,u*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i){return this.set(1,t,i,0,e,1,i,0,e,t,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,u=o+o,h=a+a,d=s*c,f=s*u,p=s*h,m=o*u,y=o*h,g=a*h,v=l*c,_=l*u,b=l*h,S=i.x,w=i.y,T=i.z;return r[0]=(1-(m+g))*S,r[1]=(f+b)*S,r[2]=(p-_)*S,r[3]=0,r[4]=(f-b)*w,r[5]=(1-(d+g))*w,r[6]=(y+v)*w,r[7]=0,r[8]=(p+_)*T,r[9]=(y-v)*T,r[10]=(1-(d+m))*T,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=La.set(r[0],r[1],r[2]).length();const o=La.set(r[4],r[5],r[6]).length(),a=La.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],ar.copy(this);const c=1/s,u=1/o,h=1/a;return ar.elements[0]*=c,ar.elements[1]*=c,ar.elements[2]*=c,ar.elements[4]*=u,ar.elements[5]*=u,ar.elements[6]*=u,ar.elements[8]*=h,ar.elements[9]*=h,ar.elements[10]*=h,t.setFromRotationMatrix(ar),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(t-e),c=2*s/(i-r),u=(t+e)/(t-e),h=(i+r)/(i-r),d=-(o+s)/(o-s),f=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,r,s,o){const a=this.elements,l=1/(t-e),c=1/(i-r),u=1/(o-s),h=(t+e)*l,d=(i+r)*c,f=(o+s)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}const La=new k,ar=new ut,UX=new k(0,0,0),VX=new k(1,1,1),As=new k,gh=new k,_i=new k;class Ql{constructor(e=0,t=0,i=0,r=Ql.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,i){const r=Ze.clamp,s=e.elements,o=s[0],a=s[4],l=s[8],c=s[1],u=s[5],h=s[9],d=s[2],f=s[6],p=s[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(f,u),this._z=0);break;case"YXZ":this._x=Math.asin(-r(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,u)):(this._y=Math.atan2(-d,o),this._z=0);break;case"ZXY":this._x=Math.asin(r(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(r(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,u),this._y=Math.atan2(-d,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,u),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-h,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return Yx.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Yx,t,i)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return Kx.setFromEuler(this),this.setFromQuaternion(Kx,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new k(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Ql.DefaultOrder="XYZ";Ql.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const Yx=new ut,Kx=new Xn;class lv{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let GX=0;const Zx=new k,Da=new Xn,Jr=new ut,yh=new k,hc=new k,HX=new k,WX=new Xn,Jx=new k(1,0,0),Qx=new k(0,1,0),e_=new k(0,0,1),jX={type:"added"},t_={type:"removed"};function ze(){Object.defineProperty(this,"id",{value:GX++}),this.uuid=Ze.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ze.DefaultUp.clone();const n=new k,e=new Ql,t=new Xn,i=new k(1,1,1);function r(){t.setFromEuler(e,!1)}function s(){e.setFromQuaternion(t,void 0,!1)}e._onChange(r),t._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ut},normalMatrix:{value:new Ei}}),this.matrix=new ut,this.matrixWorld=new ut,this.matrixAutoUpdate=ze.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new lv,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}ze.DefaultUp=new k(0,1,0);ze.DefaultMatrixAutoUpdate=!0;ze.prototype=Object.assign(Object.create(_s.prototype),{constructor:ze,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(n){return this.quaternion.premultiply(n),this},setRotationFromAxisAngle:function(n,e){this.quaternion.setFromAxisAngle(n,e)},setRotationFromEuler:function(n){this.quaternion.setFromEuler(n,!0)},setRotationFromMatrix:function(n){this.quaternion.setFromRotationMatrix(n)},setRotationFromQuaternion:function(n){this.quaternion.copy(n)},rotateOnAxis:function(n,e){return Da.setFromAxisAngle(n,e),this.quaternion.multiply(Da),this},rotateOnWorldAxis:function(n,e){return Da.setFromAxisAngle(n,e),this.quaternion.premultiply(Da),this},rotateX:function(n){return this.rotateOnAxis(Jx,n)},rotateY:function(n){return this.rotateOnAxis(Qx,n)},rotateZ:function(n){return this.rotateOnAxis(e_,n)},translateOnAxis:function(n,e){return Zx.copy(n).applyQuaternion(this.quaternion),this.position.add(Zx.multiplyScalar(e)),this},translateX:function(n){return this.translateOnAxis(Jx,n)},translateY:function(n){return this.translateOnAxis(Qx,n)},translateZ:function(n){return this.translateOnAxis(e_,n)},localToWorld:function(n){return n.applyMatrix4(this.matrixWorld)},worldToLocal:function(n){return n.applyMatrix4(Jr.copy(this.matrixWorld).invert())},lookAt:function(n,e,t){n.isVector3?yh.copy(n):yh.set(n,e,t);const i=this.parent;this.updateWorldMatrix(!0,!1),hc.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Jr.lookAt(hc,yh,this.up):Jr.lookAt(yh,hc,this.up),this.quaternion.setFromRotationMatrix(Jr),i&&(Jr.extractRotation(i.matrixWorld),Da.setFromRotationMatrix(Jr),this.quaternion.premultiply(Da.invert()))},add:function(n){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(n.parent!==null&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(jX)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)},remove:function(n){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(n);return e!==-1&&(n.parent=null,this.children.splice(e,1),n.dispatchEvent(t_)),this},clear:function(){for(let n=0;n<this.children.length;n++){const e=this.children[n];e.parent=null,e.dispatchEvent(t_)}return this.children.length=0,this},attach:function(n){return this.updateWorldMatrix(!0,!1),Jr.copy(this.matrixWorld).invert(),n.parent!==null&&(n.parent.updateWorldMatrix(!0,!1),Jr.multiply(n.parent.matrixWorld)),n.applyMatrix4(Jr),n.updateWorldMatrix(!1,!1),this.add(n),this},getObjectById:function(n){return this.getObjectByProperty("id",n)},getObjectByName:function(n){return this.getObjectByProperty("name",n)},getObjectByProperty:function(n,e){if(this[n]===e)return this;for(let t=0,i=this.children.length;t<i;t++){const s=this.children[t].getObjectByProperty(n,e);if(s!==void 0)return s}},getWorldPosition:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),n=new k),this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),n=new Xn),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(hc,n,HX),n},getWorldScale:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),n=new k),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(hc,WX,n),n},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),n=new k),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(n){n(this);const e=this.children;for(let t=0,i=e.length;t<i;t++)e[t].traverse(n)},traverseVisible:function(n){if(this.visible===!1)return;n(this);const e=this.children;for(let t=0,i=e.length;t<i;t++)e[t].traverseVisible(n)},traverseAncestors:function(n){const e=this.parent;e!==null&&(n(e),e.traverseAncestors(n))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);const e=this.children;for(let t=0,i=e.length;t<i;t++)e[t].updateMatrixWorld(n)},updateWorldMatrix:function(n,e){const t=this.parent;if(n===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let r=0,s=i.length;r<s;r++)i[r].updateWorldMatrix(!1,!0)}},toJSON:function(n){const e=n===void 0||typeof n=="string",t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON());function r(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(n)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(n.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const u=a[l];r(n.shapes,u)}else r(n.shapes,a)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(n.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(r(n.materials,this.material[a]));i.material=o}else i.material=r(n.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(n).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];i.animations.push(r(n.animations,a))}}if(e){const o=s(n.geometries),a=s(n.materials),l=s(n.textures),c=s(n.images),u=s(n.shapes),h=s(n.skeletons),d=s(n.animations);o.length>0&&(t.geometries=o),a.length>0&&(t.materials=a),l.length>0&&(t.textures=l),c.length>0&&(t.images=c),u.length>0&&(t.shapes=u),h.length>0&&(t.skeletons=h),d.length>0&&(t.animations=d)}return t.object=i,t;function s(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(n){return new this.constructor().copy(this,n)},copy:function(n,e=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),e===!0)for(let t=0;t<n.children.length;t++){const i=n.children[t];this.add(i.clone())}return this}});const Fp=new k,qX=new k,XX=new Ei;class $r{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=e!==void 0?e:new k(1,0,0),this.constant=t!==void 0?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=Fp.subVectors(i,t).cross(qX.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}clone(){return new this.constructor().copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new k),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new k);const i=e.delta(Fp),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):void 0;const s=-(e.start.dot(this.normal)+this.constant)/r;if(!(s<0||s>1))return t.copy(i).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new k),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||XX.getNormalMatrix(e),r=this.coplanarPoint(Fp).applyMatrix4(e),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const lr=new k,Qr=new k,$p=new k,es=new k,ka=new k,Oa=new k,n_=new k,Bp=new k,zp=new k,Up=new k;class qn{constructor(e,t,i){this.a=e!==void 0?e:new k,this.b=t!==void 0?t:new k,this.c=i!==void 0?i:new k}static getNormal(e,t,i,r){r===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new k),r.subVectors(i,t),lr.subVectors(e,t),r.cross(lr);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){lr.subVectors(r,t),Qr.subVectors(i,t),$p.subVectors(e,t);const o=lr.dot(lr),a=lr.dot(Qr),l=lr.dot($p),c=Qr.dot(Qr),u=Qr.dot($p),h=o*c-a*a;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new k),h===0)return s.set(-2,-1,-1);const d=1/h,f=(c*l-a*u)*d,p=(o*u-a*l)*d;return s.set(1-f-p,p,f)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,es),es.x>=0&&es.y>=0&&es.x+es.y<=1}static getUV(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,es),l.set(0,0),l.addScaledVector(s,es.x),l.addScaledVector(o,es.y),l.addScaledVector(a,es.z),l}static isFrontFacing(e,t,i,r){return lr.subVectors(i,t),Qr.subVectors(e,t),lr.cross(Qr).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return lr.subVectors(this.c,this.b),Qr.subVectors(this.a,this.b),lr.cross(Qr).length()*.5}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new k),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return qn.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new $r),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return qn.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,r,s){return qn.getUV(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return qn.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return qn.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new k);const i=this.a,r=this.b,s=this.c;let o,a;ka.subVectors(r,i),Oa.subVectors(s,i),Bp.subVectors(e,i);const l=ka.dot(Bp),c=Oa.dot(Bp);if(l<=0&&c<=0)return t.copy(i);zp.subVectors(e,r);const u=ka.dot(zp),h=Oa.dot(zp);if(u>=0&&h<=u)return t.copy(r);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(i).addScaledVector(ka,o);Up.subVectors(e,s);const f=ka.dot(Up),p=Oa.dot(Up);if(p>=0&&f<=p)return t.copy(s);const m=f*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(i).addScaledVector(Oa,a);const y=u*p-f*h;if(y<=0&&h-u>=0&&f-p>=0)return n_.subVectors(s,r),a=(h-u)/(h-u+(f-p)),t.copy(r).addScaledVector(n_,a);const g=1/(y+m+d);return o=m*g,a=d*g,t.copy(i).addScaledVector(ka,o).addScaledVector(Oa,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const pA={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},cr={h:0,s:0,l:0},vh={h:0,s:0,l:0};function Vp(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function Gp(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Hp(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class Ne{constructor(e,t,i){return Object.defineProperty(this,"isColor",{value:!0}),t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,i){return this.r=e,this.g=t,this.b=i,this}setHSL(e,t,i){if(e=Ze.euclideanModulo(e,1),t=Ze.clamp(t,0,1),i=Ze.clamp(i,0,1),t===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+t):i+t-i*t,s=2*i-r;this.r=Vp(s,r,e+1/3),this.g=Vp(s,r,e),this.b=Vp(s,r,e-1/3)}return this}setStyle(e){function t(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const s=i[1],o=i[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,t(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,t(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return t(r[4]),this.setHSL(a,l,c)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=pA[e];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const i=t>0?1/t:1;return this.r=Math.pow(e.r,i),this.g=Math.pow(e.g,i),this.b=Math.pow(e.b,i),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=Gp(e.r),this.g=Gp(e.g),this.b=Gp(e.b),this}copyLinearToSRGB(e){return this.r=Hp(e.r),this.g=Hp(e.g),this.b=Hp(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,i=this.g,r=this.b,s=Math.max(t,i,r),o=Math.min(t,i,r);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const u=s-o;switch(l=c<=.5?u/(s+o):u/(2-s-o),s){case t:a=(i-r)/u+(i<r?6:0);break;case i:a=(r-t)/u+2;break;case r:a=(t-i)/u+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,i){return this.getHSL(cr),cr.h+=e,cr.s+=t,cr.l+=i,this.setHSL(cr.h,cr.s,cr.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(cr),e.getHSL(vh);const i=Ze.lerp(cr.h,vh.h,t),r=Ze.lerp(cr.s,vh.s,t),s=Ze.lerp(cr.l,vh.l,t);return this.setHSL(i,r,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ne.NAMES=pA;Ne.prototype.r=1;Ne.prototype.g=1;Ne.prototype.b=1;class cv{constructor(e,t,i,r,s,o=0){this.a=e,this.b=t,this.c=i,this.normal=r&&r.isVector3?r:new k,this.vertexNormals=Array.isArray(r)?r:[],this.color=s&&s.isColor?s:new Ne,this.vertexColors=Array.isArray(s)?s:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,i=e.vertexNormals.length;t<i;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,i=e.vertexColors.length;t<i;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let YX=0;function Ye(){Object.defineProperty(this,"id",{value:YX++}),this.uuid=Ze.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=ul,this.side=Xl,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=tv,this.blendDst=nv,this.blendEquation=Lo,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=kd,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=fA,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=vd,this.stencilZFail=vd,this.stencilZPass=vd,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Ye.prototype=Object.assign(Object.create(_s.prototype),{constructor:Ye,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(n){if(n!==void 0)for(const e in n){const t=n[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===ev;continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(t):i&&i.isVector3&&t&&t.isVector3?i.copy(t):this[e]=t}},toJSON:function(n){const e=n===void 0||typeof n=="string";e&&(n={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,t.reflectivity=this.reflectivity,t.refractionRatio=this.refractionRatio,this.combine!==void 0&&(t.combine=this.combine),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),this.size!==void 0&&(t.size=this.size),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==ul&&(t.blending=this.blending),this.flatShading===!0&&(t.flatShading=this.flatShading),this.side!==Xl&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function i(r){const s=[];for(const o in r){const a=r[o];delete a.metadata,s.push(a)}return s}if(e){const r=i(n.textures),s=i(n.images);r.length>0&&(t.textures=r),s.length>0&&(t.images=s)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(n){this.name=n.name,this.fog=n.fog,this.blending=n.blending,this.side=n.side,this.flatShading=n.flatShading,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;const e=n.clippingPlanes;let t=null;if(e!==null){const i=e.length;t=new Array(i);for(let r=0;r!==i;++r)t[r]=e[r].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(Ye.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function Ri(n){Ye.call(this),this.type="MeshBasicMaterial",this.color=new Ne(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Bu,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(n)}Ri.prototype=Object.create(Ye.prototype);Ri.prototype.constructor=Ri;Ri.prototype.isMeshBasicMaterial=!0;Ri.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this};const Vt=new k,xh=new fe;function Xe(n,e,t){if(Array.isArray(n))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=n,this.itemSize=e,this.count=n!==void 0?n.length/e:0,this.normalized=t===!0,this.usage=Hu,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Xe.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Xe.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[n+i]=e.array[t+i];return this},copyArray:function(n){return this.array.set(n),this},copyColorsArray:function(n){const e=this.array;let t=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),s=new Ne),e[t++]=s.r,e[t++]=s.g,e[t++]=s.b}return this},copyVector2sArray:function(n){const e=this.array;let t=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),s=new fe),e[t++]=s.x,e[t++]=s.y}return this},copyVector3sArray:function(n){const e=this.array;let t=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),s=new k),e[t++]=s.x,e[t++]=s.y,e[t++]=s.z}return this},copyVector4sArray:function(n){const e=this.array;let t=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),s=new kt),e[t++]=s.x,e[t++]=s.y,e[t++]=s.z,e[t++]=s.w}return this},applyMatrix3:function(n){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)xh.fromBufferAttribute(this,e),xh.applyMatrix3(n),this.setXY(e,xh.x,xh.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)Vt.fromBufferAttribute(this,e),Vt.applyMatrix3(n),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this},applyMatrix4:function(n){for(let e=0,t=this.count;e<t;e++)Vt.x=this.getX(e),Vt.y=this.getY(e),Vt.z=this.getZ(e),Vt.applyMatrix4(n),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this},applyNormalMatrix:function(n){for(let e=0,t=this.count;e<t;e++)Vt.x=this.getX(e),Vt.y=this.getY(e),Vt.z=this.getZ(e),Vt.applyNormalMatrix(n),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this},transformDirection:function(n){for(let e=0,t=this.count;e<t;e++)Vt.x=this.getX(e),Vt.y=this.getY(e),Vt.z=this.getZ(e),Vt.transformDirection(n),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this},set:function(n,e=0){return this.array.set(n,e),this},getX:function(n){return this.array[n*this.itemSize]},setX:function(n,e){return this.array[n*this.itemSize]=e,this},getY:function(n){return this.array[n*this.itemSize+1]},setY:function(n,e){return this.array[n*this.itemSize+1]=e,this},getZ:function(n){return this.array[n*this.itemSize+2]},setZ:function(n,e){return this.array[n*this.itemSize+2]=e,this},getW:function(n){return this.array[n*this.itemSize+3]},setW:function(n,e){return this.array[n*this.itemSize+3]=e,this},setXY:function(n,e,t){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this},setXYZ:function(n,e,t,i){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=i,this},setXYZW:function(n,e,t,i,r){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=i,this.array[n+3]=r,this},onUpload:function(n){return this.onUploadCallback=n,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function tu(n,e,t){Xe.call(this,new Int8Array(n),e,t)}tu.prototype=Object.create(Xe.prototype);tu.prototype.constructor=tu;function nu(n,e,t){Xe.call(this,new Uint8Array(n),e,t)}nu.prototype=Object.create(Xe.prototype);nu.prototype.constructor=nu;function iu(n,e,t){Xe.call(this,new Uint8ClampedArray(n),e,t)}iu.prototype=Object.create(Xe.prototype);iu.prototype.constructor=iu;function ru(n,e,t){Xe.call(this,new Int16Array(n),e,t)}ru.prototype=Object.create(Xe.prototype);ru.prototype.constructor=ru;function na(n,e,t){Xe.call(this,new Uint16Array(n),e,t)}na.prototype=Object.create(Xe.prototype);na.prototype.constructor=na;function su(n,e,t){Xe.call(this,new Int32Array(n),e,t)}su.prototype=Object.create(Xe.prototype);su.prototype.constructor=su;function ia(n,e,t){Xe.call(this,new Uint32Array(n),e,t)}ia.prototype=Object.create(Xe.prototype);ia.prototype.constructor=ia;function ou(n,e,t){Xe.call(this,new Uint16Array(n),e,t)}ou.prototype=Object.create(Xe.prototype);ou.prototype.constructor=ou;ou.prototype.isFloat16BufferAttribute=!0;function Le(n,e,t){Xe.call(this,new Float32Array(n),e,t)}Le.prototype=Object.create(Xe.prototype);Le.prototype.constructor=Le;function au(n,e,t){Xe.call(this,new Float64Array(n),e,t)}au.prototype=Object.create(Xe.prototype);au.prototype.constructor=au;function mA(n){if(n.length===0)return-1/0;let e=n[0];for(let t=1,i=n.length;t<i;++t)n[t]>e&&(e=n[t]);return e}const KX={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray!="undefined"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Ec(n,e){return new KX[n](e)}let ZX=0;const Lr=new ut,Wp=new ze,Fa=new k,bi=new bs,dc=new bs,Sn=new k;function He(){Object.defineProperty(this,"id",{value:ZX++}),this.uuid=Ze.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}He.prototype=Object.assign(Object.create(_s.prototype),{constructor:He,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(n){return Array.isArray(n)?this.index=new(mA(n)>65535?ia:na)(n,1):this.index=n,this},getAttribute:function(n){return this.attributes[n]},setAttribute:function(n,e){return this.attributes[n]=e,this},deleteAttribute:function(n){return delete this.attributes[n],this},hasAttribute:function(n){return this.attributes[n]!==void 0},addGroup:function(n,e,t=0){this.groups.push({start:n,count:e,materialIndex:t})},clearGroups:function(){this.groups=[]},setDrawRange:function(n,e){this.drawRange.start=n,this.drawRange.count=e},applyMatrix4:function(n){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(n),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const r=new Ei().getNormalMatrix(n);t.applyNormalMatrix(r),t.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(n),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(n){return Lr.makeRotationX(n),this.applyMatrix4(Lr),this},rotateY:function(n){return Lr.makeRotationY(n),this.applyMatrix4(Lr),this},rotateZ:function(n){return Lr.makeRotationZ(n),this.applyMatrix4(Lr),this},translate:function(n,e,t){return Lr.makeTranslation(n,e,t),this.applyMatrix4(Lr),this},scale:function(n,e,t){return Lr.makeScale(n,e,t),this.applyMatrix4(Lr),this},lookAt:function(n){return Wp.lookAt(n),Wp.updateMatrix(),this.applyMatrix4(Wp.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Fa).negate(),this.translate(Fa.x,Fa.y,Fa.z),this},setFromPoints:function(n){const e=[];for(let t=0,i=n.length;t<i;t++){const r=n[t];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Le(e,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new bs);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new k(-1/0,-1/0,-1/0),new k(1/0,1/0,1/0));return}if(n!==void 0){if(this.boundingBox.setFromBufferAttribute(n),e)for(let t=0,i=e.length;t<i;t++){const r=e[t];bi.setFromBufferAttribute(r),this.morphTargetsRelative?(Sn.addVectors(this.boundingBox.min,bi.min),this.boundingBox.expandByPoint(Sn),Sn.addVectors(this.boundingBox.max,bi.max),this.boundingBox.expandByPoint(Sn)):(this.boundingBox.expandByPoint(bi.min),this.boundingBox.expandByPoint(bi.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new go);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new k,1/0);return}if(n){const t=this.boundingSphere.center;if(bi.setFromBufferAttribute(n),e)for(let r=0,s=e.length;r<s;r++){const o=e[r];dc.setFromBufferAttribute(o),this.morphTargetsRelative?(Sn.addVectors(bi.min,dc.min),bi.expandByPoint(Sn),Sn.addVectors(bi.max,dc.max),bi.expandByPoint(Sn)):(bi.expandByPoint(dc.min),bi.expandByPoint(dc.max))}bi.getCenter(t);let i=0;for(let r=0,s=n.count;r<s;r++)Sn.fromBufferAttribute(n,r),i=Math.max(i,t.distanceToSquared(Sn));if(e)for(let r=0,s=e.length;r<s;r++){const o=e[r],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)Sn.fromBufferAttribute(o,l),a&&(Fa.fromBufferAttribute(n,l),Sn.add(Fa)),i=Math.max(i,t.distanceToSquared(Sn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const n=this.index,e=this.attributes;if(n===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=n.array,i=e.position.array,r=e.normal.array,s=e.uv.array,o=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new Xe(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let M=0;M<o;M++)l[M]=new k,c[M]=new k;const u=new k,h=new k,d=new k,f=new fe,p=new fe,m=new fe,y=new k,g=new k;function v(M,P,L){u.fromArray(i,M*3),h.fromArray(i,P*3),d.fromArray(i,L*3),f.fromArray(s,M*2),p.fromArray(s,P*2),m.fromArray(s,L*2),h.sub(u),d.sub(u),p.sub(f),m.sub(f);const $=1/(p.x*m.y-m.x*p.y);!isFinite($)||(y.copy(h).multiplyScalar(m.y).addScaledVector(d,-p.y).multiplyScalar($),g.copy(d).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar($),l[M].add(y),l[P].add(y),l[L].add(y),c[M].add(g),c[P].add(g),c[L].add(g))}let _=this.groups;_.length===0&&(_=[{start:0,count:t.length}]);for(let M=0,P=_.length;M<P;++M){const L=_[M],$=L.start,O=L.count;for(let I=$,N=$+O;I<N;I+=3)v(t[I+0],t[I+1],t[I+2])}const b=new k,S=new k,w=new k,T=new k;function R(M){w.fromArray(r,M*3),T.copy(w);const P=l[M];b.copy(P),b.sub(w.multiplyScalar(w.dot(P))).normalize(),S.crossVectors(T,P);const $=S.dot(c[M])<0?-1:1;a[M*4]=b.x,a[M*4+1]=b.y,a[M*4+2]=b.z,a[M*4+3]=$}for(let M=0,P=_.length;M<P;++M){const L=_[M],$=L.start,O=L.count;for(let I=$,N=$+O;I<N;I+=3)R(t[I+0]),R(t[I+1]),R(t[I+2])}},computeVertexNormals:function(){const n=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new Xe(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let h=0,d=t.count;h<d;h++)t.setXYZ(h,0,0,0);const i=new k,r=new k,s=new k,o=new k,a=new k,l=new k,c=new k,u=new k;if(n)for(let h=0,d=n.count;h<d;h+=3){const f=n.getX(h+0),p=n.getX(h+1),m=n.getX(h+2);i.fromBufferAttribute(e,f),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,m),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),o.fromBufferAttribute(t,f),a.fromBufferAttribute(t,p),l.fromBufferAttribute(t,m),o.add(c),a.add(c),l.add(c),t.setXYZ(f,o.x,o.y,o.z),t.setXYZ(p,a.x,a.y,a.z),t.setXYZ(m,l.x,l.y,l.z)}else for(let h=0,d=e.count;h<d;h+=3)i.fromBufferAttribute(e,h+0),r.fromBufferAttribute(e,h+1),s.fromBufferAttribute(e,h+2),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),t.setXYZ(h+0,c.x,c.y,c.z),t.setXYZ(h+1,c.x,c.y,c.z),t.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),t.needsUpdate=!0}},merge:function(n,e){if(!(n&&n.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const t=this.attributes;for(const i in t){if(n.attributes[i]===void 0)continue;const s=t[i].array,o=n.attributes[i],a=o.array,l=o.itemSize*e,c=Math.min(a.length,s.length-l);for(let u=0,h=l;u<c;u++,h++)s[h]=a[u]}return this},normalizeNormals:function(){const n=this.attributes.normal;for(let e=0,t=n.count;e<t;e++)Sn.fromBufferAttribute(n,e),Sn.normalize(),n.setXYZ(e,Sn.x,Sn.y,Sn.z)},toNonIndexed:function(){function n(o,a){const l=o.array,c=o.itemSize,u=o.normalized,h=new l.constructor(a.length*c);let d=0,f=0;for(let p=0,m=a.length;p<m;p++){d=a[p]*c;for(let y=0;y<c;y++)h[f++]=l[d++]}return new Xe(h,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new He,t=this.index.array,i=this.attributes;for(const o in i){const a=i[o],l=n(a,t);e.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const a=[],l=r[o];for(let c=0,u=l.length;c<u;c++){const h=l[c],d=n(h,t);a.push(d)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const l=s[o];e.addGroup(l.start,l.count,l.materialIndex)}return e},toJSON:function(){const n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(n[l]=a[l]);return n}n.data={attributes:{}};const e=this.index;e!==null&&(n.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const l=t[a],c=l.toJSON(n.data);l.name!==""&&(c.name=l.name),n.data.attributes[a]=c}const i={};let r=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let u=0,h=l.length;u<h;u++){const d=l[u],f=d.toJSON(n.data);d.name!==""&&(f.name=d.name),c.push(f)}c.length>0&&(i[a]=c,r=!0)}r&&(n.data.morphAttributes=i,n.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(n.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(n.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),n},clone:function(){return new He().copy(this)},copy:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=n.name;const t=n.index;t!==null&&this.setIndex(t.clone(e));const i=n.attributes;for(const l in i){const c=i[l];this.setAttribute(l,c.clone(e))}const r=n.morphAttributes;for(const l in r){const c=[],u=r[l];for(let h=0,d=u.length;h<d;h++)c.push(u[h].clone(e));this.morphAttributes[l]=c}this.morphTargetsRelative=n.morphTargetsRelative;const s=n.groups;for(let l=0,c=s.length;l<c;l++){const u=s[l];this.addGroup(u.start,u.count,u.materialIndex)}const o=n.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=n.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const i_=new ut,$a=new Jl,jp=new go,Rs=new k,Is=new k,Ps=new k,qp=new k,Xp=new k,Yp=new k,_h=new k,bh=new k,wh=new k,Sh=new fe,Th=new fe,Eh=new fe,Kp=new k,Ch=new k;function jt(n=new He,e=new Ri){ze.call(this),this.type="Mesh",this.geometry=n,this.material=e,this.updateMorphTargets()}jt.prototype=Object.assign(Object.create(ze.prototype),{constructor:jt,isMesh:!0,copy:function(n){return ze.prototype.copy.call(this,n),n.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),n.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const i=e[t[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(n,e){const t=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(t.boundingSphere===null&&t.computeBoundingSphere(),jp.copy(t.boundingSphere),jp.applyMatrix4(r),n.ray.intersectsSphere(jp)===!1)||(i_.copy(r).invert(),$a.copy(n.ray).applyMatrix4(i_),t.boundingBox!==null&&$a.intersectsBox(t.boundingBox)===!1))return;let s;if(t.isBufferGeometry){const o=t.index,a=t.attributes.position,l=t.morphAttributes.position,c=t.morphTargetsRelative,u=t.attributes.uv,h=t.attributes.uv2,d=t.groups,f=t.drawRange;if(o!==null)if(Array.isArray(i))for(let p=0,m=d.length;p<m;p++){const y=d[p],g=i[y.materialIndex],v=Math.max(y.start,f.start),_=Math.min(y.start+y.count,f.start+f.count);for(let b=v,S=_;b<S;b+=3){const w=o.getX(b),T=o.getX(b+1),R=o.getX(b+2);s=Mh(this,g,n,$a,a,l,c,u,h,w,T,R),s&&(s.faceIndex=Math.floor(b/3),s.face.materialIndex=y.materialIndex,e.push(s))}}else{const p=Math.max(0,f.start),m=Math.min(o.count,f.start+f.count);for(let y=p,g=m;y<g;y+=3){const v=o.getX(y),_=o.getX(y+1),b=o.getX(y+2);s=Mh(this,i,n,$a,a,l,c,u,h,v,_,b),s&&(s.faceIndex=Math.floor(y/3),e.push(s))}}else if(a!==void 0)if(Array.isArray(i))for(let p=0,m=d.length;p<m;p++){const y=d[p],g=i[y.materialIndex],v=Math.max(y.start,f.start),_=Math.min(y.start+y.count,f.start+f.count);for(let b=v,S=_;b<S;b+=3){const w=b,T=b+1,R=b+2;s=Mh(this,g,n,$a,a,l,c,u,h,w,T,R),s&&(s.faceIndex=Math.floor(b/3),s.face.materialIndex=y.materialIndex,e.push(s))}}else{const p=Math.max(0,f.start),m=Math.min(a.count,f.start+f.count);for(let y=p,g=m;y<g;y+=3){const v=y,_=y+1,b=y+2;s=Mh(this,i,n,$a,a,l,c,u,h,v,_,b),s&&(s.faceIndex=Math.floor(y/3),e.push(s))}}}else t.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function JX(n,e,t,i,r,s,o,a){let l;if(e.side===un?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,e.side!==$u,a),l===null)return null;Ch.copy(a),Ch.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(Ch);return c<t.near||c>t.far?null:{distance:c,point:Ch.clone(),object:n}}function Mh(n,e,t,i,r,s,o,a,l,c,u,h){Rs.fromBufferAttribute(r,c),Is.fromBufferAttribute(r,u),Ps.fromBufferAttribute(r,h);const d=n.morphTargetInfluences;if(e.morphTargets&&s&&d){_h.set(0,0,0),bh.set(0,0,0),wh.set(0,0,0);for(let p=0,m=s.length;p<m;p++){const y=d[p],g=s[p];y!==0&&(qp.fromBufferAttribute(g,c),Xp.fromBufferAttribute(g,u),Yp.fromBufferAttribute(g,h),o?(_h.addScaledVector(qp,y),bh.addScaledVector(Xp,y),wh.addScaledVector(Yp,y)):(_h.addScaledVector(qp.sub(Rs),y),bh.addScaledVector(Xp.sub(Is),y),wh.addScaledVector(Yp.sub(Ps),y)))}Rs.add(_h),Is.add(bh),Ps.add(wh)}n.isSkinnedMesh&&(n.boneTransform(c,Rs),n.boneTransform(u,Is),n.boneTransform(h,Ps));const f=JX(n,e,t,i,Rs,Is,Ps,Kp);if(f){a&&(Sh.fromBufferAttribute(a,c),Th.fromBufferAttribute(a,u),Eh.fromBufferAttribute(a,h),f.uv=qn.getUV(Kp,Rs,Is,Ps,Sh,Th,Eh,new fe)),l&&(Sh.fromBufferAttribute(l,c),Th.fromBufferAttribute(l,u),Eh.fromBufferAttribute(l,h),f.uv2=qn.getUV(Kp,Rs,Is,Ps,Sh,Th,Eh,new fe));const p=new cv(c,u,h);qn.getNormal(Rs,Is,Ps,p.normal),f.face=p}return f}class ra extends He{constructor(e=1,t=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],u=[],h=[];let d=0,f=0;p("z","y","x",-1,-1,i,t,e,o,s,0),p("z","y","x",1,-1,i,t,-e,o,s,1),p("x","z","y",1,1,e,i,t,r,o,2),p("x","z","y",1,-1,e,i,-t,r,o,3),p("x","y","z",1,-1,e,t,i,r,s,4),p("x","y","z",-1,-1,e,t,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new Le(c,3)),this.setAttribute("normal",new Le(u,3)),this.setAttribute("uv",new Le(h,2));function p(m,y,g,v,_,b,S,w,T,R,M){const P=b/T,L=S/R,$=b/2,O=S/2,I=w/2,N=T+1,V=R+1;let X=0,J=0;const W=new k;for(let Q=0;Q<V;Q++){const re=Q*L-O;for(let xe=0;xe<N;xe++){const Ae=xe*P-$;W[m]=Ae*v,W[y]=re*_,W[g]=I,c.push(W.x,W.y,W.z),W[m]=0,W[y]=0,W[g]=w>0?1:-1,u.push(W.x,W.y,W.z),h.push(xe/T),h.push(1-Q/R),X+=1}}for(let Q=0;Q<R;Q++)for(let re=0;re<T;re++){const xe=d+re+N*Q,Ae=d+re+N*(Q+1),$e=d+(re+1)+N*(Q+1),se=d+(re+1)+N*Q;l.push(xe,Ae,se),l.push(Ae,$e,se),J+=6}a.addGroup(f,J,M),f+=J,d+=X}}}function Tl(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function Vn(n){const e={};for(let t=0;t<n.length;t++){const i=Tl(n[t]);for(const r in i)e[r]=i[r]}return e}const gA={clone:Tl,merge:Vn};var QX=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,e7=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function si(n){Ye.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=QX,this.fragmentShader=e7,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,n!==void 0&&(n.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(n))}si.prototype=Object.create(Ye.prototype);si.prototype.constructor=si;si.prototype.isShaderMaterial=!0;si.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=Tl(n.uniforms),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.lights=n.lights,this.clipping=n.clipping,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this};si.prototype.toJSON=function(n){const e=Ye.prototype.toJSON.call(this,n);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const s=this.uniforms[i].value;s&&s.isTexture?e.uniforms[i]={type:"t",value:s.toJSON(n).uuid}:s&&s.isColor?e.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?e.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?e.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?e.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?e.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?e.uniforms[i]={type:"m4",value:s.toArray()}:e.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const t={};for(const i in this.extensions)this.extensions[i]===!0&&(t[i]=!0);return Object.keys(t).length>0&&(e.extensions=t),e};function Gr(){ze.call(this),this.type="Camera",this.matrixWorldInverse=new ut,this.projectionMatrix=new ut,this.projectionMatrixInverse=new ut}Gr.prototype=Object.assign(Object.create(ze.prototype),{constructor:Gr,isCamera:!0,copy:function(n,e){return ze.prototype.copy.call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),n=new k),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(n){ze.prototype.updateMatrixWorld.call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(n,e){ze.prototype.updateWorldMatrix.call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function fn(n=50,e=1,t=.1,i=2e3){Gr.call(this),this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=t,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}fn.prototype=Object.assign(Object.create(Gr.prototype),{constructor:fn,isPerspectiveCamera:!0,copy:function(n,e){return Gr.prototype.copy.call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=n.view===null?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this},setFocalLength:function(n){const e=.5*this.getFilmHeight()/n;this.fov=Ze.RAD2DEG*2*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const n=Math.tan(Ze.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/n},getEffectiveFOV:function(){return Ze.RAD2DEG*2*Math.atan(Math.tan(Ze.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(n,e,t,i,r,s){this.aspect=n/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=this.near;let e=n*Math.tan(Ze.DEG2RAD*.5*this.fov)/this.zoom,t=2*e,i=this.aspect*t,r=-.5*i;const s=this.view;if(this.view!==null&&this.view.enabled){const a=s.fullWidth,l=s.fullHeight;r+=s.offsetX*i/a,e-=s.offsetY*t/l,i*=s.width/a,t*=s.height/l}const o=this.filmOffset;o!==0&&(r+=n*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=ze.prototype.toJSON.call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const Ba=90,za=1;function sa(n,e,t){if(ze.call(this),this.type="CubeCamera",t.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=t;const i=new fn(Ba,za,n,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new k(1,0,0)),this.add(i);const r=new fn(Ba,za,n,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new k(-1,0,0)),this.add(r);const s=new fn(Ba,za,n,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new k(0,1,0)),this.add(s);const o=new fn(Ba,za,n,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new k(0,-1,0)),this.add(o);const a=new fn(Ba,za,n,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new k(0,0,1)),this.add(a);const l=new fn(Ba,za,n,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new k(0,0,-1)),this.add(l),this.update=function(c,u){this.parent===null&&this.updateMatrixWorld();const h=c.xr.enabled,d=c.getRenderTarget();c.xr.enabled=!1;const f=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,c.setRenderTarget(t,0),c.render(u,i),c.setRenderTarget(t,1),c.render(u,r),c.setRenderTarget(t,2),c.render(u,s),c.setRenderTarget(t,3),c.render(u,o),c.setRenderTarget(t,4),c.render(u,a),t.texture.generateMipmaps=f,c.setRenderTarget(t,5),c.render(u,l),c.setRenderTarget(d),c.xr.enabled=h}}sa.prototype=Object.create(ze.prototype);sa.prototype.constructor=sa;function Hr(n,e,t,i,r,s,o,a,l,c){n=n!==void 0?n:[],e=e!==void 0?e:zu,o=o!==void 0?o:js,Bt.call(this,n,e,t,i,r,s,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}Hr.prototype=Object.create(Bt.prototype);Hr.prototype.constructor=Hr;Hr.prototype.isCubeTexture=!0;Object.defineProperty(Hr.prototype,"images",{get:function(){return this.image},set:function(n){this.image=n}});class uv extends qs{constructor(e,t,i){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=i),super(e,e,t),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),t=t||{},this.texture=new Hr(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Mi,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new ra(5,5,5),s=new si({name:"CubemapFromEquirect",uniforms:Tl(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:un,blending:hs});s.uniforms.tEquirect.value=t;const o=new jt(r,s),a=t.minFilter;return t.minFilter===Kl&&(t.minFilter=Cn),new sa(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,i,r){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,r);e.setRenderTarget(s)}}function ms(n,e,t,i,r,s,o,a,l,c,u,h){Bt.call(this,null,s,o,a,l,c,i,r,u,h),this.image={data:n||null,width:e||1,height:t||1},this.magFilter=l!==void 0?l:bn,this.minFilter=c!==void 0?c:bn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}ms.prototype=Object.create(Bt.prototype);ms.prototype.constructor=ms;ms.prototype.isDataTexture=!0;const Ua=new go,Ah=new k;class Wu{constructor(e,t,i,r,s,o){this.planes=[e!==void 0?e:new $r,t!==void 0?t:new $r,i!==void 0?i:new $r,r!==void 0?r:new $r,s!==void 0?s:new $r,o!==void 0?o:new $r]}set(e,t,i,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],u=i[6],h=i[7],d=i[8],f=i[9],p=i[10],m=i[11],y=i[12],g=i[13],v=i[14],_=i[15];return t[0].setComponents(a-r,h-l,m-d,_-y).normalize(),t[1].setComponents(a+r,h+l,m+d,_+y).normalize(),t[2].setComponents(a+s,h+c,m+f,_+g).normalize(),t[3].setComponents(a-s,h-c,m-f,_-g).normalize(),t[4].setComponents(a-o,h-u,m-p,_-v).normalize(),t[5].setComponents(a+o,h+u,m+p,_+v).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Ua.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Ua)}intersectsSprite(e){return Ua.center.set(0,0,0),Ua.radius=.7071067811865476,Ua.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ua)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(Ah.x=r.normal.x>0?e.max.x:e.min.x,Ah.y=r.normal.y>0?e.max.y:e.min.y,Ah.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Ah)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}}function yA(){let n=null,e=!1,t=null,i=null;function r(s,o){t(s,o),i=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function t7(n,e){const t=e.isWebGL2,i=new WeakMap;function r(c,u){const h=c.array,d=c.usage,f=n.createBuffer();n.bindBuffer(u,f),n.bufferData(u,h,d),c.onUploadCallback();let p=5126;return h instanceof Float32Array?p=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?c.isFloat16BufferAttribute?t?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:h instanceof Int16Array?p=5122:h instanceof Uint32Array?p=5125:h instanceof Int32Array?p=5124:h instanceof Int8Array?p=5120:h instanceof Uint8Array&&(p=5121),{buffer:f,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function s(c,u,h){const d=u.array,f=u.updateRange;n.bindBuffer(h,c),f.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):n.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=i.get(c);u&&(n.deleteBuffer(u.buffer),i.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=i.get(c);h===void 0?i.set(c,r(c,u)):h.version<c.version&&(s(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class lu extends He{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(i),l=Math.floor(r),c=a+1,u=l+1,h=e/a,d=t/l,f=[],p=[],m=[],y=[];for(let g=0;g<u;g++){const v=g*d-o;for(let _=0;_<c;_++){const b=_*h-s;p.push(b,-v,0),m.push(0,0,1),y.push(_/a),y.push(1-g/l)}}for(let g=0;g<l;g++)for(let v=0;v<a;v++){const _=v+c*g,b=v+c*(g+1),S=v+1+c*(g+1),w=v+1+c*g;f.push(_,b,w),f.push(b,S,w)}this.setIndex(f),this.setAttribute("position",new Le(p,3)),this.setAttribute("normal",new Le(m,3)),this.setAttribute("uv",new Le(y,2))}}var n7=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,i7=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,r7=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,s7=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,o7=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,a7="vec3 transformed = vec3( position );",l7=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,c7=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,u7=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,h7=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,d7=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,f7=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,p7=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,m7=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,g7=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,y7=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,v7=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,x7=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,_7=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,b7=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,w7=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,S7=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,T7=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,E7=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,C7="gl_FragColor = linearToOutputTexel( gl_FragColor );",M7=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,A7=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,R7=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,I7=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,P7=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,N7=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,L7=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,D7=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,k7=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,O7=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,F7=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,$7=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,B7=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,z7=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,U7=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,V7=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,G7=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,H7=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,W7=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,j7=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,q7=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,X7=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Y7=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,K7=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,Z7=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,J7=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Q7=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,e9=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,t9=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,n9=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,i9=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,r9=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,s9=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,o9=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,a9=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,l9=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,c9=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,u9=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,h9=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,d9=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,f9=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,p9=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,m9=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,g9=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,y9=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,v9=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,x9=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,_9=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,b9=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,w9=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,S9=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,T9=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,E9=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,C9=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,M9=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,A9=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,R9=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,I9=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,P9=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,N9=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,L9=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,D9=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,k9=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,O9=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,F9=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,$9=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,B9=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,z9=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,U9=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,V9=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,G9=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,H9=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,W9=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,j9=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,q9=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,X9=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Y9=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,K9=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Z9=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,J9=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Q9=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,eY=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,tY=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,nY=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,iY=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,rY=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,sY=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,oY=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,aY=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,lY=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,cY=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,uY=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,hY=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dY=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fY=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,pY=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,mY=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,gY=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,yY=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vY=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,xY=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,_Y=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,bY=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,wY=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const dt={alphamap_fragment:n7,alphamap_pars_fragment:i7,alphatest_fragment:r7,aomap_fragment:s7,aomap_pars_fragment:o7,begin_vertex:a7,beginnormal_vertex:l7,bsdfs:c7,bumpmap_pars_fragment:u7,clipping_planes_fragment:h7,clipping_planes_pars_fragment:d7,clipping_planes_pars_vertex:f7,clipping_planes_vertex:p7,color_fragment:m7,color_pars_fragment:g7,color_pars_vertex:y7,color_vertex:v7,common:x7,cube_uv_reflection_fragment:_7,defaultnormal_vertex:b7,displacementmap_pars_vertex:w7,displacementmap_vertex:S7,emissivemap_fragment:T7,emissivemap_pars_fragment:E7,encodings_fragment:C7,encodings_pars_fragment:M7,envmap_fragment:A7,envmap_common_pars_fragment:R7,envmap_pars_fragment:I7,envmap_pars_vertex:P7,envmap_physical_pars_fragment:V7,envmap_vertex:N7,fog_vertex:L7,fog_pars_vertex:D7,fog_fragment:k7,fog_pars_fragment:O7,gradientmap_pars_fragment:F7,lightmap_fragment:$7,lightmap_pars_fragment:B7,lights_lambert_vertex:z7,lights_pars_begin:U7,lights_toon_fragment:G7,lights_toon_pars_fragment:H7,lights_phong_fragment:W7,lights_phong_pars_fragment:j7,lights_physical_fragment:q7,lights_physical_pars_fragment:X7,lights_fragment_begin:Y7,lights_fragment_maps:K7,lights_fragment_end:Z7,logdepthbuf_fragment:J7,logdepthbuf_pars_fragment:Q7,logdepthbuf_pars_vertex:e9,logdepthbuf_vertex:t9,map_fragment:n9,map_pars_fragment:i9,map_particle_fragment:r9,map_particle_pars_fragment:s9,metalnessmap_fragment:o9,metalnessmap_pars_fragment:a9,morphnormal_vertex:l9,morphtarget_pars_vertex:c9,morphtarget_vertex:u9,normal_fragment_begin:h9,normal_fragment_maps:d9,normalmap_pars_fragment:f9,clearcoat_normal_fragment_begin:p9,clearcoat_normal_fragment_maps:m9,clearcoat_pars_fragment:g9,packing:y9,premultiplied_alpha_fragment:v9,project_vertex:x9,dithering_fragment:_9,dithering_pars_fragment:b9,roughnessmap_fragment:w9,roughnessmap_pars_fragment:S9,shadowmap_pars_fragment:T9,shadowmap_pars_vertex:E9,shadowmap_vertex:C9,shadowmask_pars_fragment:M9,skinbase_vertex:A9,skinning_pars_vertex:R9,skinning_vertex:I9,skinnormal_vertex:P9,specularmap_fragment:N9,specularmap_pars_fragment:L9,tonemapping_fragment:D9,tonemapping_pars_fragment:k9,transmissionmap_fragment:O9,transmissionmap_pars_fragment:F9,uv_pars_fragment:$9,uv_pars_vertex:B9,uv_vertex:z9,uv2_pars_fragment:U9,uv2_pars_vertex:V9,uv2_vertex:G9,worldpos_vertex:H9,background_frag:W9,background_vert:j9,cube_frag:q9,cube_vert:X9,depth_frag:Y9,depth_vert:K9,distanceRGBA_frag:Z9,distanceRGBA_vert:J9,equirect_frag:Q9,equirect_vert:eY,linedashed_frag:tY,linedashed_vert:nY,meshbasic_frag:iY,meshbasic_vert:rY,meshlambert_frag:sY,meshlambert_vert:oY,meshmatcap_frag:aY,meshmatcap_vert:lY,meshtoon_frag:cY,meshtoon_vert:uY,meshphong_frag:hY,meshphong_vert:dY,meshphysical_frag:fY,meshphysical_vert:pY,normal_frag:mY,normal_vert:gY,points_frag:yY,points_vert:vY,shadow_frag:xY,shadow_vert:_Y,sprite_frag:bY,sprite_vert:wY},Ee={common:{diffuse:{value:new Ne(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ei},uv2Transform:{value:new Ei},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new fe(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ne(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ne(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Ei}},sprite:{diffuse:{value:new Ne(15658734)},opacity:{value:1},center:{value:new fe(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Ei}}},yr={basic:{uniforms:Vn([Ee.common,Ee.specularmap,Ee.envmap,Ee.aomap,Ee.lightmap,Ee.fog]),vertexShader:dt.meshbasic_vert,fragmentShader:dt.meshbasic_frag},lambert:{uniforms:Vn([Ee.common,Ee.specularmap,Ee.envmap,Ee.aomap,Ee.lightmap,Ee.emissivemap,Ee.fog,Ee.lights,{emissive:{value:new Ne(0)}}]),vertexShader:dt.meshlambert_vert,fragmentShader:dt.meshlambert_frag},phong:{uniforms:Vn([Ee.common,Ee.specularmap,Ee.envmap,Ee.aomap,Ee.lightmap,Ee.emissivemap,Ee.bumpmap,Ee.normalmap,Ee.displacementmap,Ee.fog,Ee.lights,{emissive:{value:new Ne(0)},specular:{value:new Ne(1118481)},shininess:{value:30}}]),vertexShader:dt.meshphong_vert,fragmentShader:dt.meshphong_frag},standard:{uniforms:Vn([Ee.common,Ee.envmap,Ee.aomap,Ee.lightmap,Ee.emissivemap,Ee.bumpmap,Ee.normalmap,Ee.displacementmap,Ee.roughnessmap,Ee.metalnessmap,Ee.fog,Ee.lights,{emissive:{value:new Ne(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:dt.meshphysical_vert,fragmentShader:dt.meshphysical_frag},toon:{uniforms:Vn([Ee.common,Ee.aomap,Ee.lightmap,Ee.emissivemap,Ee.bumpmap,Ee.normalmap,Ee.displacementmap,Ee.gradientmap,Ee.fog,Ee.lights,{emissive:{value:new Ne(0)}}]),vertexShader:dt.meshtoon_vert,fragmentShader:dt.meshtoon_frag},matcap:{uniforms:Vn([Ee.common,Ee.bumpmap,Ee.normalmap,Ee.displacementmap,Ee.fog,{matcap:{value:null}}]),vertexShader:dt.meshmatcap_vert,fragmentShader:dt.meshmatcap_frag},points:{uniforms:Vn([Ee.points,Ee.fog]),vertexShader:dt.points_vert,fragmentShader:dt.points_frag},dashed:{uniforms:Vn([Ee.common,Ee.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:dt.linedashed_vert,fragmentShader:dt.linedashed_frag},depth:{uniforms:Vn([Ee.common,Ee.displacementmap]),vertexShader:dt.depth_vert,fragmentShader:dt.depth_frag},normal:{uniforms:Vn([Ee.common,Ee.bumpmap,Ee.normalmap,Ee.displacementmap,{opacity:{value:1}}]),vertexShader:dt.normal_vert,fragmentShader:dt.normal_frag},sprite:{uniforms:Vn([Ee.sprite,Ee.fog]),vertexShader:dt.sprite_vert,fragmentShader:dt.sprite_frag},background:{uniforms:{uvTransform:{value:new Ei},t2D:{value:null}},vertexShader:dt.background_vert,fragmentShader:dt.background_frag},cube:{uniforms:Vn([Ee.envmap,{opacity:{value:1}}]),vertexShader:dt.cube_vert,fragmentShader:dt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:dt.equirect_vert,fragmentShader:dt.equirect_frag},distanceRGBA:{uniforms:Vn([Ee.common,Ee.displacementmap,{referencePosition:{value:new k},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:dt.distanceRGBA_vert,fragmentShader:dt.distanceRGBA_frag},shadow:{uniforms:Vn([Ee.lights,Ee.fog,{color:{value:new Ne(0)},opacity:{value:1}}]),vertexShader:dt.shadow_vert,fragmentShader:dt.shadow_frag}};yr.physical={uniforms:Vn([yr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new fe(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Ne(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:dt.meshphysical_vert,fragmentShader:dt.meshphysical_frag};function SY(n,e,t,i,r){const s=new Ne(0);let o=0,a,l,c=null,u=0,h=null;function d(p,m,y,g){let v=m.isScene===!0?m.background:null;v&&v.isTexture&&(v=e.get(v));const _=n.xr,b=_.getSession&&_.getSession();b&&b.environmentBlendMode==="additive"&&(v=null),v===null?f(s,o):v&&v.isColor&&(f(v,1),g=!0),(n.autoClear||g)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),v&&(v.isCubeTexture||v.isWebGLCubeRenderTarget||v.mapping===Yl)?(l===void 0&&(l=new jt(new ra(1,1,1),new si({name:"BackgroundCubeMaterial",uniforms:Tl(yr.cube.uniforms),vertexShader:yr.cube.vertexShader,fragmentShader:yr.cube.fragmentShader,side:un,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,w,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(l)),v.isWebGLCubeRenderTarget&&(v=v.texture),l.material.uniforms.envMap.value=v,l.material.uniforms.flipEnvMap.value=v.isCubeTexture&&v._needsFlipEnvMap?-1:1,(c!==v||u!==v.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,c=v,u=v.version,h=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):v&&v.isTexture&&(a===void 0&&(a=new jt(new lu(2,2),new si({name:"BackgroundMaterial",uniforms:Tl(yr.background.uniforms),vertexShader:yr.background.vertexShader,fragmentShader:yr.background.fragmentShader,side:Xl,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=v,v.matrixAutoUpdate===!0&&v.updateMatrix(),a.material.uniforms.uvTransform.value.copy(v.matrix),(c!==v||u!==v.version||h!==n.toneMapping)&&(a.material.needsUpdate=!0,c=v,u=v.version,h=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function f(p,m){t.buffers.color.setClear(p.r,p.g,p.b,m,r)}return{getClearColor:function(){return s},setClearColor:function(p,m=1){s.set(p),o=m,f(s,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,f(s,o)},render:d}}function TY(n,e,t,i){const r=n.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||s!==null,a={},l=m(null);let c=l;function u(O,I,N,V,X){let J=!1;if(o){const W=p(V,N,I);c!==W&&(c=W,d(c.object)),J=y(V,X),J&&g(V,X)}else{const W=I.wireframe===!0;(c.geometry!==V.id||c.program!==N.id||c.wireframe!==W)&&(c.geometry=V.id,c.program=N.id,c.wireframe=W,J=!0)}O.isInstancedMesh===!0&&(J=!0),X!==null&&t.update(X,34963),J&&(T(O,I,N,V),X!==null&&n.bindBuffer(34963,t.get(X).buffer))}function h(){return i.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function d(O){return i.isWebGL2?n.bindVertexArray(O):s.bindVertexArrayOES(O)}function f(O){return i.isWebGL2?n.deleteVertexArray(O):s.deleteVertexArrayOES(O)}function p(O,I,N){const V=N.wireframe===!0;let X=a[O.id];X===void 0&&(X={},a[O.id]=X);let J=X[I.id];J===void 0&&(J={},X[I.id]=J);let W=J[V];return W===void 0&&(W=m(h()),J[V]=W),W}function m(O){const I=[],N=[],V=[];for(let X=0;X<r;X++)I[X]=0,N[X]=0,V[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:I,enabledAttributes:N,attributeDivisors:V,object:O,attributes:{},index:null}}function y(O,I){const N=c.attributes,V=O.attributes;let X=0;for(const J in V){const W=N[J],Q=V[J];if(W===void 0||W.attribute!==Q||W.data!==Q.data)return!0;X++}return c.attributesNum!==X||c.index!==I}function g(O,I){const N={},V=O.attributes;let X=0;for(const J in V){const W=V[J],Q={};Q.attribute=W,W.data&&(Q.data=W.data),N[J]=Q,X++}c.attributes=N,c.attributesNum=X,c.index=I}function v(){const O=c.newAttributes;for(let I=0,N=O.length;I<N;I++)O[I]=0}function _(O){b(O,0)}function b(O,I){const N=c.newAttributes,V=c.enabledAttributes,X=c.attributeDivisors;N[O]=1,V[O]===0&&(n.enableVertexAttribArray(O),V[O]=1),X[O]!==I&&((i.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](O,I),X[O]=I)}function S(){const O=c.newAttributes,I=c.enabledAttributes;for(let N=0,V=I.length;N<V;N++)I[N]!==O[N]&&(n.disableVertexAttribArray(N),I[N]=0)}function w(O,I,N,V,X,J){i.isWebGL2===!0&&(N===5124||N===5125)?n.vertexAttribIPointer(O,I,N,X,J):n.vertexAttribPointer(O,I,N,V,X,J)}function T(O,I,N,V){if(i.isWebGL2===!1&&(O.isInstancedMesh||V.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;v();const X=V.attributes,J=N.getAttributes(),W=I.defaultAttributeValues;for(const Q in J){const re=J[Q];if(re>=0){const xe=X[Q];if(xe!==void 0){const Ae=xe.normalized,$e=xe.itemSize,se=t.get(xe);if(se===void 0)continue;const ht=se.buffer,Ie=se.type,at=se.bytesPerElement;if(xe.isInterleavedBufferAttribute){const je=xe.data,it=je.stride,qe=xe.offset;je&&je.isInstancedInterleavedBuffer?(b(re,je.meshPerAttribute),V._maxInstanceCount===void 0&&(V._maxInstanceCount=je.meshPerAttribute*je.count)):_(re),n.bindBuffer(34962,ht),w(re,$e,Ie,Ae,it*at,qe*at)}else xe.isInstancedBufferAttribute?(b(re,xe.meshPerAttribute),V._maxInstanceCount===void 0&&(V._maxInstanceCount=xe.meshPerAttribute*xe.count)):_(re),n.bindBuffer(34962,ht),w(re,$e,Ie,Ae,0,0)}else if(Q==="instanceMatrix"){const Ae=t.get(O.instanceMatrix);if(Ae===void 0)continue;const $e=Ae.buffer,se=Ae.type;b(re+0,1),b(re+1,1),b(re+2,1),b(re+3,1),n.bindBuffer(34962,$e),n.vertexAttribPointer(re+0,4,se,!1,64,0),n.vertexAttribPointer(re+1,4,se,!1,64,16),n.vertexAttribPointer(re+2,4,se,!1,64,32),n.vertexAttribPointer(re+3,4,se,!1,64,48)}else if(Q==="instanceColor"){const Ae=t.get(O.instanceColor);if(Ae===void 0)continue;const $e=Ae.buffer,se=Ae.type;b(re,1),n.bindBuffer(34962,$e),n.vertexAttribPointer(re,3,se,!1,12,0)}else if(W!==void 0){const Ae=W[Q];if(Ae!==void 0)switch(Ae.length){case 2:n.vertexAttrib2fv(re,Ae);break;case 3:n.vertexAttrib3fv(re,Ae);break;case 4:n.vertexAttrib4fv(re,Ae);break;default:n.vertexAttrib1fv(re,Ae)}}}}S()}function R(){L();for(const O in a){const I=a[O];for(const N in I){const V=I[N];for(const X in V)f(V[X].object),delete V[X];delete I[N]}delete a[O]}}function M(O){if(a[O.id]===void 0)return;const I=a[O.id];for(const N in I){const V=I[N];for(const X in V)f(V[X].object),delete V[X];delete I[N]}delete a[O.id]}function P(O){for(const I in a){const N=a[I];if(N[O.id]===void 0)continue;const V=N[O.id];for(const X in V)f(V[X].object),delete V[X];delete N[O.id]}}function L(){$(),c!==l&&(c=l,d(c.object))}function $(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:L,resetDefaultState:$,dispose:R,releaseStatesOfGeometry:M,releaseStatesOfProgram:P,initAttributes:v,enableAttribute:_,disableUnusedAttributes:S}}function EY(n,e,t,i){const r=i.isWebGL2;let s;function o(c){s=c}function a(c,u){n.drawArrays(s,c,u),t.update(u,s,1)}function l(c,u,h){if(h===0)return;let d,f;if(r)d=n,f="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](s,c,u,h),t.update(u,s,h)}this.setMode=o,this.render=a,this.renderInstances=l}function CY(n,e,t){let i;function r(){if(i!==void 0)return i;const w=e.get("EXT_texture_filter_anisotropic");return w!==null?i=n.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT):i=0,i}function s(w){if(w==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";w="mediump"}return w==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=t.logarithmicDepthBuffer===!0,u=n.getParameter(34930),h=n.getParameter(35660),d=n.getParameter(3379),f=n.getParameter(34076),p=n.getParameter(34921),m=n.getParameter(36347),y=n.getParameter(36348),g=n.getParameter(36349),v=h>0,_=o||!!e.get("OES_texture_float"),b=v&&_,S=o?n.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:d,maxCubemapSize:f,maxAttributes:p,maxVertexUniforms:m,maxVaryings:y,maxFragmentUniforms:g,vertexTextures:v,floatFragmentTextures:_,floatVertexTextures:b,maxSamples:S}}function MY(n){const e=this;let t=null,i=0,r=!1,s=!1;const o=new $r,a=new Ei,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,f){const p=h.length!==0||d||i!==0||r;return r=d,t=u(h,f,0),i=h.length,p},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(h,d,f){const p=h.clippingPlanes,m=h.clipIntersection,y=h.clipShadows,g=n.get(h);if(!r||p===null||p.length===0||s&&!y)s?u(null):c();else{const v=s?0:i,_=v*4;let b=g.clippingState||null;l.value=b,b=u(p,d,_,f);for(let S=0;S!==_;++S)b[S]=t[S];g.clippingState=b,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=v}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function u(h,d,f,p){const m=h!==null?h.length:0;let y=null;if(m!==0){if(y=l.value,p!==!0||y===null){const g=f+m*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(y===null||y.length<g)&&(y=new Float32Array(g));for(let _=0,b=f;_!==m;++_,b+=4)o.copy(h[_]).applyMatrix4(v,a),o.normal.toArray(y,b),y[b+3]=o.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,y}}function AY(n){let e=new WeakMap;function t(o,a){return a===Od?o.mapping=zu:a===Fd&&(o.mapping=Uu),o}function i(o){if(o&&o.isTexture){const a=o.mapping;if(a===Od||a===Fd)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderList(),u=n.getRenderTarget(),h=new uv(l.height/2);return h.fromEquirectangularTexture(n,o),e.set(o,h),n.setRenderTarget(u),n.setRenderList(c),o.addEventListener("dispose",r),t(h.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:i,dispose:s}}function RY(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return e[i]=r,r}return{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(i){const r=t(i);return r===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function IY(n,e,t,i){const r={},s=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const p in d.attributes)e.remove(d.attributes[p]);d.removeEventListener("dispose",o),delete r[d.id];const f=s.get(d);f&&(e.remove(f),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const p in d)e.update(d[p],34962);const f=h.morphAttributes;for(const p in f){const m=f[p];for(let y=0,g=m.length;y<g;y++)e.update(m[y],34962)}}function c(h){const d=[],f=h.index,p=h.attributes.position;let m=0;if(f!==null){const v=f.array;m=f.version;for(let _=0,b=v.length;_<b;_+=3){const S=v[_+0],w=v[_+1],T=v[_+2];d.push(S,w,w,T,T,S)}}else{const v=p.array;m=p.version;for(let _=0,b=v.length/3-1;_<b;_+=3){const S=_+0,w=_+1,T=_+2;d.push(S,w,w,T,T,S)}}const y=new(mA(d)>65535?ia:na)(d,1);y.version=m;const g=s.get(h);g&&e.remove(g),s.set(h,y)}function u(h){const d=s.get(h);if(d){const f=h.index;f!==null&&d.version<f.version&&c(h)}else c(h);return s.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function PY(n,e,t,i){const r=i.isWebGL2;let s;function o(d){s=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function u(d,f){n.drawElements(s,f,a,d*l),t.update(f,s,1)}function h(d,f,p){if(p===0)return;let m,y;if(r)m=n,y="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[y](s,f,a,d*l,p),t.update(f,s,p)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function NY(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(s/3);break;case 1:t.lines+=a*(s/2);break;case 3:t.lines+=a*(s-1);break;case 2:t.lines+=a*s;break;case 0:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:i}}function LY(n,e){return n[0]-e[0]}function DY(n,e){return Math.abs(e[1])-Math.abs(n[1])}function kY(n){const e={},t=new Float32Array(8),i=[];for(let s=0;s<8;s++)i[s]=[s,0];function r(s,o,a,l){const c=s.morphTargetInfluences,u=c===void 0?0:c.length;let h=e[o.id];if(h===void 0){h=[];for(let y=0;y<u;y++)h[y]=[y,0];e[o.id]=h}for(let y=0;y<u;y++){const g=h[y];g[0]=y,g[1]=c[y]}h.sort(DY);for(let y=0;y<8;y++)y<u&&h[y][1]?(i[y][0]=h[y][0],i[y][1]=h[y][1]):(i[y][0]=Number.MAX_SAFE_INTEGER,i[y][1]=0);i.sort(LY);const d=a.morphTargets&&o.morphAttributes.position,f=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let y=0;y<8;y++){const g=i[y],v=g[0],_=g[1];v!==Number.MAX_SAFE_INTEGER&&_?(d&&o.getAttribute("morphTarget"+y)!==d[v]&&o.setAttribute("morphTarget"+y,d[v]),f&&o.getAttribute("morphNormal"+y)!==f[v]&&o.setAttribute("morphNormal"+y,f[v]),t[y]=_,p+=_):(d&&o.hasAttribute("morphTarget"+y)===!0&&o.deleteAttribute("morphTarget"+y),f&&o.hasAttribute("morphNormal"+y)===!0&&o.deleteAttribute("morphNormal"+y),t[y]=0)}const m=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",m),l.getUniforms().setValue(n,"morphTargetInfluences",t)}return{update:r}}function OY(n,e,t,i){let r=new WeakMap;function s(l){const c=i.render.frame,u=l.geometry,h=e.get(l,u);return r.get(h)!==c&&(e.update(h),r.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}function El(n=null,e=1,t=1,i=1){Bt.call(this,null),this.image={data:n,width:e,height:t,depth:i},this.magFilter=bn,this.minFilter=bn,this.wrapR=ii,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}El.prototype=Object.create(Bt.prototype);El.prototype.constructor=El;El.prototype.isDataTexture2DArray=!0;function Cl(n=null,e=1,t=1,i=1){Bt.call(this,null),this.image={data:n,width:e,height:t,depth:i},this.magFilter=bn,this.minFilter=bn,this.wrapR=ii,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}Cl.prototype=Object.create(Bt.prototype);Cl.prototype.constructor=Cl;Cl.prototype.isDataTexture3D=!0;const vA=new Bt,FY=new El,$Y=new Cl,xA=new Hr,r_=[],s_=[],o_=new Float32Array(16),a_=new Float32Array(9),l_=new Float32Array(4);function ec(n,e,t){const i=n[0];if(i<=0||i>0)return n;const r=e*t;let s=r_[r];if(s===void 0&&(s=new Float32Array(r),r_[r]=s),e!==0){i.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function Ki(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function Ii(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function _A(n,e){let t=s_[e];t===void 0&&(t=new Int32Array(e),s_[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function BY(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function zY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ki(t,e))return;n.uniform2fv(this.addr,e),Ii(t,e)}}function UY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Ki(t,e))return;n.uniform3fv(this.addr,e),Ii(t,e)}}function VY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ki(t,e))return;n.uniform4fv(this.addr,e),Ii(t,e)}}function GY(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Ki(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ii(t,e)}else{if(Ki(t,i))return;l_.set(i),n.uniformMatrix2fv(this.addr,!1,l_),Ii(t,i)}}function HY(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Ki(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ii(t,e)}else{if(Ki(t,i))return;a_.set(i),n.uniformMatrix3fv(this.addr,!1,a_),Ii(t,i)}}function WY(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Ki(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ii(t,e)}else{if(Ki(t,i))return;o_.set(i),n.uniformMatrix4fv(this.addr,!1,o_),Ii(t,i)}}function jY(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.safeSetTexture2D(e||vA,r)}function qY(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(e||FY,r)}function XY(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(e||$Y,r)}function YY(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.safeSetTextureCube(e||xA,r)}function KY(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function ZY(n,e){const t=this.cache;Ki(t,e)||(n.uniform2iv(this.addr,e),Ii(t,e))}function JY(n,e){const t=this.cache;Ki(t,e)||(n.uniform3iv(this.addr,e),Ii(t,e))}function QY(n,e){const t=this.cache;Ki(t,e)||(n.uniform4iv(this.addr,e),Ii(t,e))}function eK(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function tK(n){switch(n){case 5126:return BY;case 35664:return zY;case 35665:return UY;case 35666:return VY;case 35674:return GY;case 35675:return HY;case 35676:return WY;case 5124:case 35670:return KY;case 35667:case 35671:return ZY;case 35668:case 35672:return JY;case 35669:case 35673:return QY;case 5125:return eK;case 35678:case 36198:case 36298:case 36306:case 35682:return jY;case 35679:case 36299:case 36307:return XY;case 35680:case 36300:case 36308:case 36293:return YY;case 36289:case 36303:case 36311:case 36292:return qY}}function nK(n,e){n.uniform1fv(this.addr,e)}function iK(n,e){n.uniform1iv(this.addr,e)}function rK(n,e){n.uniform2iv(this.addr,e)}function sK(n,e){n.uniform3iv(this.addr,e)}function oK(n,e){n.uniform4iv(this.addr,e)}function aK(n,e){const t=ec(e,this.size,2);n.uniform2fv(this.addr,t)}function lK(n,e){const t=ec(e,this.size,3);n.uniform3fv(this.addr,t)}function cK(n,e){const t=ec(e,this.size,4);n.uniform4fv(this.addr,t)}function uK(n,e){const t=ec(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function hK(n,e){const t=ec(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function dK(n,e){const t=ec(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function fK(n,e,t){const i=e.length,r=_A(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.safeSetTexture2D(e[s]||vA,r[s])}function pK(n,e,t){const i=e.length,r=_A(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.safeSetTextureCube(e[s]||xA,r[s])}function mK(n){switch(n){case 5126:return nK;case 35664:return aK;case 35665:return lK;case 35666:return cK;case 35674:return uK;case 35675:return hK;case 35676:return dK;case 5124:case 35670:return iK;case 35667:case 35671:return rK;case 35668:case 35672:return sK;case 35669:case 35673:return oK;case 35678:case 36198:case 36298:case 36306:case 35682:return fK;case 35680:case 36300:case 36308:case 36293:return pK}}function gK(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=tK(e.type)}function bA(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=mK(e.type)}bA.prototype.updateCache=function(n){const e=this.cache;n instanceof Float32Array&&e.length!==n.length&&(this.cache=new Float32Array(n.length)),Ii(e,n)};function wA(n){this.id=n,this.seq=[],this.map={}}wA.prototype.setValue=function(n,e,t){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const o=i[r];o.setValue(n,e[o.id],t)}};const Zp=/(\w+)(\])?(\[|\.)?/g;function c_(n,e){n.seq.push(e),n.map[e.id]=e}function yK(n,e,t){const i=n.name,r=i.length;for(Zp.lastIndex=0;;){const s=Zp.exec(i),o=Zp.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){c_(t,c===void 0?new gK(a,n,e):new bA(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new wA(a),c_(t,h)),t=h}}}function Xs(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let i=0;i<t;++i){const r=n.getActiveUniform(e,i),s=n.getUniformLocation(e,r.name);yK(r,s,this)}}Xs.prototype.setValue=function(n,e,t,i){const r=this.map[e];r!==void 0&&r.setValue(n,t,i)};Xs.prototype.setOptional=function(n,e,t){const i=e[t];i!==void 0&&this.setValue(n,t,i)};Xs.upload=function(n,e,t,i){for(let r=0,s=e.length;r!==s;++r){const o=e[r],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,i)}};Xs.seqWithValue=function(n,e){const t=[];for(let i=0,r=n.length;i!==r;++i){const s=n[i];s.id in e&&t.push(s)}return t};function u_(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}let vK=0;function xK(n){const e=n.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function SA(n){switch(n){case ri:return["Linear","( value )"];case Gu:return["sRGB","( value )"];case jf:return["RGBE","( value )"];case sv:return["RGBM","( value, 7.0 )"];case ov:return["RGBM","( value, 16.0 )"];case av:return["RGBD","( value, 256.0 )"];case Wf:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case cA:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function h_(n,e,t){const i=n.getShaderParameter(e,35713),r=n.getShaderInfoLog(e).trim();if(i&&r==="")return"";const s=n.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+r+xK(s)}function fc(n,e){const t=SA(e);return"vec4 "+n+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function _K(n,e){const t=SA(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function bK(n,e){let t;switch(e){case l2:t="Linear";break;case c2:t="Reinhard";break;case u2:t="OptimizedCineon";break;case h2:t="ACESFilmic";break;case d2:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function wK(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Cc).join(`
`)}function SK(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function TK(n,e){const t={},i=n.getProgramParameter(e,35721);for(let r=0;r<i;r++){const o=n.getActiveAttrib(e,r).name;t[o]=n.getAttribLocation(e,o)}return t}function Cc(n){return n!==""}function d_(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function f_(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const EK=/^[ \t]*#include +<([\w\d./]+)>/gm;function Gg(n){return n.replace(EK,CK)}function CK(n,e){const t=dt[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Gg(t)}const MK=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,AK=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function p_(n){return n.replace(AK,TA).replace(MK,RK)}function RK(n,e,t,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),TA(n,e,t,i)}function TA(n,e,t,i){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function m_(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function IK(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===Qy?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===zM?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===rl&&(e="SHADOWMAP_TYPE_VSM"),e}function PK(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case zu:case Uu:e="ENVMAP_TYPE_CUBE";break;case Yl:case Vu:e="ENVMAP_TYPE_CUBE_UV";break}return e}function NK(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Uu:case Vu:e="ENVMAP_MODE_REFRACTION";break}return e}function LK(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Bu:e="ENVMAP_BLENDING_MULTIPLY";break;case o2:e="ENVMAP_BLENDING_MIX";break;case a2:e="ENVMAP_BLENDING_ADD";break}return e}function DK(n,e,t,i){const r=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=IK(t),c=PK(t),u=NK(t),h=LK(t),d=n.gammaFactor>0?n.gammaFactor:1,f=t.isWebGL2?"":wK(t),p=SK(s),m=r.createProgram();let y,g,v=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=[p].filter(Cc).join(`
`),y.length>0&&(y+=`
`),g=[f,p].filter(Cc).join(`
`),g.length>0&&(g+=`
`)):(y=[m_(t),"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Cc).join(`
`),g=[f,m_(t),"#define SHADER_NAME "+t.shaderName,p,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==qo?"#define TONE_MAPPING":"",t.toneMapping!==qo?dt.tonemapping_pars_fragment:"",t.toneMapping!==qo?bK("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",dt.encodings_pars_fragment,t.map?fc("mapTexelToLinear",t.mapEncoding):"",t.matcap?fc("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?fc("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?fc("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?fc("lightMapTexelToLinear",t.lightMapEncoding):"",_K("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Cc).join(`
`)),o=Gg(o),o=d_(o,t),o=f_(o,t),a=Gg(a),a=d_(a,t),a=f_(a,t),o=p_(o),a=p_(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,y=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,g=["#define varying in",t.glslVersion===Vg?"":"out highp vec4 pc_fragColor;",t.glslVersion===Vg?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const _=v+y+o,b=v+g+a,S=u_(r,35633,_),w=u_(r,35632,b);if(r.attachShader(m,S),r.attachShader(m,w),t.index0AttributeName!==void 0?r.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),n.debug.checkShaderErrors){const M=r.getProgramInfoLog(m).trim(),P=r.getShaderInfoLog(S).trim(),L=r.getShaderInfoLog(w).trim();let $=!0,O=!0;if(r.getProgramParameter(m,35714)===!1){$=!1;const I=h_(r,S,"vertex"),N=h_(r,w,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(m,35715),"gl.getProgramInfoLog",M,I,N)}else M!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",M):(P===""||L==="")&&(O=!1);O&&(this.diagnostics={runnable:$,programLog:M,vertexShader:{log:P,prefix:y},fragmentShader:{log:L,prefix:g}})}r.deleteShader(S),r.deleteShader(w);let T;this.getUniforms=function(){return T===void 0&&(T=new Xs(r,m)),T};let R;return this.getAttributes=function(){return R===void 0&&(R=TK(r,m)),R},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=vK++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=w,this}function kK(n,e,t,i,r,s){const o=[],a=i.isWebGL2,l=i.logarithmicDepthBuffer,c=i.floatVertexTextures,u=i.maxVertexUniforms,h=i.vertexTextures;let d=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(w){const R=w.skeleton.bones;if(c)return 1024;{const P=Math.floor((u-20)/4),L=Math.min(P,R.length);return L<R.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+R.length+" bones. This GPU supports "+L+"."),0):L}}function y(w){let T;return w&&w.isTexture?T=w.encoding:w&&w.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),T=w.texture.encoding):T=ri,T}function g(w,T,R,M,P){const L=M.fog,$=w.isMeshStandardMaterial?M.environment:null,O=e.get(w.envMap||$),I=f[w.type],N=P.isSkinnedMesh?m(P):0;w.precision!==null&&(d=i.getMaxPrecision(w.precision),d!==w.precision&&console.warn("THREE.WebGLProgram.getParameters:",w.precision,"not supported, using",d,"instead."));let V,X;if(I){const Q=yr[I];V=Q.vertexShader,X=Q.fragmentShader}else V=w.vertexShader,X=w.fragmentShader;const J=n.getRenderTarget();return{isWebGL2:a,shaderID:I,shaderName:w.type,vertexShader:V,fragmentShader:X,defines:w.defines,isRawShaderMaterial:w.isRawShaderMaterial===!0,glslVersion:w.glslVersion,precision:d,instancing:P.isInstancedMesh===!0,instancingColor:P.isInstancedMesh===!0&&P.instanceColor!==null,supportsVertexTextures:h,outputEncoding:J!==null?y(J.texture):n.outputEncoding,map:!!w.map,mapEncoding:y(w.map),matcap:!!w.matcap,matcapEncoding:y(w.matcap),envMap:!!O,envMapMode:O&&O.mapping,envMapEncoding:y(O),envMapCubeUV:!!O&&(O.mapping===Yl||O.mapping===Vu),lightMap:!!w.lightMap,lightMapEncoding:y(w.lightMap),aoMap:!!w.aoMap,emissiveMap:!!w.emissiveMap,emissiveMapEncoding:y(w.emissiveMap),bumpMap:!!w.bumpMap,normalMap:!!w.normalMap,objectSpaceNormalMap:w.normalMapType===dA,tangentSpaceNormalMap:w.normalMapType===wa,clearcoatMap:!!w.clearcoatMap,clearcoatRoughnessMap:!!w.clearcoatRoughnessMap,clearcoatNormalMap:!!w.clearcoatNormalMap,displacementMap:!!w.displacementMap,roughnessMap:!!w.roughnessMap,metalnessMap:!!w.metalnessMap,specularMap:!!w.specularMap,alphaMap:!!w.alphaMap,gradientMap:!!w.gradientMap,sheen:!!w.sheen,transmissionMap:!!w.transmissionMap,combine:w.combine,vertexTangents:w.normalMap&&w.vertexTangents,vertexColors:w.vertexColors,vertexUvs:!!w.map||!!w.bumpMap||!!w.normalMap||!!w.specularMap||!!w.alphaMap||!!w.emissiveMap||!!w.roughnessMap||!!w.metalnessMap||!!w.clearcoatMap||!!w.clearcoatRoughnessMap||!!w.clearcoatNormalMap||!!w.displacementMap||!!w.transmissionMap,uvsVertexOnly:!(!!w.map||!!w.bumpMap||!!w.normalMap||!!w.specularMap||!!w.alphaMap||!!w.emissiveMap||!!w.roughnessMap||!!w.metalnessMap||!!w.clearcoatNormalMap||!!w.transmissionMap)&&!!w.displacementMap,fog:!!L,useFog:w.fog,fogExp2:L&&L.isFogExp2,flatShading:w.flatShading,sizeAttenuation:w.sizeAttenuation,logarithmicDepthBuffer:l,skinning:w.skinning&&N>0,maxBones:N,useVertexTexture:c,morphTargets:w.morphTargets,morphNormals:w.morphNormals,maxMorphTargets:n.maxMorphTargets,maxMorphNormals:n.maxMorphNormals,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:w.dithering,shadowMapEnabled:n.shadowMap.enabled&&R.length>0,shadowMapType:n.shadowMap.type,toneMapping:w.toneMapped?n.toneMapping:qo,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:w.premultipliedAlpha,alphaTest:w.alphaTest,doubleSided:w.side===$u,flipSided:w.side===un,depthPacking:w.depthPacking!==void 0?w.depthPacking:!1,index0AttributeName:w.index0AttributeName,extensionDerivatives:w.extensions&&w.extensions.derivatives,extensionFragDepth:w.extensions&&w.extensions.fragDepth,extensionDrawBuffers:w.extensions&&w.extensions.drawBuffers,extensionShaderTextureLOD:w.extensions&&w.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||t.has("EXT_shader_texture_lod"),customProgramCacheKey:w.customProgramCacheKey()}}function v(w){const T=[];if(w.shaderID?T.push(w.shaderID):(T.push(w.fragmentShader),T.push(w.vertexShader)),w.defines!==void 0)for(const R in w.defines)T.push(R),T.push(w.defines[R]);if(w.isRawShaderMaterial===!1){for(let R=0;R<p.length;R++)T.push(w[p[R]]);T.push(n.outputEncoding),T.push(n.gammaFactor)}return T.push(w.customProgramCacheKey),T.join()}function _(w){const T=f[w.type];let R;if(T){const M=yr[T];R=gA.clone(M.uniforms)}else R=w.uniforms;return R}function b(w,T){let R;for(let M=0,P=o.length;M<P;M++){const L=o[M];if(L.cacheKey===T){R=L,++R.usedTimes;break}}return R===void 0&&(R=new DK(n,T,w,r),o.push(R)),R}function S(w){if(--w.usedTimes===0){const T=o.indexOf(w);o[T]=o[o.length-1],o.pop(),w.destroy()}}return{getParameters:g,getProgramCacheKey:v,getUniforms:_,acquireProgram:b,releaseProgram:S,programs:o}}function OK(){let n=new WeakMap;function e(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function t(s){n.delete(s)}function i(s,o,a){n.get(s)[o]=a}function r(){n=new WeakMap}return{get:e,remove:t,update:i,dispose:r}}function FK(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.program!==e.program?n.program.id-e.program.id:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function $K(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function g_(n){const e=[];let t=0;const i=[],r=[],s={id:-1};function o(){t=0,i.length=0,r.length=0}function a(d,f,p,m,y,g){let v=e[t];const _=n.get(p);return v===void 0?(v={id:d.id,object:d,geometry:f,material:p,program:_.program||s,groupOrder:m,renderOrder:d.renderOrder,z:y,group:g},e[t]=v):(v.id=d.id,v.object=d,v.geometry=f,v.material=p,v.program=_.program||s,v.groupOrder=m,v.renderOrder=d.renderOrder,v.z=y,v.group=g),t++,v}function l(d,f,p,m,y,g){const v=a(d,f,p,m,y,g);(p.transparent===!0?r:i).push(v)}function c(d,f,p,m,y,g){const v=a(d,f,p,m,y,g);(p.transparent===!0?r:i).unshift(v)}function u(d,f){i.length>1&&i.sort(d||FK),r.length>1&&r.sort(f||$K)}function h(){for(let d=t,f=e.length;d<f;d++){const p=e[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:i,transparent:r,init:o,push:l,unshift:c,finish:h,sort:u}}function BK(n){let e=new WeakMap;function t(r,s){const o=e.get(r);let a;return o===void 0?(a=new g_(n),e.set(r,new WeakMap),e.get(r).set(s,a)):(a=o.get(s),a===void 0&&(a=new g_(n),o.set(s,a))),a}function i(){e=new WeakMap}return{get:t,dispose:i}}function zK(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new k,color:new Ne};break;case"SpotLight":t={position:new k,direction:new k,color:new Ne,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new k,color:new Ne,distance:0,decay:0};break;case"HemisphereLight":t={direction:new k,skyColor:new Ne,groundColor:new Ne};break;case"RectAreaLight":t={color:new Ne,position:new k,halfWidth:new k,halfHeight:new k};break}return n[e.id]=t,t}}}function UK(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let VK=0;function GK(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function HK(n,e){const t=new zK,i=UK(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)r.probe.push(new k);const s=new k,o=new ut,a=new ut;function l(u){let h=0,d=0,f=0;for(let T=0;T<9;T++)r.probe[T].set(0,0,0);let p=0,m=0,y=0,g=0,v=0,_=0,b=0,S=0;u.sort(GK);for(let T=0,R=u.length;T<R;T++){const M=u[T],P=M.color,L=M.intensity,$=M.distance,O=M.shadow&&M.shadow.map?M.shadow.map.texture:null;if(M.isAmbientLight)h+=P.r*L,d+=P.g*L,f+=P.b*L;else if(M.isLightProbe)for(let I=0;I<9;I++)r.probe[I].addScaledVector(M.sh.coefficients[I],L);else if(M.isDirectionalLight){const I=t.get(M);if(I.color.copy(M.color).multiplyScalar(M.intensity),M.castShadow){const N=M.shadow,V=i.get(M);V.shadowBias=N.bias,V.shadowNormalBias=N.normalBias,V.shadowRadius=N.radius,V.shadowMapSize=N.mapSize,r.directionalShadow[p]=V,r.directionalShadowMap[p]=O,r.directionalShadowMatrix[p]=M.shadow.matrix,_++}r.directional[p]=I,p++}else if(M.isSpotLight){const I=t.get(M);if(I.position.setFromMatrixPosition(M.matrixWorld),I.color.copy(P).multiplyScalar(L),I.distance=$,I.coneCos=Math.cos(M.angle),I.penumbraCos=Math.cos(M.angle*(1-M.penumbra)),I.decay=M.decay,M.castShadow){const N=M.shadow,V=i.get(M);V.shadowBias=N.bias,V.shadowNormalBias=N.normalBias,V.shadowRadius=N.radius,V.shadowMapSize=N.mapSize,r.spotShadow[y]=V,r.spotShadowMap[y]=O,r.spotShadowMatrix[y]=M.shadow.matrix,S++}r.spot[y]=I,y++}else if(M.isRectAreaLight){const I=t.get(M);I.color.copy(P).multiplyScalar(L),I.halfWidth.set(M.width*.5,0,0),I.halfHeight.set(0,M.height*.5,0),r.rectArea[g]=I,g++}else if(M.isPointLight){const I=t.get(M);if(I.color.copy(M.color).multiplyScalar(M.intensity),I.distance=M.distance,I.decay=M.decay,M.castShadow){const N=M.shadow,V=i.get(M);V.shadowBias=N.bias,V.shadowNormalBias=N.normalBias,V.shadowRadius=N.radius,V.shadowMapSize=N.mapSize,V.shadowCameraNear=N.camera.near,V.shadowCameraFar=N.camera.far,r.pointShadow[m]=V,r.pointShadowMap[m]=O,r.pointShadowMatrix[m]=M.shadow.matrix,b++}r.point[m]=I,m++}else if(M.isHemisphereLight){const I=t.get(M);I.skyColor.copy(M.color).multiplyScalar(L),I.groundColor.copy(M.groundColor).multiplyScalar(L),r.hemi[v]=I,v++}}g>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Ee.LTC_FLOAT_1,r.rectAreaLTC2=Ee.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=Ee.LTC_HALF_1,r.rectAreaLTC2=Ee.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=h,r.ambient[1]=d,r.ambient[2]=f;const w=r.hash;(w.directionalLength!==p||w.pointLength!==m||w.spotLength!==y||w.rectAreaLength!==g||w.hemiLength!==v||w.numDirectionalShadows!==_||w.numPointShadows!==b||w.numSpotShadows!==S)&&(r.directional.length=p,r.spot.length=y,r.rectArea.length=g,r.point.length=m,r.hemi.length=v,r.directionalShadow.length=_,r.directionalShadowMap.length=_,r.pointShadow.length=b,r.pointShadowMap.length=b,r.spotShadow.length=S,r.spotShadowMap.length=S,r.directionalShadowMatrix.length=_,r.pointShadowMatrix.length=b,r.spotShadowMatrix.length=S,w.directionalLength=p,w.pointLength=m,w.spotLength=y,w.rectAreaLength=g,w.hemiLength=v,w.numDirectionalShadows=_,w.numPointShadows=b,w.numSpotShadows=S,r.version=VK++)}function c(u,h){let d=0,f=0,p=0,m=0,y=0;const g=h.matrixWorldInverse;for(let v=0,_=u.length;v<_;v++){const b=u[v];if(b.isDirectionalLight){const S=r.directional[d];S.direction.setFromMatrixPosition(b.matrixWorld),s.setFromMatrixPosition(b.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),d++}else if(b.isSpotLight){const S=r.spot[p];S.position.setFromMatrixPosition(b.matrixWorld),S.position.applyMatrix4(g),S.direction.setFromMatrixPosition(b.matrixWorld),s.setFromMatrixPosition(b.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),p++}else if(b.isRectAreaLight){const S=r.rectArea[m];S.position.setFromMatrixPosition(b.matrixWorld),S.position.applyMatrix4(g),a.identity(),o.copy(b.matrixWorld),o.premultiply(g),a.extractRotation(o),S.halfWidth.set(b.width*.5,0,0),S.halfHeight.set(0,b.height*.5,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),m++}else if(b.isPointLight){const S=r.point[f];S.position.setFromMatrixPosition(b.matrixWorld),S.position.applyMatrix4(g),f++}else if(b.isHemisphereLight){const S=r.hemi[y];S.direction.setFromMatrixPosition(b.matrixWorld),S.direction.transformDirection(g),S.direction.normalize(),y++}}}return{setup:l,setupView:c,state:r}}function y_(n,e){const t=new HK(n,e),i=[],r=[];function s(){i.length=0,r.length=0}function o(h){i.push(h)}function a(h){r.push(h)}function l(){t.setup(i)}function c(h){t.setupView(i,h)}return{init:s,state:{lightsArray:i,shadowsArray:r,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function WK(n,e){let t=new WeakMap;function i(s,o=0){let a;return t.has(s)===!1?(a=new y_(n,e),t.set(s,[]),t.get(s).push(a)):o>=t.get(s).length?(a=new y_(n,e),t.get(s).push(a)):a=t.get(s)[o],a}function r(){t=new WeakMap}return{get:i,dispose:r}}function io(n){Ye.call(this),this.type="MeshDepthMaterial",this.depthPacking=uA,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(n)}io.prototype=Object.create(Ye.prototype);io.prototype.constructor=io;io.prototype.isMeshDepthMaterial=!0;io.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.depthPacking=n.depthPacking,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this};function ro(n){Ye.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new k,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(n)}ro.prototype=Object.create(Ye.prototype);ro.prototype.constructor=ro;ro.prototype.isMeshDistanceMaterial=!0;ro.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this};var jK=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,qK=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function EA(n,e,t){let i=new Wu;const r=new fe,s=new fe,o=new kt,a=[],l=[],c={},u={0:un,1:Xl,2:$u},h=new si({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new fe},radius:{value:4}},vertexShader:qK,fragmentShader:jK}),d=h.clone();d.defines.HORIZONTAL_PASS=1;const f=new He;f.setAttribute("position",new Xe(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new jt(f,h),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Qy,this.render=function(S,w,T){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||S.length===0)return;const R=n.getRenderTarget(),M=n.getActiveCubeFace(),P=n.getActiveMipmapLevel(),L=n.state;L.setBlending(hs),L.buffers.color.setClear(1,1,1,1),L.buffers.depth.setTest(!0),L.setScissorTest(!1);for(let $=0,O=S.length;$<O;$++){const I=S[$],N=I.shadow;if(N===void 0){console.warn("THREE.WebGLShadowMap:",I,"has no shadow.");continue}if(N.autoUpdate===!1&&N.needsUpdate===!1)continue;r.copy(N.mapSize);const V=N.getFrameExtents();if(r.multiply(V),s.copy(N.mapSize),(r.x>t||r.y>t)&&(r.x>t&&(s.x=Math.floor(t/V.x),r.x=s.x*V.x,N.mapSize.x=s.x),r.y>t&&(s.y=Math.floor(t/V.y),r.y=s.y*V.y,N.mapSize.y=s.y)),N.map===null&&!N.isPointLightShadow&&this.type===rl){const J={minFilter:Cn,magFilter:Cn,format:Mi};N.map=new qs(r.x,r.y,J),N.map.texture.name=I.name+".shadowMap",N.mapPass=new qs(r.x,r.y,J),N.camera.updateProjectionMatrix()}if(N.map===null){const J={minFilter:bn,magFilter:bn,format:Mi};N.map=new qs(r.x,r.y,J),N.map.texture.name=I.name+".shadowMap",N.camera.updateProjectionMatrix()}n.setRenderTarget(N.map),n.clear();const X=N.getViewportCount();for(let J=0;J<X;J++){const W=N.getViewport(J);o.set(s.x*W.x,s.y*W.y,s.x*W.z,s.y*W.w),L.viewport(o),N.updateMatrices(I,J),i=N.getFrustum(),b(w,T,N.camera,I,this.type)}!N.isPointLightShadow&&this.type===rl&&y(N,T),N.needsUpdate=!1}m.needsUpdate=!1,n.setRenderTarget(R,M,P)};function y(S,w){const T=e.update(p);h.uniforms.shadow_pass.value=S.map.texture,h.uniforms.resolution.value=S.mapSize,h.uniforms.radius.value=S.radius,n.setRenderTarget(S.mapPass),n.clear(),n.renderBufferDirect(w,null,T,h,p,null),d.uniforms.shadow_pass.value=S.mapPass.texture,d.uniforms.resolution.value=S.mapSize,d.uniforms.radius.value=S.radius,n.setRenderTarget(S.map),n.clear(),n.renderBufferDirect(w,null,T,d,p,null)}function g(S,w,T){const R=S<<0|w<<1|T<<2;let M=a[R];return M===void 0&&(M=new io({depthPacking:hA,morphTargets:S,skinning:w}),a[R]=M),M}function v(S,w,T){const R=S<<0|w<<1|T<<2;let M=l[R];return M===void 0&&(M=new ro({morphTargets:S,skinning:w}),l[R]=M),M}function _(S,w,T,R,M,P,L){let $=null,O=g,I=S.customDepthMaterial;if(R.isPointLight===!0&&(O=v,I=S.customDistanceMaterial),I===void 0){let N=!1;T.morphTargets===!0&&(N=w.morphAttributes&&w.morphAttributes.position&&w.morphAttributes.position.length>0);let V=!1;S.isSkinnedMesh===!0&&(T.skinning===!0?V=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",S));const X=S.isInstancedMesh===!0;$=O(N,V,X)}else $=I;if(n.localClippingEnabled&&T.clipShadows===!0&&T.clippingPlanes.length!==0){const N=$.uuid,V=T.uuid;let X=c[N];X===void 0&&(X={},c[N]=X);let J=X[V];J===void 0&&(J=$.clone(),X[V]=J),$=J}return $.visible=T.visible,$.wireframe=T.wireframe,L===rl?$.side=T.shadowSide!==null?T.shadowSide:T.side:$.side=T.shadowSide!==null?T.shadowSide:u[T.side],$.clipShadows=T.clipShadows,$.clippingPlanes=T.clippingPlanes,$.clipIntersection=T.clipIntersection,$.wireframeLinewidth=T.wireframeLinewidth,$.linewidth=T.linewidth,R.isPointLight===!0&&$.isMeshDistanceMaterial===!0&&($.referencePosition.setFromMatrixPosition(R.matrixWorld),$.nearDistance=M,$.farDistance=P),$}function b(S,w,T,R,M){if(S.visible===!1)return;if(S.layers.test(w.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&M===rl)&&(!S.frustumCulled||i.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,S.matrixWorld);const $=e.update(S),O=S.material;if(Array.isArray(O)){const I=$.groups;for(let N=0,V=I.length;N<V;N++){const X=I[N],J=O[X.materialIndex];if(J&&J.visible){const W=_(S,$,J,R,T.near,T.far,M);n.renderBufferDirect(T,null,$,W,S,X)}}}else if(O.visible){const I=_(S,$,O,R,T.near,T.far,M);n.renderBufferDirect(T,null,$,I,S,null)}}const L=S.children;for(let $=0,O=L.length;$<O;$++)b(L[$],w,T,R,M)}}function XK(n,e,t){const i=t.isWebGL2;function r(){let j=!1;const pe=new kt;let Se=null;const De=new kt(0,0,0,0);return{setMask:function(ye){Se!==ye&&!j&&(n.colorMask(ye,ye,ye,ye),Se=ye)},setLocked:function(ye){j=ye},setClear:function(ye,Pe,Be,Ke,H){H===!0&&(ye*=Ke,Pe*=Ke,Be*=Ke),pe.set(ye,Pe,Be,Ke),De.equals(pe)===!1&&(n.clearColor(ye,Pe,Be,Ke),De.copy(pe))},reset:function(){j=!1,Se=null,De.set(-1,0,0,0)}}}function s(){let j=!1,pe=null,Se=null,De=null;return{setTest:function(ye){ye?Q(2929):re(2929)},setMask:function(ye){pe!==ye&&!j&&(n.depthMask(ye),pe=ye)},setFunc:function(ye){if(Se!==ye){if(ye)switch(ye){case QM:n.depthFunc(512);break;case e2:n.depthFunc(519);break;case t2:n.depthFunc(513);break;case kd:n.depthFunc(515);break;case n2:n.depthFunc(514);break;case i2:n.depthFunc(518);break;case r2:n.depthFunc(516);break;case s2:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);Se=ye}},setLocked:function(ye){j=ye},setClear:function(ye){De!==ye&&(n.clearDepth(ye),De=ye)},reset:function(){j=!1,pe=null,Se=null,De=null}}}function o(){let j=!1,pe=null,Se=null,De=null,ye=null,Pe=null,Be=null,Ke=null,H=null;return{setTest:function(ue){j||(ue?Q(2960):re(2960))},setMask:function(ue){pe!==ue&&!j&&(n.stencilMask(ue),pe=ue)},setFunc:function(ue,Je,yt){(Se!==ue||De!==Je||ye!==yt)&&(n.stencilFunc(ue,Je,yt),Se=ue,De=Je,ye=yt)},setOp:function(ue,Je,yt){(Pe!==ue||Be!==Je||Ke!==yt)&&(n.stencilOp(ue,Je,yt),Pe=ue,Be=Je,Ke=yt)},setLocked:function(ue){j=ue},setClear:function(ue){H!==ue&&(n.clearStencil(ue),H=ue)},reset:function(){j=!1,pe=null,Se=null,De=null,ye=null,Pe=null,Be=null,Ke=null,H=null}}}const a=new r,l=new s,c=new o;let u={},h=null,d=null,f=null,p=null,m=null,y=null,g=null,v=null,_=null,b=!1,S=null,w=null,T=null,R=null,M=null;const P=n.getParameter(35661);let L=!1,$=0;const O=n.getParameter(7938);O.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(O)[1]),L=$>=1):O.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(O)[1]),L=$>=2);let I=null,N={};const V=new kt,X=new kt;function J(j,pe,Se){const De=new Uint8Array(4),ye=n.createTexture();n.bindTexture(j,ye),n.texParameteri(j,10241,9728),n.texParameteri(j,10240,9728);for(let Pe=0;Pe<Se;Pe++)n.texImage2D(pe+Pe,0,6408,1,1,0,6408,5121,De);return ye}const W={};W[3553]=J(3553,3553,1),W[34067]=J(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),Q(2929),l.setFunc(kd),Ie(!1),at(Cg),Q(2884),se(hs);function Q(j){u[j]!==!0&&(n.enable(j),u[j]=!0)}function re(j){u[j]!==!1&&(n.disable(j),u[j]=!1)}function xe(j){return h!==j?(n.useProgram(j),h=j,!0):!1}const Ae={[Lo]:32774,[VM]:32778,[GM]:32779};if(i)Ae[Ig]=32775,Ae[Pg]=32776;else{const j=e.get("EXT_blend_minmax");j!==null&&(Ae[Ig]=j.MIN_EXT,Ae[Pg]=j.MAX_EXT)}const $e={[HM]:0,[WM]:1,[jM]:768,[tv]:770,[JM]:776,[KM]:774,[XM]:772,[qM]:769,[nv]:771,[ZM]:775,[YM]:773};function se(j,pe,Se,De,ye,Pe,Be,Ke){if(j===hs){d&&(re(3042),d=!1);return}if(d||(Q(3042),d=!0),j!==UM){if(j!==f||Ke!==b){if((p!==Lo||g!==Lo)&&(n.blendEquation(32774),p=Lo,g=Lo),Ke)switch(j){case ul:n.blendFuncSeparate(1,771,1,771);break;case Mg:n.blendFunc(1,1);break;case Ag:n.blendFuncSeparate(0,0,769,771);break;case Rg:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",j);break}else switch(j){case ul:n.blendFuncSeparate(770,771,1,771);break;case Mg:n.blendFunc(770,1);break;case Ag:n.blendFunc(0,769);break;case Rg:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",j);break}m=null,y=null,v=null,_=null,f=j,b=Ke}return}ye=ye||pe,Pe=Pe||Se,Be=Be||De,(pe!==p||ye!==g)&&(n.blendEquationSeparate(Ae[pe],Ae[ye]),p=pe,g=ye),(Se!==m||De!==y||Pe!==v||Be!==_)&&(n.blendFuncSeparate($e[Se],$e[De],$e[Pe],$e[Be]),m=Se,y=De,v=Pe,_=Be),f=j,b=null}function ht(j,pe){j.side===$u?re(2884):Q(2884);let Se=j.side===un;pe&&(Se=!Se),Ie(Se),j.blending===ul&&j.transparent===!1?se(hs):se(j.blending,j.blendEquation,j.blendSrc,j.blendDst,j.blendEquationAlpha,j.blendSrcAlpha,j.blendDstAlpha,j.premultipliedAlpha),l.setFunc(j.depthFunc),l.setTest(j.depthTest),l.setMask(j.depthWrite),a.setMask(j.colorWrite);const De=j.stencilWrite;c.setTest(De),De&&(c.setMask(j.stencilWriteMask),c.setFunc(j.stencilFunc,j.stencilRef,j.stencilFuncMask),c.setOp(j.stencilFail,j.stencilZFail,j.stencilZPass)),it(j.polygonOffset,j.polygonOffsetFactor,j.polygonOffsetUnits)}function Ie(j){S!==j&&(j?n.frontFace(2304):n.frontFace(2305),S=j)}function at(j){j!==$M?(Q(2884),j!==w&&(j===Cg?n.cullFace(1029):j===BM?n.cullFace(1028):n.cullFace(1032))):re(2884),w=j}function je(j){j!==T&&(L&&n.lineWidth(j),T=j)}function it(j,pe,Se){j?(Q(32823),(R!==pe||M!==Se)&&(n.polygonOffset(pe,Se),R=pe,M=Se)):re(32823)}function qe(j){j?Q(3089):re(3089)}function ce(j){j===void 0&&(j=33984+P-1),I!==j&&(n.activeTexture(j),I=j)}function ve(j,pe){I===null&&ce();let Se=N[I];Se===void 0&&(Se={type:void 0,texture:void 0},N[I]=Se),(Se.type!==j||Se.texture!==pe)&&(n.bindTexture(j,pe||W[j]),Se.type=j,Se.texture=pe)}function be(){const j=N[I];j!==void 0&&j.type!==void 0&&(n.bindTexture(j.type,null),j.type=void 0,j.texture=void 0)}function Oe(){try{n.compressedTexImage2D.apply(n,arguments)}catch(j){console.error("THREE.WebGLState:",j)}}function _e(){try{n.texImage2D.apply(n,arguments)}catch(j){console.error("THREE.WebGLState:",j)}}function z(){try{n.texImage3D.apply(n,arguments)}catch(j){console.error("THREE.WebGLState:",j)}}function F(j){V.equals(j)===!1&&(n.scissor(j.x,j.y,j.z,j.w),V.copy(j))}function me(j){X.equals(j)===!1&&(n.viewport(j.x,j.y,j.z,j.w),X.copy(j))}function le(){u={},I=null,N={},h=null,d=null,f=null,p=null,m=null,y=null,g=null,v=null,_=null,b=!1,S=null,w=null,T=null,R=null,M=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:Q,disable:re,useProgram:xe,setBlending:se,setMaterial:ht,setFlipSided:Ie,setCullFace:at,setLineWidth:je,setPolygonOffset:it,setScissorTest:qe,activeTexture:ce,bindTexture:ve,unbindTexture:be,compressedTexImage2D:Oe,texImage2D:_e,texImage3D:z,scissor:F,viewport:me,reset:le}}function YK(n,e,t,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=new WeakMap;let f,p=!1;try{p=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(z,F){return p?new OffscreenCanvas(z,F):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(z,F,me,le){let j=1;if((z.width>le||z.height>le)&&(j=le/Math.max(z.width,z.height)),j<1||F===!0)if(typeof HTMLImageElement!="undefined"&&z instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&z instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&z instanceof ImageBitmap){const pe=F?Ze.floorPowerOfTwo:Math.floor,Se=pe(j*z.width),De=pe(j*z.height);f===void 0&&(f=m(Se,De));const ye=me?m(Se,De):f;return ye.width=Se,ye.height=De,ye.getContext("2d").drawImage(z,0,0,Se,De),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+z.width+"x"+z.height+") to ("+Se+"x"+De+")."),ye}else return"data"in z&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+z.width+"x"+z.height+")."),z;return z}function g(z){return Ze.isPowerOfTwo(z.width)&&Ze.isPowerOfTwo(z.height)}function v(z){return a?!1:z.wrapS!==ii||z.wrapT!==ii||z.minFilter!==bn&&z.minFilter!==Cn}function _(z,F){return z.generateMipmaps&&F&&z.minFilter!==bn&&z.minFilter!==Cn}function b(z,F,me,le){n.generateMipmap(z);const j=i.get(F);j.__maxMipLevel=Math.log(Math.max(me,le))*Math.LOG2E}function S(z,F,me){if(a===!1)return F;if(z!==null){if(n[z]!==void 0)return n[z];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+z+"'")}let le=F;return F===6403&&(me===5126&&(le=33326),me===5131&&(le=33325),me===5121&&(le=33321)),F===6407&&(me===5126&&(le=34837),me===5131&&(le=34843),me===5121&&(le=32849)),F===6408&&(me===5126&&(le=34836),me===5131&&(le=34842),me===5121&&(le=32856)),(le===33325||le===33326||le===34842||le===34836)&&e.get("EXT_color_buffer_float"),le}function w(z){return z===bn||z===$d||z===Bd?9728:9729}function T(z){const F=z.target;F.removeEventListener("dispose",T),M(F),F.isVideoTexture&&d.delete(F),o.memory.textures--}function R(z){const F=z.target;F.removeEventListener("dispose",R),P(F),o.memory.textures--}function M(z){const F=i.get(z);F.__webglInit!==void 0&&(n.deleteTexture(F.__webglTexture),i.remove(z))}function P(z){const F=i.get(z),me=i.get(z.texture);if(!!z){if(me.__webglTexture!==void 0&&n.deleteTexture(me.__webglTexture),z.depthTexture&&z.depthTexture.dispose(),z.isWebGLCubeRenderTarget)for(let le=0;le<6;le++)n.deleteFramebuffer(F.__webglFramebuffer[le]),F.__webglDepthbuffer&&n.deleteRenderbuffer(F.__webglDepthbuffer[le]);else n.deleteFramebuffer(F.__webglFramebuffer),F.__webglDepthbuffer&&n.deleteRenderbuffer(F.__webglDepthbuffer),F.__webglMultisampledFramebuffer&&n.deleteFramebuffer(F.__webglMultisampledFramebuffer),F.__webglColorRenderbuffer&&n.deleteRenderbuffer(F.__webglColorRenderbuffer),F.__webglDepthRenderbuffer&&n.deleteRenderbuffer(F.__webglDepthRenderbuffer);i.remove(z.texture),i.remove(z)}}let L=0;function $(){L=0}function O(){const z=L;return z>=l&&console.warn("THREE.WebGLTextures: Trying to use "+z+" texture units while this GPU supports only "+l),L+=1,z}function I(z,F){const me=i.get(z);if(z.isVideoTexture&&ce(z),z.version>0&&me.__version!==z.version){const le=z.image;if(le===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(le.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{xe(me,z,F);return}}t.activeTexture(33984+F),t.bindTexture(3553,me.__webglTexture)}function N(z,F){const me=i.get(z);if(z.version>0&&me.__version!==z.version){xe(me,z,F);return}t.activeTexture(33984+F),t.bindTexture(35866,me.__webglTexture)}function V(z,F){const me=i.get(z);if(z.version>0&&me.__version!==z.version){xe(me,z,F);return}t.activeTexture(33984+F),t.bindTexture(32879,me.__webglTexture)}function X(z,F){const me=i.get(z);if(z.version>0&&me.__version!==z.version){Ae(me,z,F);return}t.activeTexture(33984+F),t.bindTexture(34067,me.__webglTexture)}const J={[Yc]:10497,[ii]:33071,[Kc]:33648},W={[bn]:9728,[$d]:9984,[Bd]:9986,[Cn]:9729,[iv]:9985,[Kl]:9987};function Q(z,F,me){me?(n.texParameteri(z,10242,J[F.wrapS]),n.texParameteri(z,10243,J[F.wrapT]),(z===32879||z===35866)&&n.texParameteri(z,32882,J[F.wrapR]),n.texParameteri(z,10240,W[F.magFilter]),n.texParameteri(z,10241,W[F.minFilter])):(n.texParameteri(z,10242,33071),n.texParameteri(z,10243,33071),(z===32879||z===35866)&&n.texParameteri(z,32882,33071),(F.wrapS!==ii||F.wrapT!==ii)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(z,10240,w(F.magFilter)),n.texParameteri(z,10241,w(F.minFilter)),F.minFilter!==bn&&F.minFilter!==Cn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const le=e.get("EXT_texture_filter_anisotropic");if(le){if(F.type===ls&&e.get("OES_texture_float_linear")===null||F.type===Jc&&(a||e.get("OES_texture_half_float_linear"))===null)return;(F.anisotropy>1||i.get(F).__currentAnisotropy)&&(n.texParameterf(z,le.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(F.anisotropy,r.getMaxAnisotropy())),i.get(F).__currentAnisotropy=F.anisotropy)}}function re(z,F){z.__webglInit===void 0&&(z.__webglInit=!0,F.addEventListener("dispose",T),z.__webglTexture=n.createTexture(),o.memory.textures++)}function xe(z,F,me){let le=3553;F.isDataTexture2DArray&&(le=35866),F.isDataTexture3D&&(le=32879),re(z,F),t.activeTexture(33984+me),t.bindTexture(le,z.__webglTexture),n.pixelStorei(37440,F.flipY),n.pixelStorei(37441,F.premultiplyAlpha),n.pixelStorei(3317,F.unpackAlignment);const j=v(F)&&g(F.image)===!1,pe=y(F.image,j,!1,u),Se=g(pe)||a,De=s.convert(F.format);let ye=s.convert(F.type),Pe=S(F.internalFormat,De,ye);Q(le,F,Se);let Be;const Ke=F.mipmaps;if(F.isDepthTexture)Pe=6402,a?F.type===ls?Pe=36012:F.type===Ic?Pe=33190:F.type===hl?Pe=35056:Pe=33189:F.type===ls&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),F.format===Xo&&Pe===6402&&F.type!==Zc&&F.type!==Ic&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),F.type=Zc,ye=s.convert(F.type)),F.format===Sl&&Pe===6402&&(Pe=34041,F.type!==hl&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),F.type=hl,ye=s.convert(F.type))),t.texImage2D(3553,0,Pe,pe.width,pe.height,0,De,ye,null);else if(F.isDataTexture)if(Ke.length>0&&Se){for(let H=0,ue=Ke.length;H<ue;H++)Be=Ke[H],t.texImage2D(3553,H,Pe,Be.width,Be.height,0,De,ye,Be.data);F.generateMipmaps=!1,z.__maxMipLevel=Ke.length-1}else t.texImage2D(3553,0,Pe,pe.width,pe.height,0,De,ye,pe.data),z.__maxMipLevel=0;else if(F.isCompressedTexture){for(let H=0,ue=Ke.length;H<ue;H++)Be=Ke[H],F.format!==Mi&&F.format!==js?De!==null?t.compressedTexImage2D(3553,H,Pe,Be.width,Be.height,0,Be.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,H,Pe,Be.width,Be.height,0,De,ye,Be.data);z.__maxMipLevel=Ke.length-1}else if(F.isDataTexture2DArray)t.texImage3D(35866,0,Pe,pe.width,pe.height,pe.depth,0,De,ye,pe.data),z.__maxMipLevel=0;else if(F.isDataTexture3D)t.texImage3D(32879,0,Pe,pe.width,pe.height,pe.depth,0,De,ye,pe.data),z.__maxMipLevel=0;else if(Ke.length>0&&Se){for(let H=0,ue=Ke.length;H<ue;H++)Be=Ke[H],t.texImage2D(3553,H,Pe,De,ye,Be);F.generateMipmaps=!1,z.__maxMipLevel=Ke.length-1}else t.texImage2D(3553,0,Pe,De,ye,pe),z.__maxMipLevel=0;_(F,Se)&&b(le,F,pe.width,pe.height),z.__version=F.version,F.onUpdate&&F.onUpdate(F)}function Ae(z,F,me){if(F.image.length!==6)return;re(z,F),t.activeTexture(33984+me),t.bindTexture(34067,z.__webglTexture),n.pixelStorei(37440,F.flipY),n.pixelStorei(37441,F.premultiplyAlpha),n.pixelStorei(3317,F.unpackAlignment);const le=F&&(F.isCompressedTexture||F.image[0].isCompressedTexture),j=F.image[0]&&F.image[0].isDataTexture,pe=[];for(let H=0;H<6;H++)!le&&!j?pe[H]=y(F.image[H],!1,!0,c):pe[H]=j?F.image[H].image:F.image[H];const Se=pe[0],De=g(Se)||a,ye=s.convert(F.format),Pe=s.convert(F.type),Be=S(F.internalFormat,ye,Pe);Q(34067,F,De);let Ke;if(le){for(let H=0;H<6;H++){Ke=pe[H].mipmaps;for(let ue=0;ue<Ke.length;ue++){const Je=Ke[ue];F.format!==Mi&&F.format!==js?ye!==null?t.compressedTexImage2D(34069+H,ue,Be,Je.width,Je.height,0,Je.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+H,ue,Be,Je.width,Je.height,0,ye,Pe,Je.data)}}z.__maxMipLevel=Ke.length-1}else{Ke=F.mipmaps;for(let H=0;H<6;H++)if(j){t.texImage2D(34069+H,0,Be,pe[H].width,pe[H].height,0,ye,Pe,pe[H].data);for(let ue=0;ue<Ke.length;ue++){const yt=Ke[ue].image[H].image;t.texImage2D(34069+H,ue+1,Be,yt.width,yt.height,0,ye,Pe,yt.data)}}else{t.texImage2D(34069+H,0,Be,ye,Pe,pe[H]);for(let ue=0;ue<Ke.length;ue++){const Je=Ke[ue];t.texImage2D(34069+H,ue+1,Be,ye,Pe,Je.image[H])}}z.__maxMipLevel=Ke.length}_(F,De)&&b(34067,F,Se.width,Se.height),z.__version=F.version,F.onUpdate&&F.onUpdate(F)}function $e(z,F,me,le){const j=s.convert(F.texture.format),pe=s.convert(F.texture.type),Se=S(F.texture.internalFormat,j,pe);t.texImage2D(le,0,Se,F.width,F.height,0,j,pe,null),n.bindFramebuffer(36160,z),n.framebufferTexture2D(36160,me,le,i.get(F.texture).__webglTexture,0),n.bindFramebuffer(36160,null)}function se(z,F,me){if(n.bindRenderbuffer(36161,z),F.depthBuffer&&!F.stencilBuffer){let le=33189;if(me){const j=F.depthTexture;j&&j.isDepthTexture&&(j.type===ls?le=36012:j.type===Ic&&(le=33190));const pe=qe(F);n.renderbufferStorageMultisample(36161,pe,le,F.width,F.height)}else n.renderbufferStorage(36161,le,F.width,F.height);n.framebufferRenderbuffer(36160,36096,36161,z)}else if(F.depthBuffer&&F.stencilBuffer){if(me){const le=qe(F);n.renderbufferStorageMultisample(36161,le,35056,F.width,F.height)}else n.renderbufferStorage(36161,34041,F.width,F.height);n.framebufferRenderbuffer(36160,33306,36161,z)}else{const le=s.convert(F.texture.format),j=s.convert(F.texture.type),pe=S(F.texture.internalFormat,le,j);if(me){const Se=qe(F);n.renderbufferStorageMultisample(36161,Se,pe,F.width,F.height)}else n.renderbufferStorage(36161,pe,F.width,F.height)}n.bindRenderbuffer(36161,null)}function ht(z,F){if(F&&F.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,z),!(F.depthTexture&&F.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(F.depthTexture).__webglTexture||F.depthTexture.image.width!==F.width||F.depthTexture.image.height!==F.height)&&(F.depthTexture.image.width=F.width,F.depthTexture.image.height=F.height,F.depthTexture.needsUpdate=!0),I(F.depthTexture,0);const le=i.get(F.depthTexture).__webglTexture;if(F.depthTexture.format===Xo)n.framebufferTexture2D(36160,36096,3553,le,0);else if(F.depthTexture.format===Sl)n.framebufferTexture2D(36160,33306,3553,le,0);else throw new Error("Unknown depthTexture format")}function Ie(z){const F=i.get(z),me=z.isWebGLCubeRenderTarget===!0;if(z.depthTexture){if(me)throw new Error("target.depthTexture not supported in Cube render targets");ht(F.__webglFramebuffer,z)}else if(me){F.__webglDepthbuffer=[];for(let le=0;le<6;le++)n.bindFramebuffer(36160,F.__webglFramebuffer[le]),F.__webglDepthbuffer[le]=n.createRenderbuffer(),se(F.__webglDepthbuffer[le],z,!1)}else n.bindFramebuffer(36160,F.__webglFramebuffer),F.__webglDepthbuffer=n.createRenderbuffer(),se(F.__webglDepthbuffer,z,!1);n.bindFramebuffer(36160,null)}function at(z){const F=i.get(z),me=i.get(z.texture);z.addEventListener("dispose",R),me.__webglTexture=n.createTexture(),o.memory.textures++;const le=z.isWebGLCubeRenderTarget===!0,j=z.isWebGLMultisampleRenderTarget===!0,pe=g(z)||a;if(a&&z.texture.format===js&&(z.texture.type===ls||z.texture.type===Jc)&&(z.texture.format=Mi,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),le){F.__webglFramebuffer=[];for(let Se=0;Se<6;Se++)F.__webglFramebuffer[Se]=n.createFramebuffer()}else if(F.__webglFramebuffer=n.createFramebuffer(),j)if(a){F.__webglMultisampledFramebuffer=n.createFramebuffer(),F.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,F.__webglColorRenderbuffer);const Se=s.convert(z.texture.format),De=s.convert(z.texture.type),ye=S(z.texture.internalFormat,Se,De),Pe=qe(z);n.renderbufferStorageMultisample(36161,Pe,ye,z.width,z.height),n.bindFramebuffer(36160,F.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,F.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),z.depthBuffer&&(F.__webglDepthRenderbuffer=n.createRenderbuffer(),se(F.__webglDepthRenderbuffer,z,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(le){t.bindTexture(34067,me.__webglTexture),Q(34067,z.texture,pe);for(let Se=0;Se<6;Se++)$e(F.__webglFramebuffer[Se],z,36064,34069+Se);_(z.texture,pe)&&b(34067,z.texture,z.width,z.height),t.bindTexture(34067,null)}else t.bindTexture(3553,me.__webglTexture),Q(3553,z.texture,pe),$e(F.__webglFramebuffer,z,36064,3553),_(z.texture,pe)&&b(3553,z.texture,z.width,z.height),t.bindTexture(3553,null);z.depthBuffer&&Ie(z)}function je(z){const F=z.texture,me=g(z)||a;if(_(F,me)){const le=z.isWebGLCubeRenderTarget?34067:3553,j=i.get(F).__webglTexture;t.bindTexture(le,j),b(le,F,z.width,z.height),t.bindTexture(le,null)}}function it(z){if(z.isWebGLMultisampleRenderTarget)if(a){const F=i.get(z);n.bindFramebuffer(36008,F.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,F.__webglFramebuffer);const me=z.width,le=z.height;let j=16384;z.depthBuffer&&(j|=256),z.stencilBuffer&&(j|=1024),n.blitFramebuffer(0,0,me,le,0,0,me,le,j,9728),n.bindFramebuffer(36160,F.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function qe(z){return a&&z.isWebGLMultisampleRenderTarget?Math.min(h,z.samples):0}function ce(z){const F=o.render.frame;d.get(z)!==F&&(d.set(z,F),z.update())}let ve=!1,be=!1;function Oe(z,F){z&&z.isWebGLRenderTarget&&(ve===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),ve=!0),z=z.texture),I(z,F)}function _e(z,F){z&&z.isWebGLCubeRenderTarget&&(be===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),be=!0),z=z.texture),X(z,F)}this.allocateTextureUnit=O,this.resetTextureUnits=$,this.setTexture2D=I,this.setTexture2DArray=N,this.setTexture3D=V,this.setTextureCube=X,this.setupRenderTarget=at,this.updateRenderTargetMipmap=je,this.updateMultisampleRenderTarget=it,this.safeSetTexture2D=Oe,this.safeSetTextureCube=_e}function CA(n,e,t){const i=t.isWebGL2;function r(s){let o;if(s===Zl)return 5121;if(s===g2)return 32819;if(s===y2)return 32820;if(s===v2)return 33635;if(s===f2)return 5120;if(s===p2)return 5122;if(s===Zc)return 5123;if(s===m2)return 5124;if(s===Ic)return 5125;if(s===ls)return 5126;if(s===Jc)return i?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===x2)return 6406;if(s===js)return 6407;if(s===Mi)return 6408;if(s===_2)return 6409;if(s===b2)return 6410;if(s===Xo)return 6402;if(s===Sl)return 34041;if(s===S2)return 6403;if(s===T2)return 36244;if(s===E2)return 33319;if(s===C2)return 33320;if(s===M2)return 36248;if(s===A2)return 36249;if(s===Ng||s===Lg||s===Dg||s===kg)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===Ng)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Lg)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Dg)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===kg)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===Og||s===Fg||s===$g||s===Bg)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===Og)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Fg)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===$g)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===Bg)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===R2)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===zg||s===Ug)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(s===zg)return o.COMPRESSED_RGB8_ETC2;if(s===Ug)return o.COMPRESSED_RGBA8_ETC2_EAC}if(s===I2||s===P2||s===N2||s===L2||s===D2||s===k2||s===O2||s===F2||s===$2||s===B2||s===z2||s===U2||s===V2||s===G2||s===W2||s===j2||s===q2||s===X2||s===Y2||s===K2||s===Z2||s===J2||s===Q2||s===eA||s===tA||s===nA||s===iA||s===rA)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?s:null;if(s===H2)return o=e.get("EXT_texture_compression_bptc"),o!==null?s:null;if(s===hl)return i?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}function zd(n=[]){fn.call(this),this.cameras=n}zd.prototype=Object.assign(Object.create(fn.prototype),{constructor:zd,isArrayCamera:!0});function Vs(){ze.call(this),this.type="Group"}Vs.prototype=Object.assign(Object.create(ze.prototype),{constructor:Vs,isGroup:!0});function Nc(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(Nc.prototype,{constructor:Nc,getHandSpace:function(){return this._hand===null&&(this._hand=new Vs,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Vs,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Vs,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(n){return this._targetRay!==null&&this._targetRay.dispatchEvent(n),this._grip!==null&&this._grip.dispatchEvent(n),this._hand!==null&&this._hand.dispatchEvent(n),this},disconnect:function(n){return this.dispatchEvent({type:"disconnected",data:n}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(n,e,t){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(n&&e.session.visibilityState!=="visible-blurred")if(l&&n.hand){s=!0;for(const p of n.hand.values()){const m=e.getJointPose(p,t);if(l.joints[p.jointName]===void 0){const g=new Vs;g.matrixAutoUpdate=!1,g.visible=!1,l.joints[p.jointName]=g,l.add(g)}const y=l.joints[p.jointName];m!==null&&(y.matrix.fromArray(m.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.jointRadius=m.radius),y.visible=m!==null}const c=l.joints["index-finger-tip"],u=l.joints["thumb-tip"],h=c.position.distanceTo(u.position),d=.02,f=.005;l.inputState.pinching&&h>d+f?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!l.inputState.pinching&&h<=d-f&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else o!==null&&(i=e.getPose(n.targetRaySpace,t),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&n.gripSpace&&(r=e.getPose(n.gripSpace,t),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=i!==null),a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),this}});function MA(n,e){const t=this;let i=null,r=1,s=null,o="local-floor",a=null;const l=[],c=new Map,u=new fn;u.layers.enable(1),u.viewport=new kt;const h=new fn;h.layers.enable(2),h.viewport=new kt;const d=[u,h],f=new zd;f.layers.enable(1),f.layers.enable(2);let p=null,m=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(P){let L=l[P];return L===void 0&&(L=new Nc,l[P]=L),L.getTargetRaySpace()},this.getControllerGrip=function(P){let L=l[P];return L===void 0&&(L=new Nc,l[P]=L),L.getGripSpace()},this.getHand=function(P){let L=l[P];return L===void 0&&(L=new Nc,l[P]=L),L.getHandSpace()};function y(P){const L=c.get(P.inputSource);L&&L.dispatchEvent({type:P.type,data:P.inputSource})}function g(){c.forEach(function(P,L){P.disconnect(L)}),c.clear(),p=null,m=null,n.setFramebuffer(null),n.setRenderTarget(n.getRenderTarget()),M.stop(),t.isPresenting=!1,t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(P){r=P,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(P){o=P,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return i},this.setSession=async function(P){if(i=P,i!==null){i.addEventListener("select",y),i.addEventListener("selectstart",y),i.addEventListener("selectend",y),i.addEventListener("squeeze",y),i.addEventListener("squeezestart",y),i.addEventListener("squeezeend",y),i.addEventListener("end",g),i.addEventListener("inputsourceschange",v);const L=e.getContextAttributes();L.xrCompatible!==!0&&await e.makeXRCompatible();const $={antialias:L.antialias,alpha:L.alpha,depth:L.depth,stencil:L.stencil,framebufferScaleFactor:r},O=new XRWebGLLayer(i,e,$);i.updateRenderState({baseLayer:O}),s=await i.requestReferenceSpace(o),M.setContext(i),M.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}};function v(P){const L=i.inputSources;for(let $=0;$<l.length;$++)c.set(L[$],l[$]);for(let $=0;$<P.removed.length;$++){const O=P.removed[$],I=c.get(O);I&&(I.dispatchEvent({type:"disconnected",data:O}),c.delete(O))}for(let $=0;$<P.added.length;$++){const O=P.added[$],I=c.get(O);I&&I.dispatchEvent({type:"connected",data:O})}}const _=new k,b=new k;function S(P,L,$){_.setFromMatrixPosition(L.matrixWorld),b.setFromMatrixPosition($.matrixWorld);const O=_.distanceTo(b),I=L.projectionMatrix.elements,N=$.projectionMatrix.elements,V=I[14]/(I[10]-1),X=I[14]/(I[10]+1),J=(I[9]+1)/I[5],W=(I[9]-1)/I[5],Q=(I[8]-1)/I[0],re=(N[8]+1)/N[0],xe=V*Q,Ae=V*re,$e=O/(-Q+re),se=$e*-Q;L.matrixWorld.decompose(P.position,P.quaternion,P.scale),P.translateX(se),P.translateZ($e),P.matrixWorld.compose(P.position,P.quaternion,P.scale),P.matrixWorldInverse.copy(P.matrixWorld).invert();const ht=V+$e,Ie=X+$e,at=xe-se,je=Ae+(O-se),it=J*X/Ie*ht,qe=W*X/Ie*ht;P.projectionMatrix.makePerspective(at,je,it,qe,ht,Ie)}function w(P,L){L===null?P.matrixWorld.copy(P.matrix):P.matrixWorld.multiplyMatrices(L.matrixWorld,P.matrix),P.matrixWorldInverse.copy(P.matrixWorld).invert()}this.getCamera=function(P){f.near=h.near=u.near=P.near,f.far=h.far=u.far=P.far,(p!==f.near||m!==f.far)&&(i.updateRenderState({depthNear:f.near,depthFar:f.far}),p=f.near,m=f.far);const L=P.parent,$=f.cameras;w(f,L);for(let I=0;I<$.length;I++)w($[I],L);P.matrixWorld.copy(f.matrixWorld),P.matrix.copy(f.matrix),P.matrix.decompose(P.position,P.quaternion,P.scale);const O=P.children;for(let I=0,N=O.length;I<N;I++)O[I].updateMatrixWorld(!0);return $.length===2?S(f,u,h):f.projectionMatrix.copy(u.projectionMatrix),f};let T=null;function R(P,L){if(a=L.getViewerPose(s),a!==null){const O=a.views,I=i.renderState.baseLayer;n.setFramebuffer(I.framebuffer);let N=!1;O.length!==f.cameras.length&&(f.cameras.length=0,N=!0);for(let V=0;V<O.length;V++){const X=O[V],J=I.getViewport(X),W=d[V];W.matrix.fromArray(X.transform.matrix),W.projectionMatrix.fromArray(X.projectionMatrix),W.viewport.set(J.x,J.y,J.width,J.height),V===0&&f.matrix.copy(W.matrix),N===!0&&f.cameras.push(W)}}const $=i.inputSources;for(let O=0;O<l.length;O++){const I=l[O],N=$[O];I.update(N,L,s)}T&&T(P,L)}const M=new yA;M.setAnimationLoop(R),this.setAnimationLoop=function(P){T=P},this.dispose=function(){}}Object.assign(MA.prototype,_s.prototype);function KK(n){function e(g,v){g.fogColor.value.copy(v.color),v.isFog?(g.fogNear.value=v.near,g.fogFar.value=v.far):v.isFogExp2&&(g.fogDensity.value=v.density)}function t(g,v,_,b){v.isMeshBasicMaterial?i(g,v):v.isMeshLambertMaterial?(i(g,v),l(g,v)):v.isMeshToonMaterial?(i(g,v),u(g,v)):v.isMeshPhongMaterial?(i(g,v),c(g,v)):v.isMeshStandardMaterial?(i(g,v),v.isMeshPhysicalMaterial?d(g,v):h(g,v)):v.isMeshMatcapMaterial?(i(g,v),f(g,v)):v.isMeshDepthMaterial?(i(g,v),p(g,v)):v.isMeshDistanceMaterial?(i(g,v),m(g,v)):v.isMeshNormalMaterial?(i(g,v),y(g,v)):v.isLineBasicMaterial?(r(g,v),v.isLineDashedMaterial&&s(g,v)):v.isPointsMaterial?o(g,v,_,b):v.isSpriteMaterial?a(g,v):v.isShadowMaterial?(g.color.value.copy(v.color),g.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function i(g,v){g.opacity.value=v.opacity,v.color&&g.diffuse.value.copy(v.color),v.emissive&&g.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(g.map.value=v.map),v.alphaMap&&(g.alphaMap.value=v.alphaMap),v.specularMap&&(g.specularMap.value=v.specularMap);const _=n.get(v).envMap;if(_){g.envMap.value=_,g.flipEnvMap.value=_.isCubeTexture&&_._needsFlipEnvMap?-1:1,g.reflectivity.value=v.reflectivity,g.refractionRatio.value=v.refractionRatio;const w=n.get(_).__maxMipLevel;w!==void 0&&(g.maxMipLevel.value=w)}v.lightMap&&(g.lightMap.value=v.lightMap,g.lightMapIntensity.value=v.lightMapIntensity),v.aoMap&&(g.aoMap.value=v.aoMap,g.aoMapIntensity.value=v.aoMapIntensity);let b;v.map?b=v.map:v.specularMap?b=v.specularMap:v.displacementMap?b=v.displacementMap:v.normalMap?b=v.normalMap:v.bumpMap?b=v.bumpMap:v.roughnessMap?b=v.roughnessMap:v.metalnessMap?b=v.metalnessMap:v.alphaMap?b=v.alphaMap:v.emissiveMap?b=v.emissiveMap:v.clearcoatMap?b=v.clearcoatMap:v.clearcoatNormalMap?b=v.clearcoatNormalMap:v.clearcoatRoughnessMap&&(b=v.clearcoatRoughnessMap),b!==void 0&&(b.isWebGLRenderTarget&&(b=b.texture),b.matrixAutoUpdate===!0&&b.updateMatrix(),g.uvTransform.value.copy(b.matrix));let S;v.aoMap?S=v.aoMap:v.lightMap&&(S=v.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uv2Transform.value.copy(S.matrix))}function r(g,v){g.diffuse.value.copy(v.color),g.opacity.value=v.opacity}function s(g,v){g.dashSize.value=v.dashSize,g.totalSize.value=v.dashSize+v.gapSize,g.scale.value=v.scale}function o(g,v,_,b){g.diffuse.value.copy(v.color),g.opacity.value=v.opacity,g.size.value=v.size*_,g.scale.value=b*.5,v.map&&(g.map.value=v.map),v.alphaMap&&(g.alphaMap.value=v.alphaMap);let S;v.map?S=v.map:v.alphaMap&&(S=v.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uvTransform.value.copy(S.matrix))}function a(g,v){g.diffuse.value.copy(v.color),g.opacity.value=v.opacity,g.rotation.value=v.rotation,v.map&&(g.map.value=v.map),v.alphaMap&&(g.alphaMap.value=v.alphaMap);let _;v.map?_=v.map:v.alphaMap&&(_=v.alphaMap),_!==void 0&&(_.matrixAutoUpdate===!0&&_.updateMatrix(),g.uvTransform.value.copy(_.matrix))}function l(g,v){v.emissiveMap&&(g.emissiveMap.value=v.emissiveMap)}function c(g,v){g.specular.value.copy(v.specular),g.shininess.value=Math.max(v.shininess,1e-4),v.emissiveMap&&(g.emissiveMap.value=v.emissiveMap),v.bumpMap&&(g.bumpMap.value=v.bumpMap,g.bumpScale.value=v.bumpScale,v.side===un&&(g.bumpScale.value*=-1)),v.normalMap&&(g.normalMap.value=v.normalMap,g.normalScale.value.copy(v.normalScale),v.side===un&&g.normalScale.value.negate()),v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias)}function u(g,v){v.gradientMap&&(g.gradientMap.value=v.gradientMap),v.emissiveMap&&(g.emissiveMap.value=v.emissiveMap),v.bumpMap&&(g.bumpMap.value=v.bumpMap,g.bumpScale.value=v.bumpScale,v.side===un&&(g.bumpScale.value*=-1)),v.normalMap&&(g.normalMap.value=v.normalMap,g.normalScale.value.copy(v.normalScale),v.side===un&&g.normalScale.value.negate()),v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias)}function h(g,v){g.roughness.value=v.roughness,g.metalness.value=v.metalness,v.roughnessMap&&(g.roughnessMap.value=v.roughnessMap),v.metalnessMap&&(g.metalnessMap.value=v.metalnessMap),v.emissiveMap&&(g.emissiveMap.value=v.emissiveMap),v.bumpMap&&(g.bumpMap.value=v.bumpMap,g.bumpScale.value=v.bumpScale,v.side===un&&(g.bumpScale.value*=-1)),v.normalMap&&(g.normalMap.value=v.normalMap,g.normalScale.value.copy(v.normalScale),v.side===un&&g.normalScale.value.negate()),v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias),n.get(v).envMap&&(g.envMapIntensity.value=v.envMapIntensity)}function d(g,v){h(g,v),g.reflectivity.value=v.reflectivity,g.clearcoat.value=v.clearcoat,g.clearcoatRoughness.value=v.clearcoatRoughness,v.sheen&&g.sheen.value.copy(v.sheen),v.clearcoatMap&&(g.clearcoatMap.value=v.clearcoatMap),v.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap),v.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),g.clearcoatNormalMap.value=v.clearcoatNormalMap,v.side===un&&g.clearcoatNormalScale.value.negate()),g.transmission.value=v.transmission,v.transmissionMap&&(g.transmissionMap.value=v.transmissionMap)}function f(g,v){v.matcap&&(g.matcap.value=v.matcap),v.bumpMap&&(g.bumpMap.value=v.bumpMap,g.bumpScale.value=v.bumpScale,v.side===un&&(g.bumpScale.value*=-1)),v.normalMap&&(g.normalMap.value=v.normalMap,g.normalScale.value.copy(v.normalScale),v.side===un&&g.normalScale.value.negate()),v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias)}function p(g,v){v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias)}function m(g,v){v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias),g.referencePosition.value.copy(v.referencePosition),g.nearDistance.value=v.nearDistance,g.farDistance.value=v.farDistance}function y(g,v){v.bumpMap&&(g.bumpMap.value=v.bumpMap,g.bumpScale.value=v.bumpScale,v.side===un&&(g.bumpScale.value*=-1)),v.normalMap&&(g.normalMap.value=v.normalMap,g.normalScale.value.copy(v.normalScale),v.side===un&&g.normalScale.value.negate()),v.displacementMap&&(g.displacementMap.value=v.displacementMap,g.displacementScale.value=v.displacementScale,g.displacementBias.value=v.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function ZK(){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.style.display="block",n}function ju(n){n=n||{};const e=n.canvas!==void 0?n.canvas:ZK(),t=n.context!==void 0?n.context:null,i=n.alpha!==void 0?n.alpha:!1,r=n.depth!==void 0?n.depth:!0,s=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",u=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h=null,d=null;const f=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=ri,this.physicallyCorrectLights=!1,this.toneMapping=qo,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let m=!1,y=null,g=0,v=0,_=null,b=null,S=-1,w=null;const T=new kt,R=new kt;let M=null,P=e.width,L=e.height,$=1,O=null,I=null;const N=new kt(0,0,P,L),V=new kt(0,0,P,L);let X=!1;const J=new Wu;let W=!1,Q=!1;const re=new ut,xe=new k,Ae={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function $e(){return _===null?$:1}let se=t;function ht(B,ie){for(let te=0;te<B.length;te++){const oe=B[te],ge=e.getContext(oe,ie);if(ge!==null)return ge}return null}try{const B={alpha:i,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",Je,!1),e.addEventListener("webglcontextrestored",yt,!1),se===null){const ie=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&ie.shift(),se=ht(ie,B),se===null)throw ht(ie)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}se.getShaderPrecisionFormat===void 0&&(se.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(B){throw console.error("THREE.WebGLRenderer: "+B.message),B}let Ie,at,je,it,qe,ce,ve,be,Oe,_e,z,F,me,le,j,pe,Se,De,ye,Pe,Be;function Ke(){Ie=new RY(se),at=new CY(se,Ie,n),Ie.init(at),Pe=new CA(se,Ie,at),je=new XK(se,Ie,at),je.scissor(R.copy(V).multiplyScalar($).floor()),je.viewport(T.copy(N).multiplyScalar($).floor()),it=new NY(se),qe=new OK,ce=new YK(se,Ie,je,qe,at,Pe,it),ve=new AY(p),be=new t7(se,at),Be=new TY(se,Ie,be,at),Oe=new IY(se,be,it,Be),_e=new OY(se,Oe,be,it),Se=new kY(se),j=new MY(qe),z=new kK(p,ve,Ie,at,Be,j),F=new KK(qe),me=new BK(qe),le=new WK(Ie,at),pe=new SY(p,ve,je,_e,a),De=new EY(se,Ie,it,at),ye=new PY(se,Ie,it,at),it.programs=z.programs,p.capabilities=at,p.extensions=Ie,p.properties=qe,p.renderLists=me,p.state=je,p.info=it}Ke();const H=new MA(p,se);this.xr=H;const ue=new EA(p,_e,at.maxTextureSize);this.shadowMap=ue,this.getContext=function(){return se},this.getContextAttributes=function(){return se.getContextAttributes()},this.forceContextLoss=function(){const B=Ie.get("WEBGL_lose_context");B&&B.loseContext()},this.forceContextRestore=function(){const B=Ie.get("WEBGL_lose_context");B&&B.restoreContext()},this.getPixelRatio=function(){return $},this.setPixelRatio=function(B){B!==void 0&&($=B,this.setSize(P,L,!1))},this.getSize=function(B){return B===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),B=new fe),B.set(P,L)},this.setSize=function(B,ie,te){if(H.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}P=B,L=ie,e.width=Math.floor(B*$),e.height=Math.floor(ie*$),te!==!1&&(e.style.width=B+"px",e.style.height=ie+"px"),this.setViewport(0,0,B,ie)},this.getDrawingBufferSize=function(B){return B===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),B=new fe),B.set(P*$,L*$).floor()},this.setDrawingBufferSize=function(B,ie,te){P=B,L=ie,$=te,e.width=Math.floor(B*te),e.height=Math.floor(ie*te),this.setViewport(0,0,B,ie)},this.getCurrentViewport=function(B){return B===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),B=new kt),B.copy(T)},this.getViewport=function(B){return B.copy(N)},this.setViewport=function(B,ie,te,oe){B.isVector4?N.set(B.x,B.y,B.z,B.w):N.set(B,ie,te,oe),je.viewport(T.copy(N).multiplyScalar($).floor())},this.getScissor=function(B){return B.copy(V)},this.setScissor=function(B,ie,te,oe){B.isVector4?V.set(B.x,B.y,B.z,B.w):V.set(B,ie,te,oe),je.scissor(R.copy(V).multiplyScalar($).floor())},this.getScissorTest=function(){return X},this.setScissorTest=function(B){je.setScissorTest(X=B)},this.setOpaqueSort=function(B){O=B},this.setTransparentSort=function(B){I=B},this.getClearColor=function(B){return B===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),B=new Ne),B.copy(pe.getClearColor())},this.setClearColor=function(){pe.setClearColor.apply(pe,arguments)},this.getClearAlpha=function(){return pe.getClearAlpha()},this.setClearAlpha=function(){pe.setClearAlpha.apply(pe,arguments)},this.clear=function(B,ie,te){let oe=0;(B===void 0||B)&&(oe|=16384),(ie===void 0||ie)&&(oe|=256),(te===void 0||te)&&(oe|=1024),se.clear(oe)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Je,!1),e.removeEventListener("webglcontextrestored",yt,!1),me.dispose(),le.dispose(),qe.dispose(),ve.dispose(),_e.dispose(),Be.dispose(),H.dispose(),ws.stop()};function Je(B){B.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function yt(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,Ke()}function pn(B){const ie=B.target;ie.removeEventListener("dispose",pn),sr(ie)}function sr(B){Di(B),qe.remove(B)}function Di(B){const ie=qe.get(B).program;ie!==void 0&&z.releaseProgram(ie)}function yo(B,ie){B.render(function(te){p.renderBufferImmediate(te,ie)})}this.renderBufferImmediate=function(B,ie){Be.initAttributes();const te=qe.get(B);B.hasPositions&&!te.position&&(te.position=se.createBuffer()),B.hasNormals&&!te.normal&&(te.normal=se.createBuffer()),B.hasUvs&&!te.uv&&(te.uv=se.createBuffer()),B.hasColors&&!te.color&&(te.color=se.createBuffer());const oe=ie.getAttributes();B.hasPositions&&(se.bindBuffer(34962,te.position),se.bufferData(34962,B.positionArray,35048),Be.enableAttribute(oe.position),se.vertexAttribPointer(oe.position,3,5126,!1,0,0)),B.hasNormals&&(se.bindBuffer(34962,te.normal),se.bufferData(34962,B.normalArray,35048),Be.enableAttribute(oe.normal),se.vertexAttribPointer(oe.normal,3,5126,!1,0,0)),B.hasUvs&&(se.bindBuffer(34962,te.uv),se.bufferData(34962,B.uvArray,35048),Be.enableAttribute(oe.uv),se.vertexAttribPointer(oe.uv,2,5126,!1,0,0)),B.hasColors&&(se.bindBuffer(34962,te.color),se.bufferData(34962,B.colorArray,35048),Be.enableAttribute(oe.color),se.vertexAttribPointer(oe.color,3,5126,!1,0,0)),Be.disableUnusedAttributes(),se.drawArrays(4,0,B.count),B.count=0},this.renderBufferDirect=function(B,ie,te,oe,ge,ct){ie===null&&(ie=Ae);const rt=ge.isMesh&&ge.matrixWorld.determinant()<0,st=ic(B,ie,oe,ge);je.setMaterial(oe,rt);let ot=te.index;const Jt=te.attributes.position;if(ot===null){if(Jt===void 0||Jt.count===0)return}else if(ot.count===0)return;let Xt=1;oe.wireframe===!0&&(ot=Oe.getWireframeAttribute(te),Xt=2),(oe.morphTargets||oe.morphNormals)&&Se.update(ge,te,oe,st),Be.setup(ge,oe,st,te,ot);let tt,vt=De;ot!==null&&(tt=be.get(ot),vt=ye,vt.setIndex(tt));const yi=ot!==null?ot.count:Jt.count,Nt=te.drawRange.start*Xt,mn=te.drawRange.count*Xt,At=ct!==null?ct.start*Xt:0,rc=ct!==null?ct.count*Xt:1/0,$n=Math.max(Nt,At),Ss=Math.min(yi,Nt+mn,At+rc)-1,Yr=Math.max(0,Ss-$n+1);if(Yr!==0){if(ge.isMesh)oe.wireframe===!0?(je.setLineWidth(oe.wireframeLinewidth*$e()),vt.setMode(1)):vt.setMode(4);else if(ge.isLine){let or=oe.linewidth;or===void 0&&(or=1),je.setLineWidth(or*$e()),ge.isLineSegments?vt.setMode(1):ge.isLineLoop?vt.setMode(2):vt.setMode(3)}else ge.isPoints?vt.setMode(0):ge.isSprite&&vt.setMode(4);if(ge.isInstancedMesh)vt.renderInstances($n,Yr,ge.count);else if(te.isInstancedBufferGeometry){const or=Math.min(te.instanceCount,te._maxInstanceCount);vt.renderInstances($n,Yr,or)}else vt.render($n,Yr)}},this.compile=function(B,ie){d=le.get(B),d.init(),B.traverseVisible(function(oe){oe.isLight&&oe.layers.test(ie.layers)&&(d.pushLight(oe),oe.castShadow&&d.pushShadow(oe))}),d.setupLights();const te=new WeakMap;B.traverse(function(oe){const ge=oe.material;if(ge)if(Array.isArray(ge))for(let ct=0;ct<ge.length;ct++){const rt=ge[ct];te.has(rt)===!1&&(ki(rt,B,oe),te.set(rt))}else te.has(ge)===!1&&(ki(ge,B,oe),te.set(ge))})};let Rn=null;function In(B){H.isPresenting||Rn&&Rn(B)}const ws=new yA;ws.setAnimationLoop(In),typeof window!="undefined"&&ws.setContext(window),this.setAnimationLoop=function(B){Rn=B,H.setAnimationLoop(B),B===null?ws.stop():ws.start()},this.render=function(B,ie){let te,oe;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),te=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),oe=arguments[3]),ie!==void 0&&ie.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;Be.resetDefaultState(),S=-1,w=null,B.autoUpdate===!0&&B.updateMatrixWorld(),ie.parent===null&&ie.updateMatrixWorld(),H.enabled===!0&&H.isPresenting===!0&&(ie=H.getCamera(ie)),B.isScene===!0&&B.onBeforeRender(p,B,ie,te||_),d=le.get(B,f.length),d.init(),f.push(d),re.multiplyMatrices(ie.projectionMatrix,ie.matrixWorldInverse),J.setFromProjectionMatrix(re),Q=this.localClippingEnabled,W=j.init(this.clippingPlanes,Q,ie),h=me.get(B,ie),h.init(),tc(B,ie,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(O,I),W===!0&&j.beginShadows();const ge=d.state.shadowsArray;ue.render(ge,B,ie),d.setupLights(),d.setupLightsView(ie),W===!0&&j.endShadows(),this.info.autoReset===!0&&this.info.reset(),te!==void 0&&this.setRenderTarget(te),pe.render(h,B,ie,oe);const ct=h.opaque,rt=h.transparent;ct.length>0&&Zu(ct,B,ie),rt.length>0&&Zu(rt,B,ie),B.isScene===!0&&B.onAfterRender(p,B,ie),_!==null&&(ce.updateRenderTargetMipmap(_),ce.updateMultisampleRenderTarget(_)),je.buffers.depth.setTest(!0),je.buffers.depth.setMask(!0),je.buffers.color.setMask(!0),je.setPolygonOffset(!1),f.pop(),f.length>0?d=f[f.length-1]:d=null,h=null};function tc(B,ie,te,oe){if(B.visible===!1)return;if(B.layers.test(ie.layers)){if(B.isGroup)te=B.renderOrder;else if(B.isLOD)B.autoUpdate===!0&&B.update(ie);else if(B.isLight)d.pushLight(B),B.castShadow&&d.pushShadow(B);else if(B.isSprite){if(!B.frustumCulled||J.intersectsSprite(B)){oe&&xe.setFromMatrixPosition(B.matrixWorld).applyMatrix4(re);const rt=_e.update(B),st=B.material;st.visible&&h.push(B,rt,st,te,xe.z,null)}}else if(B.isImmediateRenderObject)oe&&xe.setFromMatrixPosition(B.matrixWorld).applyMatrix4(re),h.push(B,null,B.material,te,xe.z,null);else if((B.isMesh||B.isLine||B.isPoints)&&(B.isSkinnedMesh&&B.skeleton.frame!==it.render.frame&&(B.skeleton.update(),B.skeleton.frame=it.render.frame),!B.frustumCulled||J.intersectsObject(B))){oe&&xe.setFromMatrixPosition(B.matrixWorld).applyMatrix4(re);const rt=_e.update(B),st=B.material;if(Array.isArray(st)){const ot=rt.groups;for(let Jt=0,Xt=ot.length;Jt<Xt;Jt++){const tt=ot[Jt],vt=st[tt.materialIndex];vt&&vt.visible&&h.push(B,rt,vt,te,xe.z,tt)}}else st.visible&&h.push(B,rt,st,te,xe.z,null)}}const ct=B.children;for(let rt=0,st=ct.length;rt<st;rt++)tc(ct[rt],ie,te,oe)}function Zu(B,ie,te){const oe=ie.isScene===!0?ie.overrideMaterial:null;for(let ge=0,ct=B.length;ge<ct;ge++){const rt=B[ge],st=rt.object,ot=rt.geometry,Jt=oe===null?rt.material:oe,Xt=rt.group;if(te.isArrayCamera){const tt=te.cameras;for(let vt=0,yi=tt.length;vt<yi;vt++){const Nt=tt[vt];st.layers.test(Nt.layers)&&(je.viewport(T.copy(Nt.viewport)),d.setupLightsView(Nt),nc(st,ie,Nt,ot,Jt,Xt))}}else nc(st,ie,te,ot,Jt,Xt)}}function nc(B,ie,te,oe,ge,ct){if(B.onBeforeRender(p,ie,te,oe,ge,ct),B.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse,B.matrixWorld),B.normalMatrix.getNormalMatrix(B.modelViewMatrix),B.isImmediateRenderObject){const rt=ic(te,ie,ge,B);je.setMaterial(ge),Be.reset(),yo(B,rt)}else p.renderBufferDirect(te,ie,oe,ge,B,ct);B.onAfterRender(p,ie,te,oe,ge,ct)}function ki(B,ie,te){ie.isScene!==!0&&(ie=Ae);const oe=qe.get(B),ge=d.state.lights,ct=d.state.shadowsArray,rt=ge.state.version,st=z.getParameters(B,ge.state,ct,ie,te),ot=z.getProgramCacheKey(st);let Jt=oe.program,Xt=!0;if(oe.environment=B.isMeshStandardMaterial?ie.environment:null,oe.fog=ie.fog,oe.envMap=ve.get(B.envMap||oe.environment),Jt===void 0)B.addEventListener("dispose",pn);else if(Jt.cacheKey!==ot)Di(B);else if(oe.lightsStateVersion!==rt)Xt=!1;else{if(st.shaderID!==void 0)return;Xt=!1}Xt&&(st.uniforms=z.getUniforms(B),B.onBeforeCompile(st,p),Jt=z.acquireProgram(st,ot),oe.program=Jt,oe.uniforms=st.uniforms,oe.outputEncoding=st.outputEncoding);const tt=oe.uniforms;(!B.isShaderMaterial&&!B.isRawShaderMaterial||B.clipping===!0)&&(oe.numClippingPlanes=j.numPlanes,oe.numIntersection=j.numIntersection,tt.clippingPlanes=j.uniform),oe.needsLights=Ea(B),oe.lightsStateVersion=rt,oe.needsLights&&(tt.ambientLightColor.value=ge.state.ambient,tt.lightProbe.value=ge.state.probe,tt.directionalLights.value=ge.state.directional,tt.directionalLightShadows.value=ge.state.directionalShadow,tt.spotLights.value=ge.state.spot,tt.spotLightShadows.value=ge.state.spotShadow,tt.rectAreaLights.value=ge.state.rectArea,tt.ltc_1.value=ge.state.rectAreaLTC1,tt.ltc_2.value=ge.state.rectAreaLTC2,tt.pointLights.value=ge.state.point,tt.pointLightShadows.value=ge.state.pointShadow,tt.hemisphereLights.value=ge.state.hemi,tt.directionalShadowMap.value=ge.state.directionalShadowMap,tt.directionalShadowMatrix.value=ge.state.directionalShadowMatrix,tt.spotShadowMap.value=ge.state.spotShadowMap,tt.spotShadowMatrix.value=ge.state.spotShadowMatrix,tt.pointShadowMap.value=ge.state.pointShadowMap,tt.pointShadowMatrix.value=ge.state.pointShadowMatrix);const vt=oe.program.getUniforms(),yi=Xs.seqWithValue(vt.seq,tt);oe.uniformsList=yi}function ic(B,ie,te,oe){ie.isScene!==!0&&(ie=Ae),ce.resetTextureUnits();const ge=ie.fog,ct=te.isMeshStandardMaterial?ie.environment:null,rt=_===null?p.outputEncoding:_.texture.encoding,st=ve.get(te.envMap||ct),ot=qe.get(te),Jt=d.state.lights;if(W===!0&&(Q===!0||B!==w)){const At=B===w&&te.id===S;j.setState(te,B,At)}te.version===ot.__version?(te.fog&&ot.fog!==ge||ot.environment!==ct||ot.needsLights&&ot.lightsStateVersion!==Jt.state.version||ot.numClippingPlanes!==void 0&&(ot.numClippingPlanes!==j.numPlanes||ot.numIntersection!==j.numIntersection)||ot.outputEncoding!==rt||ot.envMap!==st)&&ki(te,ie,oe):(ki(te,ie,oe),ot.__version=te.version);let Xt=!1,tt=!1,vt=!1;const yi=ot.program,Nt=yi.getUniforms(),mn=ot.uniforms;if(je.useProgram(yi.program)&&(Xt=!0,tt=!0,vt=!0),te.id!==S&&(S=te.id,tt=!0),Xt||w!==B){if(Nt.setValue(se,"projectionMatrix",B.projectionMatrix),at.logarithmicDepthBuffer&&Nt.setValue(se,"logDepthBufFC",2/(Math.log(B.far+1)/Math.LN2)),w!==B&&(w=B,tt=!0,vt=!0),te.isShaderMaterial||te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshStandardMaterial||te.envMap){const At=Nt.map.cameraPosition;At!==void 0&&At.setValue(se,xe.setFromMatrixPosition(B.matrixWorld))}(te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshLambertMaterial||te.isMeshBasicMaterial||te.isMeshStandardMaterial||te.isShaderMaterial)&&Nt.setValue(se,"isOrthographic",B.isOrthographicCamera===!0),(te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshLambertMaterial||te.isMeshBasicMaterial||te.isMeshStandardMaterial||te.isShaderMaterial||te.isShadowMaterial||te.skinning)&&Nt.setValue(se,"viewMatrix",B.matrixWorldInverse)}if(te.skinning){Nt.setOptional(se,oe,"bindMatrix"),Nt.setOptional(se,oe,"bindMatrixInverse");const At=oe.skeleton;if(At){const rc=At.bones;if(at.floatVertexTextures){if(At.boneTexture===null){let $n=Math.sqrt(rc.length*4);$n=Ze.ceilPowerOfTwo($n),$n=Math.max($n,4);const Ss=new Float32Array($n*$n*4);Ss.set(At.boneMatrices);const Yr=new ms(Ss,$n,$n,Mi,ls);At.boneMatrices=Ss,At.boneTexture=Yr,At.boneTextureSize=$n}Nt.setValue(se,"boneTexture",At.boneTexture,ce),Nt.setValue(se,"boneTextureSize",At.boneTextureSize)}else Nt.setOptional(se,At,"boneMatrices")}}return(tt||ot.receiveShadow!==oe.receiveShadow)&&(ot.receiveShadow=oe.receiveShadow,Nt.setValue(se,"receiveShadow",oe.receiveShadow)),tt&&(Nt.setValue(se,"toneMappingExposure",p.toneMappingExposure),ot.needsLights&&li(mn,vt),ge&&te.fog&&F.refreshFogUniforms(mn,ge),F.refreshMaterialUniforms(mn,te,$,L),Xs.upload(se,ot.uniformsList,mn,ce)),te.isShaderMaterial&&te.uniformsNeedUpdate===!0&&(Xs.upload(se,ot.uniformsList,mn,ce),te.uniformsNeedUpdate=!1),te.isSpriteMaterial&&Nt.setValue(se,"center",oe.center),Nt.setValue(se,"modelViewMatrix",oe.modelViewMatrix),Nt.setValue(se,"normalMatrix",oe.normalMatrix),Nt.setValue(se,"modelMatrix",oe.matrixWorld),yi}function li(B,ie){B.ambientLightColor.needsUpdate=ie,B.lightProbe.needsUpdate=ie,B.directionalLights.needsUpdate=ie,B.directionalLightShadows.needsUpdate=ie,B.pointLights.needsUpdate=ie,B.pointLightShadows.needsUpdate=ie,B.spotLights.needsUpdate=ie,B.spotLightShadows.needsUpdate=ie,B.rectAreaLights.needsUpdate=ie,B.hemisphereLights.needsUpdate=ie}function Ea(B){return B.isMeshLambertMaterial||B.isMeshToonMaterial||B.isMeshPhongMaterial||B.isMeshStandardMaterial||B.isShadowMaterial||B.isShaderMaterial&&B.lights===!0}this.setFramebuffer=function(B){y!==B&&_===null&&se.bindFramebuffer(36160,B),y=B},this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return v},this.getRenderList=function(){return h},this.setRenderList=function(B){h=B},this.getRenderTarget=function(){return _},this.setRenderTarget=function(B,ie=0,te=0){_=B,g=ie,v=te,B&&qe.get(B).__webglFramebuffer===void 0&&ce.setupRenderTarget(B);let oe=y,ge=!1;if(B){const ct=qe.get(B).__webglFramebuffer;B.isWebGLCubeRenderTarget?(oe=ct[ie],ge=!0):B.isWebGLMultisampleRenderTarget?oe=qe.get(B).__webglMultisampledFramebuffer:oe=ct,T.copy(B.viewport),R.copy(B.scissor),M=B.scissorTest}else T.copy(N).multiplyScalar($).floor(),R.copy(V).multiplyScalar($).floor(),M=X;if(b!==oe&&(se.bindFramebuffer(36160,oe),b=oe),je.viewport(T),je.scissor(R),je.setScissorTest(M),ge){const ct=qe.get(B.texture);se.framebufferTexture2D(36160,36064,34069+ie,ct.__webglTexture,te)}},this.readRenderTargetPixels=function(B,ie,te,oe,ge,ct,rt){if(!(B&&B.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let st=qe.get(B).__webglFramebuffer;if(B.isWebGLCubeRenderTarget&&rt!==void 0&&(st=st[rt]),st){let ot=!1;st!==b&&(se.bindFramebuffer(36160,st),ot=!0);try{const Jt=B.texture,Xt=Jt.format,tt=Jt.type;if(Xt!==Mi&&Pe.convert(Xt)!==se.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const vt=tt===Jc&&(Ie.has("EXT_color_buffer_half_float")||at.isWebGL2&&Ie.has("EXT_color_buffer_float"));if(tt!==Zl&&Pe.convert(tt)!==se.getParameter(35738)&&!(tt===ls&&(at.isWebGL2||Ie.has("OES_texture_float")||Ie.has("WEBGL_color_buffer_float")))&&!vt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}se.checkFramebufferStatus(36160)===36053?ie>=0&&ie<=B.width-oe&&te>=0&&te<=B.height-ge&&se.readPixels(ie,te,oe,ge,Pe.convert(Xt),Pe.convert(tt),ct):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{ot&&se.bindFramebuffer(36160,b)}}},this.copyFramebufferToTexture=function(B,ie,te=0){const oe=Math.pow(2,-te),ge=Math.floor(ie.image.width*oe),ct=Math.floor(ie.image.height*oe),rt=Pe.convert(ie.format);ce.setTexture2D(ie,0),se.copyTexImage2D(3553,te,rt,B.x,B.y,ge,ct,0),je.unbindTexture()},this.copyTextureToTexture=function(B,ie,te,oe=0){const ge=ie.image.width,ct=ie.image.height,rt=Pe.convert(te.format),st=Pe.convert(te.type);ce.setTexture2D(te,0),se.pixelStorei(37440,te.flipY),se.pixelStorei(37441,te.premultiplyAlpha),se.pixelStorei(3317,te.unpackAlignment),ie.isDataTexture?se.texSubImage2D(3553,oe,B.x,B.y,ge,ct,rt,st,ie.image.data):ie.isCompressedTexture?se.compressedTexSubImage2D(3553,oe,B.x,B.y,ie.mipmaps[0].width,ie.mipmaps[0].height,rt,ie.mipmaps[0].data):se.texSubImage2D(3553,oe,B.x,B.y,rt,st,ie.image),oe===0&&te.generateMipmaps&&se.generateMipmap(3553),je.unbindTexture()},this.initTexture=function(B){ce.setTexture2D(B,0),je.unbindTexture()},this.resetState=function(){je.reset(),Be.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Hg(n){ju.call(this,n)}Hg.prototype=Object.assign(Object.create(ju.prototype),{constructor:Hg,isWebGL1Renderer:!0});class qf{constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new Ne(e),this.density=t!==void 0?t:25e-5}clone(){return new qf(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Xf{constructor(e,t,i){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new Ne(e),this.near=t!==void 0?t:1,this.far=i!==void 0?i:1e3}clone(){return new Xf(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class hv extends ze{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}function Ci(n,e){this.array=n,this.stride=e,this.count=n!==void 0?n.length/e:0,this.usage=Hu,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ze.generateUUID()}Object.defineProperty(Ci.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Ci.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.stride,t*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[n+i]=e.array[t+i];return this},set:function(n,e=0){return this.array.set(n,e),this},clone:function(n){n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ze.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new Ci(e,this.stride);return t.setUsage(this.usage),t},onUpload:function(n){return this.onUploadCallback=n,this},toJSON:function(n){return n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ze.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const wo=new k;function so(n,e,t,i){this.name="",this.data=n,this.itemSize=e,this.offset=t,this.normalized=i===!0}Object.defineProperties(so.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(n){this.data.needsUpdate=n}}});Object.assign(so.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(n){for(let e=0,t=this.data.count;e<t;e++)wo.x=this.getX(e),wo.y=this.getY(e),wo.z=this.getZ(e),wo.applyMatrix4(n),this.setXYZ(e,wo.x,wo.y,wo.z);return this},setX:function(n,e){return this.data.array[n*this.data.stride+this.offset]=e,this},setY:function(n,e){return this.data.array[n*this.data.stride+this.offset+1]=e,this},setZ:function(n,e){return this.data.array[n*this.data.stride+this.offset+2]=e,this},setW:function(n,e){return this.data.array[n*this.data.stride+this.offset+3]=e,this},getX:function(n){return this.data.array[n*this.data.stride+this.offset]},getY:function(n){return this.data.array[n*this.data.stride+this.offset+1]},getZ:function(n){return this.data.array[n*this.data.stride+this.offset+2]},getW:function(n){return this.data.array[n*this.data.stride+this.offset+3]},setXY:function(n,e,t){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this},setXYZ:function(n,e,t,i){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=i,this},setXYZW:function(n,e,t,i,r){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=i,this.data.array[n+3]=r,this},clone:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const i=t*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return new Xe(new this.array.constructor(e),this.itemSize,this.normalized)}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new so(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const i=t*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function oo(n){Ye.call(this),this.type="SpriteMaterial",this.color=new Ne(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(n)}oo.prototype=Object.create(Ye.prototype);oo.prototype.constructor=oo;oo.prototype.isSpriteMaterial=!0;oo.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this};let Va;const pc=new k,Ga=new k,Ha=new k,Wa=new fe,mc=new fe,AA=new ut,Rh=new k,gc=new k,Ih=new k,v_=new fe,Jp=new fe,x_=new fe;function cu(n){if(ze.call(this),this.type="Sprite",Va===void 0){Va=new He;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new Ci(e,5);Va.setIndex([0,1,2,0,2,3]),Va.setAttribute("position",new so(t,3,0,!1)),Va.setAttribute("uv",new so(t,2,3,!1))}this.geometry=Va,this.material=n!==void 0?n:new oo,this.center=new fe(.5,.5)}cu.prototype=Object.assign(Object.create(ze.prototype),{constructor:cu,isSprite:!0,raycast:function(n,e){n.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ga.setFromMatrixScale(this.matrixWorld),AA.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),Ha.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Ga.multiplyScalar(-Ha.z);const t=this.material.rotation;let i,r;t!==0&&(r=Math.cos(t),i=Math.sin(t));const s=this.center;Ph(Rh.set(-.5,-.5,0),Ha,s,Ga,i,r),Ph(gc.set(.5,-.5,0),Ha,s,Ga,i,r),Ph(Ih.set(.5,.5,0),Ha,s,Ga,i,r),v_.set(0,0),Jp.set(1,0),x_.set(1,1);let o=n.ray.intersectTriangle(Rh,gc,Ih,!1,pc);if(o===null&&(Ph(gc.set(-.5,.5,0),Ha,s,Ga,i,r),Jp.set(0,1),o=n.ray.intersectTriangle(Rh,Ih,gc,!1,pc),o===null))return;const a=n.ray.origin.distanceTo(pc);a<n.near||a>n.far||e.push({distance:a,point:pc.clone(),uv:qn.getUV(pc,Rh,gc,Ih,v_,Jp,x_,new fe),face:null,object:this})},copy:function(n){return ze.prototype.copy.call(this,n),n.center!==void 0&&this.center.copy(n.center),this.material=n.material,this}});function Ph(n,e,t,i,r,s){Wa.subVectors(n,t).addScalar(.5).multiply(i),r!==void 0?(mc.x=s*Wa.x-r*Wa.y,mc.y=r*Wa.x+s*Wa.y):mc.copy(Wa),n.copy(e),n.x+=mc.x,n.y+=mc.y,n.applyMatrix4(AA)}const Nh=new k,__=new k;function uu(){ze.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}uu.prototype=Object.assign(Object.create(ze.prototype),{constructor:uu,isLOD:!0,copy:function(n){ze.prototype.copy.call(this,n,!1);const e=n.levels;for(let t=0,i=e.length;t<i;t++){const r=e[t];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=n.autoUpdate,this},addLevel:function(n,e=0){e=Math.abs(e);const t=this.levels;let i;for(i=0;i<t.length&&!(e<t[i].distance);i++);return t.splice(i,0,{distance:e,object:n}),this.add(n),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(n){const e=this.levels;if(e.length>0){let t,i;for(t=1,i=e.length;t<i&&!(n<e[t].distance);t++);return e[t-1].object}return null},raycast:function(n,e){if(this.levels.length>0){Nh.setFromMatrixPosition(this.matrixWorld);const i=n.ray.origin.distanceTo(Nh);this.getObjectForDistance(i).raycast(n,e)}},update:function(n){const e=this.levels;if(e.length>1){Nh.setFromMatrixPosition(n.matrixWorld),__.setFromMatrixPosition(this.matrixWorld);const t=Nh.distanceTo(__)/n.zoom;e[0].object.visible=!0;let i,r;for(i=1,r=e.length;i<r&&t>=e[i].distance;i++)e[i-1].object.visible=!1,e[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}},toJSON:function(n){const e=ze.prototype.toJSON.call(this,n);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const t=this.levels;for(let i=0,r=t.length;i<r;i++){const s=t[i];e.object.levels.push({object:s.object.uuid,distance:s.distance})}return e}});const b_=new k,w_=new kt,S_=new kt,JK=new k,T_=new ut;function hu(n,e){n&&n.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),jt.call(this,n,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ut,this.bindMatrixInverse=new ut}hu.prototype=Object.assign(Object.create(jt.prototype),{constructor:hu,isSkinnedMesh:!0,copy:function(n){return jt.prototype.copy.call(this,n),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this},bind:function(n,e){this.skeleton=n,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const n=new kt,e=this.geometry.attributes.skinWeight;for(let t=0,i=e.count;t<i;t++){n.x=e.getX(t),n.y=e.getY(t),n.z=e.getZ(t),n.w=e.getW(t);const r=1/n.manhattanLength();r!==1/0?n.multiplyScalar(r):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(n){jt.prototype.updateMatrixWorld.call(this,n),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(n,e){const t=this.skeleton,i=this.geometry;w_.fromBufferAttribute(i.attributes.skinIndex,n),S_.fromBufferAttribute(i.attributes.skinWeight,n),b_.fromBufferAttribute(i.attributes.position,n).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const s=S_.getComponent(r);if(s!==0){const o=w_.getComponent(r);T_.multiplyMatrices(t.bones[o].matrixWorld,t.boneInverses[o]),e.addScaledVector(JK.copy(b_).applyMatrix4(T_),s)}}return e.applyMatrix4(this.bindMatrixInverse)}});function du(){ze.call(this),this.type="Bone"}du.prototype=Object.assign(Object.create(ze.prototype),{constructor:du,isBone:!0});const E_=new ut,QK=new ut;function fu(n=[],e=[]){this.uuid=Ze.generateUUID(),this.bones=n.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(fu.prototype,{init:function(){const n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(n.length*16),e.length===0)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,i=this.bones.length;t<i;t++)this.boneInverses.push(new ut)}},calculateInverses:function(){this.boneInverses.length=0;for(let n=0,e=this.bones.length;n<e;n++){const t=new ut;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}},pose:function(){for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const n=this.bones,e=this.boneInverses,t=this.boneMatrices,i=this.boneTexture;for(let r=0,s=n.length;r<s;r++){const o=n[r]?n[r].matrixWorld:QK;E_.multiplyMatrices(o,e[r]),E_.toArray(t,r*16)}i!==null&&(i.needsUpdate=!0)},clone:function(){return new fu(this.bones,this.boneInverses)},getBoneByName:function(n){for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];if(i.name===n)return i}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(n,e){this.uuid=n.uuid;for(let t=0,i=n.bones.length;t<i;t++){const r=n.bones[t];let s=e[r];s===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),s=new du),this.bones.push(s),this.boneInverses.push(new ut().fromArray(n.boneInverses[t]))}return this.init(),this},toJSON:function(){const n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const s=e[i];n.bones.push(s.uuid);const o=t[i];n.boneInverses.push(o.toArray())}return n}});const C_=new ut,M_=new ut,Lh=[],yc=new jt;function Ud(n,e,t){jt.call(this,n,e),this.instanceMatrix=new Xe(new Float32Array(t*16),16),this.instanceColor=null,this.count=t,this.frustumCulled=!1}Ud.prototype=Object.assign(Object.create(jt.prototype),{constructor:Ud,isInstancedMesh:!0,copy:function(n){return jt.prototype.copy.call(this,n),this.instanceMatrix.copy(n.instanceMatrix),n.instanceColor!==null&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this},getColorAt:function(n,e){e.fromArray(this.instanceColor.array,n*3)},getMatrixAt:function(n,e){e.fromArray(this.instanceMatrix.array,n*16)},raycast:function(n,e){const t=this.matrixWorld,i=this.count;if(yc.geometry=this.geometry,yc.material=this.material,yc.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,C_),M_.multiplyMatrices(t,C_),yc.matrixWorld=M_,yc.raycast(n,Lh);for(let s=0,o=Lh.length;s<o;s++){const a=Lh[s];a.instanceId=r,a.object=this,e.push(a)}Lh.length=0}},setColorAt:function(n,e){this.instanceColor===null&&(this.instanceColor=new Xe(new Float32Array(this.count*3),3)),e.toArray(this.instanceColor.array,n*3)},setMatrixAt:function(n,e){e.toArray(this.instanceMatrix.array,n*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});function Zt(n){Ye.call(this),this.type="LineBasicMaterial",this.color=new Ne(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(n)}Zt.prototype=Object.create(Ye.prototype);Zt.prototype.constructor=Zt;Zt.prototype.isLineBasicMaterial=!0;Zt.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.morphTargets=n.morphTargets,this};const A_=new k,R_=new k,I_=new ut,Qp=new Jl,Dh=new go;function Zi(n=new He,e=new Zt){ze.call(this),this.type="Line",this.geometry=n,this.material=e,this.updateMorphTargets()}Zi.prototype=Object.assign(Object.create(ze.prototype),{constructor:Zi,isLine:!0,copy:function(n){return ze.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[0];for(let i=1,r=e.count;i<r;i++)A_.fromBufferAttribute(e,i-1),R_.fromBufferAttribute(e,i),t[i]=t[i-1],t[i]+=A_.distanceTo(R_);n.setAttribute("lineDistance",new Le(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(n,e){const t=this.geometry,i=this.matrixWorld,r=n.params.Line.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),Dh.copy(t.boundingSphere),Dh.applyMatrix4(i),Dh.radius+=r,n.ray.intersectsSphere(Dh)===!1)return;I_.copy(i).invert(),Qp.copy(n.ray).applyMatrix4(I_);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new k,l=new k,c=new k,u=new k,h=this.isLineSegments?2:1;if(t.isBufferGeometry){const d=t.index,p=t.attributes.position;if(d!==null){const m=d.array;for(let y=0,g=m.length-1;y<g;y+=h){const v=m[y],_=m[y+1];if(a.fromBufferAttribute(p,v),l.fromBufferAttribute(p,_),Qp.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const S=n.ray.origin.distanceTo(u);S<n.near||S>n.far||e.push({distance:S,point:c.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}else for(let m=0,y=p.count-1;m<y;m+=h){if(a.fromBufferAttribute(p,m),l.fromBufferAttribute(p,m+1),Qp.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const v=n.ray.origin.distanceTo(u);v<n.near||v>n.far||e.push({distance:v,point:c.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else t.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const i=e[t[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const P_=new k,N_=new k;function oi(n,e){Zi.call(this,n,e),this.type="LineSegments"}oi.prototype=Object.assign(Object.create(Zi.prototype),{constructor:oi,isLineSegments:!0,computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[];for(let i=0,r=e.count;i<r;i+=2)P_.fromBufferAttribute(e,i),N_.fromBufferAttribute(e,i+1),t[i]=i===0?0:t[i-1],t[i+1]=t[i]+P_.distanceTo(N_);n.setAttribute("lineDistance",new Le(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});function Vd(n,e){Zi.call(this,n,e),this.type="LineLoop"}Vd.prototype=Object.assign(Object.create(Zi.prototype),{constructor:Vd,isLineLoop:!0});function Tr(n){Ye.call(this),this.type="PointsMaterial",this.color=new Ne(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(n)}Tr.prototype=Object.create(Ye.prototype);Tr.prototype.constructor=Tr;Tr.prototype.isPointsMaterial=!0;Tr.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.morphTargets=n.morphTargets,this};const L_=new ut,Wg=new Jl,kh=new go,Oh=new k;function Ml(n=new He,e=new Tr){ze.call(this),this.type="Points",this.geometry=n,this.material=e,this.updateMorphTargets()}Ml.prototype=Object.assign(Object.create(ze.prototype),{constructor:Ml,isPoints:!0,copy:function(n){return ze.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},raycast:function(n,e){const t=this.geometry,i=this.matrixWorld,r=n.params.Points.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),kh.copy(t.boundingSphere),kh.applyMatrix4(i),kh.radius+=r,n.ray.intersectsSphere(kh)===!1)return;L_.copy(i).invert(),Wg.copy(n.ray).applyMatrix4(L_);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(t.isBufferGeometry){const a=t.index,c=t.attributes.position;if(a!==null){const u=a.array;for(let h=0,d=u.length;h<d;h++){const f=u[h];Oh.fromBufferAttribute(c,f),D_(Oh,f,o,i,n,e,this)}}else for(let u=0,h=c.count;u<h;u++)Oh.fromBufferAttribute(c,u),D_(Oh,u,o,i,n,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const i=e[t[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function D_(n,e,t,i,r,s,o){const a=Wg.distanceSqToPoint(n);if(a<t){const l=new k;Wg.closestPointToPoint(n,l),l.applyMatrix4(i);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}function jg(n,e,t,i,r,s,o,a,l){Bt.call(this,n,e,t,i,r,s,o,a,l),this.format=o!==void 0?o:js,this.minFilter=s!==void 0?s:Cn,this.magFilter=r!==void 0?r:Cn,this.generateMipmaps=!1;const c=this;function u(){c.needsUpdate=!0,n.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(u)}jg.prototype=Object.assign(Object.create(Bt.prototype),{constructor:jg,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const n=this.image;"requestVideoFrameCallback"in n===!1&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function Al(n,e,t,i,r,s,o,a,l,c,u,h){Bt.call(this,null,s,o,a,l,c,i,r,u,h),this.image={width:e,height:t},this.mipmaps=n,this.flipY=!1,this.generateMipmaps=!1}Al.prototype=Object.create(Bt.prototype);Al.prototype.constructor=Al;Al.prototype.isCompressedTexture=!0;function pu(n,e,t,i,r,s,o,a,l){Bt.call(this,n,e,t,i,r,s,o,a,l),this.needsUpdate=!0}pu.prototype=Object.create(Bt.prototype);pu.prototype.constructor=pu;pu.prototype.isCanvasTexture=!0;function mu(n,e,t,i,r,s,o,a,l,c){if(c=c!==void 0?c:Xo,c!==Xo&&c!==Sl)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&c===Xo&&(t=Zc),t===void 0&&c===Sl&&(t=hl),Bt.call(this,null,i,r,s,o,a,c,t,l),this.image={width:n,height:e},this.magFilter=o!==void 0?o:bn,this.minFilter=a!==void 0?a:bn,this.flipY=!1,this.generateMipmaps=!1}mu.prototype=Object.create(Bt.prototype);mu.prototype.constructor=mu;mu.prototype.isDepthTexture=!0;class Gd extends He{constructor(e=1,t=8,i=0,r=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:r},t=Math.max(3,t);const s=[],o=[],a=[],l=[],c=new k,u=new fe;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const f=i+h/t*r;c.x=e*Math.cos(f),c.y=e*Math.sin(f),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[d]/e+1)/2,u.y=(o[d+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)s.push(h,h+1,0);this.setIndex(s),this.setAttribute("position",new Le(o,3)),this.setAttribute("normal",new Le(a,3)),this.setAttribute("uv",new Le(l,2))}}class Rl extends He{constructor(e=1,t=1,i=1,r=8,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:r,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;r=Math.floor(r),s=Math.floor(s);const u=[],h=[],d=[],f=[];let p=0;const m=[],y=i/2;let g=0;v(),o===!1&&(e>0&&_(!0),t>0&&_(!1)),this.setIndex(u),this.setAttribute("position",new Le(h,3)),this.setAttribute("normal",new Le(d,3)),this.setAttribute("uv",new Le(f,2));function v(){const b=new k,S=new k;let w=0;const T=(t-e)/i;for(let R=0;R<=s;R++){const M=[],P=R/s,L=P*(t-e)+e;for(let $=0;$<=r;$++){const O=$/r,I=O*l+a,N=Math.sin(I),V=Math.cos(I);S.x=L*N,S.y=-P*i+y,S.z=L*V,h.push(S.x,S.y,S.z),b.set(N,T,V).normalize(),d.push(b.x,b.y,b.z),f.push(O,1-P),M.push(p++)}m.push(M)}for(let R=0;R<r;R++)for(let M=0;M<s;M++){const P=m[M][R],L=m[M+1][R],$=m[M+1][R+1],O=m[M][R+1];u.push(P,L,O),u.push(L,$,O),w+=6}c.addGroup(g,w,0),g+=w}function _(b){const S=p,w=new fe,T=new k;let R=0;const M=b===!0?e:t,P=b===!0?1:-1;for(let $=1;$<=r;$++)h.push(0,y*P,0),d.push(0,P,0),f.push(.5,.5),p++;const L=p;for(let $=0;$<=r;$++){const I=$/r*l+a,N=Math.cos(I),V=Math.sin(I);T.x=M*V,T.y=y*P,T.z=M*N,h.push(T.x,T.y,T.z),d.push(0,P,0),w.x=N*.5+.5,w.y=V*.5*P+.5,f.push(w.x,w.y),p++}for(let $=0;$<r;$++){const O=S+$,I=L+$;b===!0?u.push(I,I+1,O):u.push(I+1,I,O),R+=3}c.addGroup(g,R,b===!0?1:2),g+=R}}}class Hd extends Rl{constructor(e=1,t=1,i=8,r=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,i,r,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:a}}}class ao extends He{constructor(e,t,i=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:r};const s=[],o=[];a(r),c(i),u(),this.setAttribute("position",new Le(s,3)),this.setAttribute("normal",new Le(s.slice(),3)),this.setAttribute("uv",new Le(o,2)),r===0?this.computeVertexNormals():this.normalizeNormals();function a(v){const _=new k,b=new k,S=new k;for(let w=0;w<t.length;w+=3)f(t[w+0],_),f(t[w+1],b),f(t[w+2],S),l(_,b,S,v)}function l(v,_,b,S){const w=S+1,T=[];for(let R=0;R<=w;R++){T[R]=[];const M=v.clone().lerp(b,R/w),P=_.clone().lerp(b,R/w),L=w-R;for(let $=0;$<=L;$++)$===0&&R===w?T[R][$]=M:T[R][$]=M.clone().lerp(P,$/L)}for(let R=0;R<w;R++)for(let M=0;M<2*(w-R)-1;M++){const P=Math.floor(M/2);M%2===0?(d(T[R][P+1]),d(T[R+1][P]),d(T[R][P])):(d(T[R][P+1]),d(T[R+1][P+1]),d(T[R+1][P]))}}function c(v){const _=new k;for(let b=0;b<s.length;b+=3)_.x=s[b+0],_.y=s[b+1],_.z=s[b+2],_.normalize().multiplyScalar(v),s[b+0]=_.x,s[b+1]=_.y,s[b+2]=_.z}function u(){const v=new k;for(let _=0;_<s.length;_+=3){v.x=s[_+0],v.y=s[_+1],v.z=s[_+2];const b=y(v)/2/Math.PI+.5,S=g(v)/Math.PI+.5;o.push(b,1-S)}p(),h()}function h(){for(let v=0;v<o.length;v+=6){const _=o[v+0],b=o[v+2],S=o[v+4],w=Math.max(_,b,S),T=Math.min(_,b,S);w>.9&&T<.1&&(_<.2&&(o[v+0]+=1),b<.2&&(o[v+2]+=1),S<.2&&(o[v+4]+=1))}}function d(v){s.push(v.x,v.y,v.z)}function f(v,_){const b=v*3;_.x=e[b+0],_.y=e[b+1],_.z=e[b+2]}function p(){const v=new k,_=new k,b=new k,S=new k,w=new fe,T=new fe,R=new fe;for(let M=0,P=0;M<s.length;M+=9,P+=6){v.set(s[M+0],s[M+1],s[M+2]),_.set(s[M+3],s[M+4],s[M+5]),b.set(s[M+6],s[M+7],s[M+8]),w.set(o[P+0],o[P+1]),T.set(o[P+2],o[P+3]),R.set(o[P+4],o[P+5]),S.copy(v).add(_).add(b).divideScalar(3);const L=y(S);m(w,P+0,v,L),m(T,P+2,_,L),m(R,P+4,b,L)}}function m(v,_,b,S){S<0&&v.x===1&&(o[_]=v.x-1),b.x===0&&b.z===0&&(o[_]=S/2/Math.PI+.5)}function y(v){return Math.atan2(v.z,-v.x)}function g(v){return Math.atan2(-v.y,Math.sqrt(v.x*v.x+v.z*v.z))}}}class Wd extends ao{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=1/i,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-i,0,-r,i,0,r,-i,0,r,i,-r,-i,0,-r,i,0,r,-i,0,r,i,0,-i,0,-r,i,0,-r,-i,0,r,i,0,r],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const Fh=new k,$h=new k,em=new k,Bh=new qn;class dv extends He{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0){console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const r=Math.pow(10,4),s=Math.cos(Ze.DEG2RAD*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),d={},f=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:y,c:g}=Bh;if(m.fromBufferAttribute(a,c[0]),y.fromBufferAttribute(a,c[1]),g.fromBufferAttribute(a,c[2]),Bh.getNormal(em),h[0]=`${Math.round(m.x*r)},${Math.round(m.y*r)},${Math.round(m.z*r)}`,h[1]=`${Math.round(y.x*r)},${Math.round(y.y*r)},${Math.round(y.z*r)}`,h[2]=`${Math.round(g.x*r)},${Math.round(g.y*r)},${Math.round(g.z*r)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let v=0;v<3;v++){const _=(v+1)%3,b=h[v],S=h[_],w=Bh[u[v]],T=Bh[u[_]],R=`${b}_${S}`,M=`${S}_${b}`;M in d&&d[M]?(em.dot(d[M].normal)<=s&&(f.push(w.x,w.y,w.z),f.push(T.x,T.y,T.z)),d[M]=null):R in d||(d[R]={index0:c[v],index1:c[_],normal:em.clone()})}}for(const p in d)if(d[p]){const{index0:m,index1:y}=d[p];Fh.fromBufferAttribute(a,m),$h.fromBufferAttribute(a,y),f.push(Fh.x,Fh.y,Fh.z),f.push($h.x,$h.y,$h.z)}this.setAttribute("position",new Le(f,3))}}const eZ={triangulate:function(n,e,t){t=t||2;const i=e&&e.length,r=i?e[0]*t:n.length;let s=RA(n,0,r,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,h,d,f;if(i&&(s=sZ(n,e,s,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let p=t;p<r;p+=t)h=n[p],d=n[p+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);f=Math.max(c-a,u-l),f=f!==0?1/f:0}return gu(s,o,t,a,l,f),o}};function RA(n,e,t,i,r){let s,o;if(r===gZ(n,e,t,i)>0)for(s=e;s<t;s+=i)o=k_(s,n[s],n[s+1],o);else for(s=t-i;s>=e;s-=i)o=k_(s,n[s],n[s+1],o);return o&&Yf(o,o.next)&&(vu(o),o=o.next),o}function lo(n,e){if(!n)return n;e||(e=n);let t=n,i;do if(i=!1,!t.steiner&&(Yf(t,t.next)||en(t.prev,t,t.next)===0)){if(vu(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e}function gu(n,e,t,i,r,s,o){if(!n)return;!o&&s&&uZ(n,i,r,s);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,s?nZ(n,i,r,s):tZ(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),vu(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=iZ(lo(n),e,t),gu(n,e,t,i,r,s,2)):o===2&&rZ(n,e,t,i,r,s):gu(lo(n),e,t,i,r,s,1);break}}}function tZ(n){const e=n.prev,t=n,i=n.next;if(en(e,t,i)>=0)return!1;let r=n.next.next;for(;r!==n.prev;){if(sl(e.x,e.y,t.x,t.y,i.x,i.y,r.x,r.y)&&en(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function nZ(n,e,t,i){const r=n.prev,s=n,o=n.next;if(en(r,s,o)>=0)return!1;const a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,l=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,c=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,u=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,h=qg(a,l,e,t,i),d=qg(c,u,e,t,i);let f=n.prevZ,p=n.nextZ;for(;f&&f.z>=h&&p&&p.z<=d;){if(f!==n.prev&&f!==n.next&&sl(r.x,r.y,s.x,s.y,o.x,o.y,f.x,f.y)&&en(f.prev,f,f.next)>=0||(f=f.prevZ,p!==n.prev&&p!==n.next&&sl(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&en(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=h;){if(f!==n.prev&&f!==n.next&&sl(r.x,r.y,s.x,s.y,o.x,o.y,f.x,f.y)&&en(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==n.prev&&p!==n.next&&sl(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&en(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function iZ(n,e,t){let i=n;do{const r=i.prev,s=i.next.next;!Yf(r,s)&&IA(r,i,i.next,s)&&yu(r,s)&&yu(s,r)&&(e.push(r.i/t),e.push(i.i/t),e.push(s.i/t),vu(i),vu(i.next),i=n=s),i=i.next}while(i!==n);return lo(i)}function rZ(n,e,t,i,r,s){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&fZ(o,a)){let l=PA(o,a);o=lo(o,o.next),l=lo(l,l.next),gu(o,e,t,i,r,s),gu(l,e,t,i,r,s);return}a=a.next}o=o.next}while(o!==n)}function sZ(n,e,t,i){const r=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:n.length,c=RA(n,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(dZ(c));for(r.sort(oZ),s=0;s<r.length;s++)aZ(r[s],t),t=lo(t,t.next);return t}function oZ(n,e){return n.x-e.x}function aZ(n,e){if(e=lZ(n,e),e){const t=PA(e,n);lo(e,e.next),lo(t,t.next)}}function lZ(n,e){let t=e;const i=n.x,r=n.y;let s=-1/0,o;do{if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){const d=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=i&&d>s){if(s=d,d===i){if(r===t.y)return t;if(r===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(i===s)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do i>=t.x&&t.x>=l&&i!==t.x&&sl(r<c?i:s,r,l,c,r<c?s:i,r,t.x,t.y)&&(h=Math.abs(r-t.y)/(i-t.x),yu(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&cZ(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function cZ(n,e){return en(n.prev,n,e.prev)<0&&en(e.next,n,n.next)<0}function uZ(n,e,t,i){let r=n;do r.z===null&&(r.z=qg(r.x,r.y,e,t,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,hZ(r)}function hZ(n){let e,t,i,r,s,o,a,l,c=1;do{for(t=n,n=null,s=null,o=0;t;){for(o++,i=t,a=0,e=0;e<c&&(a++,i=i.nextZ,!!i);e++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||t.z<=i.z)?(r=t,t=t.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:n=r,r.prevZ=s,s=r;t=i}s.nextZ=null,c*=2}while(o>1);return n}function qg(n,e,t,i,r){return n=32767*(n-t)*r,e=32767*(e-i)*r,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function dZ(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function sl(n,e,t,i,r,s,o,a){return(r-o)*(e-a)-(n-o)*(s-a)>=0&&(n-o)*(i-a)-(t-o)*(e-a)>=0&&(t-o)*(s-a)-(r-o)*(i-a)>=0}function fZ(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!pZ(n,e)&&(yu(n,e)&&yu(e,n)&&mZ(n,e)&&(en(n.prev,n,e.prev)||en(n,e.prev,e))||Yf(n,e)&&en(n.prev,n,n.next)>0&&en(e.prev,e,e.next)>0)}function en(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Yf(n,e){return n.x===e.x&&n.y===e.y}function IA(n,e,t,i){const r=Uh(en(n,e,t)),s=Uh(en(n,e,i)),o=Uh(en(t,i,n)),a=Uh(en(t,i,e));return!!(r!==s&&o!==a||r===0&&zh(n,t,e)||s===0&&zh(n,i,e)||o===0&&zh(t,n,i)||a===0&&zh(t,e,i))}function zh(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Uh(n){return n>0?1:n<0?-1:0}function pZ(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&IA(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function yu(n,e){return en(n.prev,n,n.next)<0?en(n,e,n.next)>=0&&en(n,n.prev,e)>=0:en(n,e,n.prev)<0||en(n,n.next,e)<0}function mZ(n,e){let t=n,i=!1;const r=(n.x+e.x)/2,s=(n.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&r<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==n);return i}function PA(n,e){const t=new Xg(n.i,n.x,n.y),i=new Xg(e.i,e.x,e.y),r=n.next,s=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,i.next=t,t.prev=i,s.next=i,i.prev=s,i}function k_(n,e,t,i){const r=new Xg(n,e,t);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function vu(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Xg(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function gZ(n,e,t,i){let r=0;for(let s=e,o=t-i;s<t;s+=i)r+=(n[o]-n[s])*(n[s+1]+n[o+1]),o=s;return r}const ds={area:function(n){const e=n.length;let t=0;for(let i=e-1,r=0;r<e;i=r++)t+=n[i].x*n[r].y-n[r].x*n[i].y;return t*.5},isClockWise:function(n){return ds.area(n)<0},triangulateShape:function(n,e){const t=[],i=[],r=[];O_(n),F_(t,n);let s=n.length;e.forEach(O_);for(let a=0;a<e.length;a++)i.push(s),s+=e[a].length,F_(t,e[a]);const o=eZ.triangulate(t,i);for(let a=0;a<o.length;a+=3)r.push(o.slice(a,a+3));return r}};function O_(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function F_(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class oa extends He{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const i=this,r=[],s=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new Le(r,3)),this.setAttribute("uv",new Le(s,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:100,d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:6,p=t.bevelSize!==void 0?t.bevelSize:f-2,m=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const g=t.extrudePath,v=t.UVGenerator!==void 0?t.UVGenerator:yZ;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let _,b=!1,S,w,T,R;g&&(_=g.getSpacedPoints(u),b=!0,d=!1,S=g.computeFrenetFrames(u,!1),w=new k,T=new k,R=new k),d||(y=0,f=0,p=0,m=0);const M=a.extractPoints(c);let P=M.shape;const L=M.holes;if(!ds.isClockWise(P)){P=P.reverse();for(let ce=0,ve=L.length;ce<ve;ce++){const be=L[ce];ds.isClockWise(be)&&(L[ce]=be.reverse())}}const O=ds.triangulateShape(P,L),I=P;for(let ce=0,ve=L.length;ce<ve;ce++){const be=L[ce];P=P.concat(be)}function N(ce,ve,be){return ve||console.error("THREE.ExtrudeGeometry: vec does not exist"),ve.clone().multiplyScalar(be).add(ce)}const V=P.length,X=O.length;function J(ce,ve,be){let Oe,_e,z;const F=ce.x-ve.x,me=ce.y-ve.y,le=be.x-ce.x,j=be.y-ce.y,pe=F*F+me*me,Se=F*j-me*le;if(Math.abs(Se)>Number.EPSILON){const De=Math.sqrt(pe),ye=Math.sqrt(le*le+j*j),Pe=ve.x-me/De,Be=ve.y+F/De,Ke=be.x-j/ye,H=be.y+le/ye,ue=((Ke-Pe)*j-(H-Be)*le)/(F*j-me*le);Oe=Pe+F*ue-ce.x,_e=Be+me*ue-ce.y;const Je=Oe*Oe+_e*_e;if(Je<=2)return new fe(Oe,_e);z=Math.sqrt(Je/2)}else{let De=!1;F>Number.EPSILON?le>Number.EPSILON&&(De=!0):F<-Number.EPSILON?le<-Number.EPSILON&&(De=!0):Math.sign(me)===Math.sign(j)&&(De=!0),De?(Oe=-me,_e=F,z=Math.sqrt(pe)):(Oe=F,_e=me,z=Math.sqrt(pe/2))}return new fe(Oe/z,_e/z)}const W=[];for(let ce=0,ve=I.length,be=ve-1,Oe=ce+1;ce<ve;ce++,be++,Oe++)be===ve&&(be=0),Oe===ve&&(Oe=0),W[ce]=J(I[ce],I[be],I[Oe]);const Q=[];let re,xe=W.concat();for(let ce=0,ve=L.length;ce<ve;ce++){const be=L[ce];re=[];for(let Oe=0,_e=be.length,z=_e-1,F=Oe+1;Oe<_e;Oe++,z++,F++)z===_e&&(z=0),F===_e&&(F=0),re[Oe]=J(be[Oe],be[z],be[F]);Q.push(re),xe=xe.concat(re)}for(let ce=0;ce<y;ce++){const ve=ce/y,be=f*Math.cos(ve*Math.PI/2),Oe=p*Math.sin(ve*Math.PI/2)+m;for(let _e=0,z=I.length;_e<z;_e++){const F=N(I[_e],W[_e],Oe);Ie(F.x,F.y,-be)}for(let _e=0,z=L.length;_e<z;_e++){const F=L[_e];re=Q[_e];for(let me=0,le=F.length;me<le;me++){const j=N(F[me],re[me],Oe);Ie(j.x,j.y,-be)}}}const Ae=p+m;for(let ce=0;ce<V;ce++){const ve=d?N(P[ce],xe[ce],Ae):P[ce];b?(T.copy(S.normals[0]).multiplyScalar(ve.x),w.copy(S.binormals[0]).multiplyScalar(ve.y),R.copy(_[0]).add(T).add(w),Ie(R.x,R.y,R.z)):Ie(ve.x,ve.y,0)}for(let ce=1;ce<=u;ce++)for(let ve=0;ve<V;ve++){const be=d?N(P[ve],xe[ve],Ae):P[ve];b?(T.copy(S.normals[ce]).multiplyScalar(be.x),w.copy(S.binormals[ce]).multiplyScalar(be.y),R.copy(_[ce]).add(T).add(w),Ie(R.x,R.y,R.z)):Ie(be.x,be.y,h/u*ce)}for(let ce=y-1;ce>=0;ce--){const ve=ce/y,be=f*Math.cos(ve*Math.PI/2),Oe=p*Math.sin(ve*Math.PI/2)+m;for(let _e=0,z=I.length;_e<z;_e++){const F=N(I[_e],W[_e],Oe);Ie(F.x,F.y,h+be)}for(let _e=0,z=L.length;_e<z;_e++){const F=L[_e];re=Q[_e];for(let me=0,le=F.length;me<le;me++){const j=N(F[me],re[me],Oe);b?Ie(j.x,j.y+_[u-1].y,_[u-1].x+be):Ie(j.x,j.y,h+be)}}}$e(),se();function $e(){const ce=r.length/3;if(d){let ve=0,be=V*ve;for(let Oe=0;Oe<X;Oe++){const _e=O[Oe];at(_e[2]+be,_e[1]+be,_e[0]+be)}ve=u+y*2,be=V*ve;for(let Oe=0;Oe<X;Oe++){const _e=O[Oe];at(_e[0]+be,_e[1]+be,_e[2]+be)}}else{for(let ve=0;ve<X;ve++){const be=O[ve];at(be[2],be[1],be[0])}for(let ve=0;ve<X;ve++){const be=O[ve];at(be[0]+V*u,be[1]+V*u,be[2]+V*u)}}i.addGroup(ce,r.length/3-ce,0)}function se(){const ce=r.length/3;let ve=0;ht(I,ve),ve+=I.length;for(let be=0,Oe=L.length;be<Oe;be++){const _e=L[be];ht(_e,ve),ve+=_e.length}i.addGroup(ce,r.length/3-ce,1)}function ht(ce,ve){let be=ce.length;for(;--be>=0;){const Oe=be;let _e=be-1;_e<0&&(_e=ce.length-1);for(let z=0,F=u+y*2;z<F;z++){const me=V*z,le=V*(z+1),j=ve+Oe+me,pe=ve+_e+me,Se=ve+_e+le,De=ve+Oe+le;je(j,pe,Se,De)}}}function Ie(ce,ve,be){l.push(ce),l.push(ve),l.push(be)}function at(ce,ve,be){it(ce),it(ve),it(be);const Oe=r.length/3,_e=v.generateTopUV(i,r,Oe-3,Oe-2,Oe-1);qe(_e[0]),qe(_e[1]),qe(_e[2])}function je(ce,ve,be,Oe){it(ce),it(ve),it(Oe),it(ve),it(be),it(Oe);const _e=r.length/3,z=v.generateSideWallUV(i,r,_e-6,_e-3,_e-2,_e-1);qe(z[0]),qe(z[1]),qe(z[3]),qe(z[1]),qe(z[2]),qe(z[3])}function it(ce){r.push(l[ce*3+0]),r.push(l[ce*3+1]),r.push(l[ce*3+2])}function qe(ce){s.push(ce.x),s.push(ce.y)}}}toJSON(){const e=He.prototype.toJSON.call(this),t=this.parameters.shapes,i=this.parameters.options;return vZ(t,i,e)}}const yZ={generateTopUV:function(n,e,t,i,r){const s=e[t*3],o=e[t*3+1],a=e[i*3],l=e[i*3+1],c=e[r*3],u=e[r*3+1];return[new fe(s,o),new fe(a,l),new fe(c,u)]},generateSideWallUV:function(n,e,t,i,r,s){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[i*3],u=e[i*3+1],h=e[i*3+2],d=e[r*3],f=e[r*3+1],p=e[r*3+2],m=e[s*3],y=e[s*3+1],g=e[s*3+2];return Math.abs(a-u)<.01?[new fe(o,1-l),new fe(c,1-h),new fe(d,1-p),new fe(m,1-g)]:[new fe(a,1-l),new fe(u,1-h),new fe(f,1-p),new fe(y,1-g)]}};function vZ(n,e,t){if(t.shapes=[],Array.isArray(n))for(let i=0,r=n.length;i<r;i++){const s=n[i];t.shapes.push(s.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class jd extends ao{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(r,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class qd extends He{constructor(e,t=12,i=0,r=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:i,phiLength:r},t=Math.floor(t),r=Ze.clamp(r,0,Math.PI*2);const s=[],o=[],a=[],l=1/t,c=new k,u=new fe;for(let h=0;h<=t;h++){const d=i+h*l*r,f=Math.sin(d),p=Math.cos(d);for(let m=0;m<=e.length-1;m++)c.x=e[m].x*f,c.y=e[m].y,c.z=e[m].x*p,o.push(c.x,c.y,c.z),u.x=h/t,u.y=m/(e.length-1),a.push(u.x,u.y)}for(let h=0;h<t;h++)for(let d=0;d<e.length-1;d++){const f=d+h*e.length,p=f,m=f+e.length,y=f+e.length+1,g=f+1;s.push(p,m,g),s.push(m,y,g)}if(this.setIndex(s),this.setAttribute("position",new Le(o,3)),this.setAttribute("uv",new Le(a,2)),this.computeVertexNormals(),r===Math.PI*2){const h=this.attributes.normal.array,d=new k,f=new k,p=new k,m=t*e.length*3;for(let y=0,g=0;y<e.length;y++,g+=3)d.x=h[g+0],d.y=h[g+1],d.z=h[g+2],f.x=h[m+g+0],f.y=h[m+g+1],f.z=h[m+g+2],p.addVectors(d,f).normalize(),h[g+0]=h[m+g+0]=p.x,h[g+1]=h[m+g+1]=p.y,h[g+2]=h[m+g+2]=p.z}}}class xu extends ao{constructor(e=1,t=0){const i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],r=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,r,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}function aa(n,e,t){He.call(this),this.type="ParametricGeometry",this.parameters={func:n,slices:e,stacks:t};const i=[],r=[],s=[],o=[],a=1e-5,l=new k,c=new k,u=new k,h=new k,d=new k;n.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const f=e+1;for(let p=0;p<=t;p++){const m=p/t;for(let y=0;y<=e;y++){const g=y/e;n(g,m,c),r.push(c.x,c.y,c.z),g-a>=0?(n(g-a,m,u),h.subVectors(c,u)):(n(g+a,m,u),h.subVectors(u,c)),m-a>=0?(n(g,m-a,u),d.subVectors(c,u)):(n(g,m+a,u),d.subVectors(u,c)),l.crossVectors(h,d).normalize(),s.push(l.x,l.y,l.z),o.push(g,m)}}for(let p=0;p<t;p++)for(let m=0;m<e;m++){const y=p*f+m,g=p*f+m+1,v=(p+1)*f+m+1,_=(p+1)*f+m;i.push(y,g,_),i.push(g,v,_)}this.setIndex(i),this.setAttribute("position",new Le(r,3)),this.setAttribute("normal",new Le(s,3)),this.setAttribute("uv",new Le(o,2))}aa.prototype=Object.create(He.prototype);aa.prototype.constructor=aa;class Xd extends He{constructor(e=.5,t=1,i=8,r=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:i,phiSegments:r,thetaStart:s,thetaLength:o},i=Math.max(3,i),r=Math.max(1,r);const a=[],l=[],c=[],u=[];let h=e;const d=(t-e)/r,f=new k,p=new fe;for(let m=0;m<=r;m++){for(let y=0;y<=i;y++){const g=s+y/i*o;f.x=h*Math.cos(g),f.y=h*Math.sin(g),l.push(f.x,f.y,f.z),c.push(0,0,1),p.x=(f.x/t+1)/2,p.y=(f.y/t+1)/2,u.push(p.x,p.y)}h+=d}for(let m=0;m<r;m++){const y=m*(i+1);for(let g=0;g<i;g++){const v=g+y,_=v,b=v+i+1,S=v+i+2,w=v+1;a.push(_,b,w),a.push(b,S,w)}}this.setIndex(a),this.setAttribute("position",new Le(l,3)),this.setAttribute("normal",new Le(c,3)),this.setAttribute("uv",new Le(u,2))}}class _u extends He{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const i=[],r=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new Le(r,3)),this.setAttribute("normal",new Le(s,3)),this.setAttribute("uv",new Le(o,2));function c(u){const h=r.length/3,d=u.extractPoints(t);let f=d.shape;const p=d.holes;ds.isClockWise(f)===!1&&(f=f.reverse());for(let y=0,g=p.length;y<g;y++){const v=p[y];ds.isClockWise(v)===!0&&(p[y]=v.reverse())}const m=ds.triangulateShape(f,p);for(let y=0,g=p.length;y<g;y++){const v=p[y];f=f.concat(v)}for(let y=0,g=f.length;y<g;y++){const v=f[y];r.push(v.x,v.y,0),s.push(0,0,1),o.push(v.x,v.y)}for(let y=0,g=m.length;y<g;y++){const v=m[y],_=v[0]+h,b=v[1]+h,S=v[2]+h;i.push(_,b,S),l+=3}}}toJSON(){const e=He.prototype.toJSON.call(this),t=this.parameters.shapes;return xZ(t,e)}}function xZ(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,i=n.length;t<i;t++){const r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}class bu extends He{constructor(e=1,t=8,i=6,r=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:r,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new k,d=new k,f=[],p=[],m=[],y=[];for(let g=0;g<=i;g++){const v=[],_=g/i;let b=0;g==0&&o==0?b=.5/t:g==i&&l==Math.PI&&(b=-.5/t);for(let S=0;S<=t;S++){const w=S/t;h.x=-e*Math.cos(r+w*s)*Math.sin(o+_*a),h.y=e*Math.cos(o+_*a),h.z=e*Math.sin(r+w*s)*Math.sin(o+_*a),p.push(h.x,h.y,h.z),d.copy(h).normalize(),m.push(d.x,d.y,d.z),y.push(w+b,1-_),v.push(c++)}u.push(v)}for(let g=0;g<i;g++)for(let v=0;v<t;v++){const _=u[g][v+1],b=u[g][v],S=u[g+1][v],w=u[g+1][v+1];(g!==0||o>0)&&f.push(_,b,w),(g!==i-1||l<Math.PI)&&f.push(b,S,w)}this.setIndex(f),this.setAttribute("position",new Le(p,3)),this.setAttribute("normal",new Le(m,3)),this.setAttribute("uv",new Le(y,2))}}class Yd extends ao{constructor(e=1,t=0){const i=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],r=[2,1,0,0,3,2,1,3,0,2,3,1];super(i,r,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class Kd extends oa{constructor(e,t={}){const i=t.font;if(!(i&&i.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new He;const r=i.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(r,t),this.type="TextGeometry"}}class Zd extends He{constructor(e=1,t=.4,i=8,r=6,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:r,arc:s},i=Math.floor(i),r=Math.floor(r);const o=[],a=[],l=[],c=[],u=new k,h=new k,d=new k;for(let f=0;f<=i;f++)for(let p=0;p<=r;p++){const m=p/r*s,y=f/i*Math.PI*2;h.x=(e+t*Math.cos(y))*Math.cos(m),h.y=(e+t*Math.cos(y))*Math.sin(m),h.z=t*Math.sin(y),a.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),d.subVectors(h,u).normalize(),l.push(d.x,d.y,d.z),c.push(p/r),c.push(f/i)}for(let f=1;f<=i;f++)for(let p=1;p<=r;p++){const m=(r+1)*f+p-1,y=(r+1)*(f-1)+p-1,g=(r+1)*(f-1)+p,v=(r+1)*f+p;o.push(m,y,v),o.push(y,g,v)}this.setIndex(o),this.setAttribute("position",new Le(a,3)),this.setAttribute("normal",new Le(l,3)),this.setAttribute("uv",new Le(c,2))}}class Jd extends He{constructor(e=1,t=.4,i=64,r=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:i,radialSegments:r,p:s,q:o},i=Math.floor(i),r=Math.floor(r);const a=[],l=[],c=[],u=[],h=new k,d=new k,f=new k,p=new k,m=new k,y=new k,g=new k;for(let _=0;_<=i;++_){const b=_/i*s*Math.PI*2;v(b,s,o,e,f),v(b+.01,s,o,e,p),y.subVectors(p,f),g.addVectors(p,f),m.crossVectors(y,g),g.crossVectors(m,y),m.normalize(),g.normalize();for(let S=0;S<=r;++S){const w=S/r*Math.PI*2,T=-t*Math.cos(w),R=t*Math.sin(w);h.x=f.x+(T*g.x+R*m.x),h.y=f.y+(T*g.y+R*m.y),h.z=f.z+(T*g.z+R*m.z),l.push(h.x,h.y,h.z),d.subVectors(h,f).normalize(),c.push(d.x,d.y,d.z),u.push(_/i),u.push(S/r)}}for(let _=1;_<=i;_++)for(let b=1;b<=r;b++){const S=(r+1)*(_-1)+(b-1),w=(r+1)*_+(b-1),T=(r+1)*_+b,R=(r+1)*(_-1)+b;a.push(S,w,R),a.push(w,T,R)}this.setIndex(a),this.setAttribute("position",new Le(l,3)),this.setAttribute("normal",new Le(c,3)),this.setAttribute("uv",new Le(u,2));function v(_,b,S,w,T){const R=Math.cos(_),M=Math.sin(_),P=S/b*_,L=Math.cos(P);T.x=w*(2+L)*.5*R,T.y=w*(2+L)*M*.5,T.z=w*Math.sin(P)*.5}}}class Qd extends He{constructor(e,t=64,i=1,r=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:i,radialSegments:r,closed:s};const o=e.computeFrenetFrames(t,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new k,l=new k,c=new fe;let u=new k;const h=[],d=[],f=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new Le(h,3)),this.setAttribute("normal",new Le(d,3)),this.setAttribute("uv",new Le(f,2));function m(){for(let _=0;_<t;_++)y(_);y(s===!1?t:0),v(),g()}function y(_){u=e.getPointAt(_/t,u);const b=o.normals[_],S=o.binormals[_];for(let w=0;w<=r;w++){const T=w/r*Math.PI*2,R=Math.sin(T),M=-Math.cos(T);l.x=M*b.x+R*S.x,l.y=M*b.y+R*S.y,l.z=M*b.z+R*S.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=u.x+i*l.x,a.y=u.y+i*l.y,a.z=u.z+i*l.z,h.push(a.x,a.y,a.z)}}function g(){for(let _=1;_<=t;_++)for(let b=1;b<=r;b++){const S=(r+1)*(_-1)+(b-1),w=(r+1)*_+(b-1),T=(r+1)*_+b,R=(r+1)*(_-1)+b;p.push(S,w,R),p.push(w,T,R)}}function v(){for(let _=0;_<=t;_++)for(let b=0;b<=r;b++)c.x=_/t,c.y=b/r,f.push(c.x,c.y)}}toJSON(){const e=He.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class fv extends He{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const t=[],i=[0,0],r={},s=new k;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],d=h.start,f=h.count;for(let p=d,m=d+f;p<m;p+=3)for(let y=0;y<3;y++){const g=a.getX(p+y),v=a.getX(p+(y+1)%3);i[0]=Math.min(g,v),i[1]=Math.max(g,v);const _=i[0]+","+i[1];r[_]===void 0&&(r[_]={index1:i[0],index2:i[1]})}}for(const c in r){const u=r[c];s.fromBufferAttribute(o,u.index1),t.push(s.x,s.y,s.z),s.fromBufferAttribute(o,u.index2),t.push(s.x,s.y,s.z)}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c;s.fromBufferAttribute(o,u),t.push(s.x,s.y,s.z);const h=3*a+(c+1)%3;s.fromBufferAttribute(o,h),t.push(s.x,s.y,s.z)}}this.setAttribute("position",new Le(t,3))}}var Jn=Object.freeze({__proto__:null,BoxGeometry:ra,BoxBufferGeometry:ra,CircleGeometry:Gd,CircleBufferGeometry:Gd,ConeGeometry:Hd,ConeBufferGeometry:Hd,CylinderGeometry:Rl,CylinderBufferGeometry:Rl,DodecahedronGeometry:Wd,DodecahedronBufferGeometry:Wd,EdgesGeometry:dv,ExtrudeGeometry:oa,ExtrudeBufferGeometry:oa,IcosahedronGeometry:jd,IcosahedronBufferGeometry:jd,LatheGeometry:qd,LatheBufferGeometry:qd,OctahedronGeometry:xu,OctahedronBufferGeometry:xu,ParametricGeometry:aa,ParametricBufferGeometry:aa,PlaneGeometry:lu,PlaneBufferGeometry:lu,PolyhedronGeometry:ao,PolyhedronBufferGeometry:ao,RingGeometry:Xd,RingBufferGeometry:Xd,ShapeGeometry:_u,ShapeBufferGeometry:_u,SphereGeometry:bu,SphereBufferGeometry:bu,TetrahedronGeometry:Yd,TetrahedronBufferGeometry:Yd,TextGeometry:Kd,TextBufferGeometry:Kd,TorusGeometry:Zd,TorusBufferGeometry:Zd,TorusKnotGeometry:Jd,TorusKnotBufferGeometry:Jd,TubeGeometry:Qd,TubeBufferGeometry:Qd,WireframeGeometry:fv});function la(n){Ye.call(this),this.type="ShadowMaterial",this.color=new Ne(0),this.transparent=!0,this.setValues(n)}la.prototype=Object.create(Ye.prototype);la.prototype.constructor=la;la.prototype.isShadowMaterial=!0;la.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this};function gs(n){si.call(this,n),this.type="RawShaderMaterial"}gs.prototype=Object.create(si.prototype);gs.prototype.constructor=gs;gs.prototype.isRawShaderMaterial=!0;function Wr(n){Ye.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ne(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wa,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(n)}Wr.prototype=Object.create(Ye.prototype);Wr.prototype.constructor=Wr;Wr.prototype.isMeshStandardMaterial=!0;Wr.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.vertexTangents=n.vertexTangents,this};function co(n){Wr.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new fe(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=Ze.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(n)}co.prototype=Object.create(Wr.prototype);co.prototype.constructor=co;co.prototype.isMeshPhysicalMaterial=!0;co.prototype.copy=function(n){return Wr.prototype.copy.call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.reflectivity=n.reflectivity,n.sheen?this.sheen=(this.sheen||new Ne).copy(n.sheen):this.sheen=null,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this};function uo(n){Ye.call(this),this.type="MeshPhongMaterial",this.color=new Ne(16777215),this.specular=new Ne(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wa,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Bu,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}uo.prototype=Object.create(Ye.prototype);uo.prototype.constructor=uo;uo.prototype.isMeshPhongMaterial=!0;uo.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function ca(n){Ye.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ne(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wa,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}ca.prototype=Object.create(Ye.prototype);ca.prototype.constructor=ca;ca.prototype.isMeshToonMaterial=!0;ca.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function ua(n){Ye.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wa,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}ua.prototype=Object.create(Ye.prototype);ua.prototype.constructor=ua;ua.prototype.isMeshNormalMaterial=!0;ua.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function ha(n){Ye.call(this),this.type="MeshLambertMaterial",this.color=new Ne(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Bu,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}ha.prototype=Object.create(Ye.prototype);ha.prototype.constructor=ha;ha.prototype.isMeshLambertMaterial=!0;ha.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function da(n){Ye.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ne(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wa,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}da.prototype=Object.create(Ye.prototype);da.prototype.constructor=da;da.prototype.isMeshMatcapMaterial=!0;da.prototype.copy=function(n){return Ye.prototype.copy.call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function fa(n){Zt.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(n)}fa.prototype=Object.create(Zt.prototype);fa.prototype.constructor=fa;fa.prototype.isLineDashedMaterial=!0;fa.prototype.copy=function(n){return Zt.prototype.copy.call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this};var _Z=Object.freeze({__proto__:null,ShadowMaterial:la,SpriteMaterial:oo,RawShaderMaterial:gs,ShaderMaterial:si,PointsMaterial:Tr,MeshPhysicalMaterial:co,MeshStandardMaterial:Wr,MeshPhongMaterial:uo,MeshToonMaterial:ca,MeshNormalMaterial:ua,MeshLambertMaterial:ha,MeshDepthMaterial:io,MeshDistanceMaterial:ro,MeshBasicMaterial:Ri,MeshMatcapMaterial:da,LineDashedMaterial:fa,LineBasicMaterial:Zt,Material:Ye});const Kt={arraySlice:function(n,e,t){return Kt.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(r,s){return n[r]-n[s]}const t=n.length,i=new Array(t);for(let r=0;r!==t;++r)i[r]=r;return i.sort(e),i},sortedArray:function(n,e,t){const i=n.length,r=new n.constructor(i);for(let s=0,o=0;o!==i;++s){const a=t[s]*e;for(let l=0;l!==e;++l)r[o++]=n[a+l]}return r},flattenJSON:function(n,e,t,i){let r=1,s=n[0];for(;s!==void 0&&s[i]===void 0;)s=n[r++];if(s===void 0)return;let o=s[i];if(o!==void 0)if(Array.isArray(o))do o=s[i],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=n[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[i],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=n[r++];while(s!==void 0);else do o=s[i],o!==void 0&&(e.push(s.time),t.push(o)),s=n[r++];while(s!==void 0)},subclip:function(n,e,t,i,r=30){const s=n.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],u=c.getValueSize(),h=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*r;if(!(p<t||p>=i)){h.push(c.times[f]);for(let m=0;m<u;++m)d.push(c.values[f*u+m])}}h.length!==0&&(c.times=Kt.convertArray(h,c.times.constructor),c.values=Kt.convertArray(d,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(n,e=0,t=n,i=30){i<=0&&(i=30);const r=t.tracks.length,s=e/i;for(let o=0;o<r;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(g){return g.name===a.name&&g.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=a.times.length-1;let m;if(s<=a.times[0]){const g=u,v=h-u;m=Kt.arraySlice(a.values,g,v)}else if(s>=a.times[p]){const g=p*h+u,v=g+h-u;m=Kt.arraySlice(a.values,g,v)}else{const g=a.createInterpolant(),v=u,_=h-u;g.evaluate(s),m=Kt.arraySlice(g.resultBuffer,v,_)}l==="quaternion"&&new Xn().fromArray(m).normalize().conjugate().toArray(m);const y=c.times.length;for(let g=0;g<y;++g){const v=g*f+d;if(l==="quaternion")Xn.multiplyQuaternionsFlat(c.values,v,m,0,c.values,v);else{const _=f-d*2;for(let b=0;b<_;++b)c.values[v+b]-=m[b]}}}return n.blendMode=rv,n}};function Ai(n,e,t,i){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(t),this.sampleValues=e,this.valueSize=t}Object.assign(Ai.prototype,{evaluate:function(n){const e=this.parameterPositions;let t=this._cachedIndex,i=e[t],r=e[t-1];e:{t:{let s;n:{i:if(!(n<i)){for(let o=t+2;;){if(i===void 0){if(n<r)break i;return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,n,r)}if(t===o)break;if(r=i,i=e[++t],n<i)break t}s=e.length;break n}if(!(n>=r)){const o=e[1];n<o&&(t=2,r=o);for(let a=t-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,i);if(t===a)break;if(i=r,r=e[--t-1],n>=r)break t}s=t,t=0;break n}break e}for(;t<s;){const o=t+s>>>1;n<e[o]?s=o:t=o+1}if(i=e[t],r=e[t-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,i);if(i===void 0)return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,r,n)}this._cachedIndex=t,this.intervalChanged_(t,r,i)}return this.interpolate_(t,r,n,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(n){const e=this.resultBuffer,t=this.sampleValues,i=this.valueSize,r=n*i;for(let s=0;s!==i;++s)e[s]=t[r+s];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Ai.prototype,{beforeStart_:Ai.prototype.copySampleValue_,afterEnd_:Ai.prototype.copySampleValue_});function ef(n,e,t,i){Ai.call(this,n,e,t,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}ef.prototype=Object.assign(Object.create(Ai.prototype),{constructor:ef,DefaultSettings_:{endingStart:Bo,endingEnd:Bo},intervalChanged_:function(n,e,t){const i=this.parameterPositions;let r=n-2,s=n+1,o=i[r],a=i[s];if(o===void 0)switch(this.getSettings_().endingStart){case zo:r=n,o=2*e-t;break;case eu:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=n,o=t}if(a===void 0)switch(this.getSettings_().endingEnd){case zo:s=n,a=2*t-e;break;case eu:s=1,a=t+i[1]-i[0];break;default:s=n-1,a=e}const l=(t-e)*.5,c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-t),this._offsetPrev=r*c,this._offsetNext=s*c},interpolate_:function(n,e,t,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,f=(t-e)/(i-e),p=f*f,m=p*f,y=-h*m+2*h*p-h*f,g=(1+h)*m+(-1.5-2*h)*p+(-.5+h)*f+1,v=(-1-d)*m+(1.5+d)*p+.5*f,_=d*m-d*p;for(let b=0;b!==o;++b)r[b]=y*s[c+b]+g*s[l+b]+v*s[a+b]+_*s[u+b];return r}});function wu(n,e,t,i){Ai.call(this,n,e,t,i)}wu.prototype=Object.assign(Object.create(Ai.prototype),{constructor:wu,interpolate_:function(n,e,t,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=(t-e)/(i-e),u=1-c;for(let h=0;h!==o;++h)r[h]=s[l+h]*u+s[a+h]*c;return r}});function tf(n,e,t,i){Ai.call(this,n,e,t,i)}tf.prototype=Object.assign(Object.create(Ai.prototype),{constructor:tf,interpolate_:function(n){return this.copySampleValue_(n-1)}});function On(n,e,t,i){if(n===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+n);this.name=n,this.times=Kt.convertArray(e,this.TimeBufferType),this.values=Kt.convertArray(t,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}Object.assign(On,{toJSON:function(n){const e=n.constructor;let t;if(e.toJSON!==void 0)t=e.toJSON(n);else{t={name:n.name,times:Kt.convertArray(n.times,Array),values:Kt.convertArray(n.values,Array)};const i=n.getInterpolation();i!==n.DefaultInterpolation&&(t.interpolation=i)}return t.type=n.ValueTypeName,t}});Object.assign(On.prototype,{constructor:On,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Pc,InterpolantFactoryMethodDiscrete:function(n){return new tf(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodLinear:function(n){return new wu(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:function(n){return new ef(this.times,this.values,this.getValueSize(),n)},setInterpolation:function(n){let e;switch(n){case Qc:e=this.InterpolantFactoryMethodDiscrete;break;case Pc:e=this.InterpolantFactoryMethodLinear;break;case yd:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(n!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Qc;case this.InterpolantFactoryMethodLinear:return Pc;case this.InterpolantFactoryMethodSmooth:return yd}},getValueSize:function(){return this.values.length/this.times.length},shift:function(n){if(n!==0){const e=this.times;for(let t=0,i=e.length;t!==i;++t)e[t]+=n}return this},scale:function(n){if(n!==1){const e=this.times;for(let t=0,i=e.length;t!==i;++t)e[t]*=n}return this},trim:function(n,e){const t=this.times,i=t.length;let r=0,s=i-1;for(;r!==i&&t[r]<n;)++r;for(;s!==-1&&t[s]>e;)--s;if(++s,r!==0||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const o=this.getValueSize();this.times=Kt.arraySlice(t,r,s),this.values=Kt.arraySlice(this.values,r*o,s*o)}return this},validate:function(){let n=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);const t=this.times,i=this.values,r=t.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);let s=null;for(let o=0;o!==r;o++){const a=t[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),n=!1;break}if(s!==null&&s>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,s),n=!1;break}s=a}if(i!==void 0&&Kt.isTypedArray(i))for(let o=0,a=i.length;o!==a;++o){const l=i[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),n=!1;break}}return n},optimize:function(){const n=Kt.arraySlice(this.times),e=Kt.arraySlice(this.values),t=this.getValueSize(),i=this.getInterpolation()===yd,r=n.length-1;let s=1;for(let o=1;o<r;++o){let a=!1;const l=n[o],c=n[o+1];if(l!==c&&(o!==1||l!==n[0]))if(i)a=!0;else{const u=o*t,h=u-t,d=u+t;for(let f=0;f!==t;++f){const p=e[u+f];if(p!==e[h+f]||p!==e[d+f]){a=!0;break}}}if(a){if(o!==s){n[s]=n[o];const u=o*t,h=s*t;for(let d=0;d!==t;++d)e[h+d]=e[u+d]}++s}}if(r>0){n[s]=n[r];for(let o=r*t,a=s*t,l=0;l!==t;++l)e[a+l]=e[o+l];++s}return s!==n.length?(this.times=Kt.arraySlice(n,0,s),this.values=Kt.arraySlice(e,0,s*t)):(this.times=n,this.values=e),this},clone:function(){const n=Kt.arraySlice(this.times,0),e=Kt.arraySlice(this.values,0),t=this.constructor,i=new t(this.name,n,e);return i.createInterpolant=this.createInterpolant,i}});function nf(n,e,t){On.call(this,n,e,t)}nf.prototype=Object.assign(Object.create(On.prototype),{constructor:nf,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:Qc,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function rf(n,e,t,i){On.call(this,n,e,t,i)}rf.prototype=Object.assign(Object.create(On.prototype),{constructor:rf,ValueTypeName:"color"});function Il(n,e,t,i){On.call(this,n,e,t,i)}Il.prototype=Object.assign(Object.create(On.prototype),{constructor:Il,ValueTypeName:"number"});function sf(n,e,t,i){Ai.call(this,n,e,t,i)}sf.prototype=Object.assign(Object.create(Ai.prototype),{constructor:sf,interpolate_:function(n,e,t,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(t-e)/(i-e);let l=n*o;for(let c=l+o;l!==c;l+=4)Xn.slerpFlat(r,0,s,l-o,s,l,a);return r}});function Su(n,e,t,i){On.call(this,n,e,t,i)}Su.prototype=Object.assign(Object.create(On.prototype),{constructor:Su,ValueTypeName:"quaternion",DefaultInterpolation:Pc,InterpolantFactoryMethodLinear:function(n){return new sf(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:void 0});function of(n,e,t,i){On.call(this,n,e,t,i)}of.prototype=Object.assign(Object.create(On.prototype),{constructor:of,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:Qc,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function Pl(n,e,t,i){On.call(this,n,e,t,i)}Pl.prototype=Object.assign(Object.create(On.prototype),{constructor:Pl,ValueTypeName:"vector"});function Si(n,e=-1,t,i=Hf){this.name=n,this.tracks=t,this.duration=e,this.blendMode=i,this.uuid=Ze.generateUUID(),this.duration<0&&this.resetDuration()}function bZ(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Il;case"vector":case"vector2":case"vector3":case"vector4":return Pl;case"color":return rf;case"quaternion":return Su;case"bool":case"boolean":return nf;case"string":return of}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function wZ(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=bZ(n.type);if(n.times===void 0){const t=[],i=[];Kt.flattenJSON(n.keys,t,i,"value"),n.times=t,n.values=i}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}Object.assign(Si,{parse:function(n){const e=[],t=n.tracks,i=1/(n.fps||1);for(let s=0,o=t.length;s!==o;++s)e.push(wZ(t[s]).scale(i));const r=new Si(n.name,n.duration,e,n.blendMode);return r.uuid=n.uuid,r},toJSON:function(n){const e=[],t=n.tracks,i={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode};for(let r=0,s=t.length;r!==s;++r)e.push(On.toJSON(t[r]));return i},CreateFromMorphTargetSequence:function(n,e,t,i){const r=e.length,s=[];for(let o=0;o<r;o++){let a=[],l=[];a.push((o+r-1)%r,o,(o+1)%r),l.push(0,1,0);const c=Kt.getKeyframeOrder(a);a=Kt.sortedArray(a,1,c),l=Kt.sortedArray(l,1,c),!i&&a[0]===0&&(a.push(r),l.push(l[0])),s.push(new Il(".morphTargetInfluences["+e[o].name+"]",a,l).scale(1/t))}return new Si(n,-1,s)},findByName:function(n,e){let t=n;if(!Array.isArray(n)){const i=n;t=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<t.length;i++)if(t[i].name===e)return t[i];return null},CreateClipsFromMorphTargetSequences:function(n,e,t){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,a=n.length;o<a;o++){const l=n[o],c=l.name.match(r);if(c&&c.length>1){const u=c[1];let h=i[u];h||(i[u]=h=[]),h.push(l)}}const s=[];for(const o in i)s.push(Si.CreateFromMorphTargetSequence(o,i[o],e,t));return s},parseAnimation:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(u,h,d,f,p){if(d.length!==0){const m=[],y=[];Kt.flattenJSON(d,m,y,f),m.length!==0&&p.push(new u(h,m,y))}},i=[],r=n.name||"default",s=n.fps||30,o=n.blendMode;let a=n.length||-1;const l=n.hierarchy||[];for(let u=0;u<l.length;u++){const h=l[u].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const d={};let f;for(f=0;f<h.length;f++)if(h[f].morphTargets)for(let p=0;p<h[f].morphTargets.length;p++)d[h[f].morphTargets[p]]=-1;for(const p in d){const m=[],y=[];for(let g=0;g!==h[f].morphTargets.length;++g){const v=h[f];m.push(v.time),y.push(v.morphTarget===p?1:0)}i.push(new Il(".morphTargetInfluence["+p+"]",m,y))}a=d.length*(s||1)}else{const d=".bones["+e[u].name+"]";t(Pl,d+".position",h,"pos",i),t(Su,d+".quaternion",h,"rot",i),t(Pl,d+".scale",h,"scl",i)}}return i.length===0?null:new Si(r,a,i,o)}});Object.assign(Si.prototype,{resetDuration:function(){const n=this.tracks;let e=0;for(let t=0,i=n.length;t!==i;++t){const r=this.tracks[t];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this},trim:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this},validate:function(){let n=!0;for(let e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n},optimize:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this},clone:function(){const n=[];for(let e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new Si(this.name,this.duration,n,this.blendMode)},toJSON:function(){return Si.toJSON(this)}});const pa={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};function pv(n,e,t){const i=this;let r=!1,s=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=n,this.onProgress=e,this.onError=t,this.itemStart=function(c){o++,r===!1&&i.onStart!==void 0&&i.onStart(c,s,o),r=!0},this.itemEnd=function(c){s++,i.onProgress!==void 0&&i.onProgress(c,s,o),s===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(c){i.onError!==void 0&&i.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,u){return l.push(c,u),this},this.removeHandler=function(c){const u=l.indexOf(c);return u!==-1&&l.splice(u,2),this},this.getHandler=function(c){for(let u=0,h=l.length;u<h;u+=2){const d=l[u],f=l[u+1];if(d.global&&(d.lastIndex=0),d.test(c))return f}return null}}const NA=new pv;function Pt(n){this.manager=n!==void 0?n:NA,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Pt.prototype,{load:function(){},loadAsync:function(n,e){const t=this;return new Promise(function(i,r){t.load(n,i,e,r)})},parse:function(){},setCrossOrigin:function(n){return this.crossOrigin=n,this},setWithCredentials:function(n){return this.withCredentials=n,this},setPath:function(n){return this.path=n,this},setResourcePath:function(n){return this.resourcePath=n,this},setRequestHeader:function(n){return this.requestHeader=n,this}});const ur={};function Ji(n){Pt.call(this,n)}Ji.prototype=Object.assign(Object.create(Pt.prototype),{constructor:Ji,load:function(n,e,t,i){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const r=this,s=pa.get(n);if(s!==void 0)return r.manager.itemStart(n),setTimeout(function(){e&&e(s),r.manager.itemEnd(n)},0),s;if(ur[n]!==void 0){ur[n].push({onLoad:e,onProgress:t,onError:i});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=n.match(o);let l;if(a){const c=a[1],u=!!a[2];let h=a[3];h=decodeURIComponent(h),u&&(h=atob(h));try{let d;const f=(this.responseType||"").toLowerCase();switch(f){case"arraybuffer":case"blob":const p=new Uint8Array(h.length);for(let y=0;y<h.length;y++)p[y]=h.charCodeAt(y);f==="blob"?d=new Blob([p.buffer],{type:c}):d=p.buffer;break;case"document":d=new DOMParser().parseFromString(h,c);break;case"json":d=JSON.parse(h);break;default:d=h;break}setTimeout(function(){e&&e(d),r.manager.itemEnd(n)},0)}catch(d){setTimeout(function(){i&&i(d),r.manager.itemError(n),r.manager.itemEnd(n)},0)}}else{ur[n]=[],ur[n].push({onLoad:e,onProgress:t,onError:i}),l=new XMLHttpRequest,l.open("GET",n,!0),l.addEventListener("load",function(c){const u=this.response,h=ur[n];if(delete ur[n],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),pa.add(n,u);for(let d=0,f=h.length;d<f;d++){const p=h[d];p.onLoad&&p.onLoad(u)}r.manager.itemEnd(n)}else{for(let d=0,f=h.length;d<f;d++){const p=h[d];p.onError&&p.onError(c)}r.manager.itemError(n),r.manager.itemEnd(n)}},!1),l.addEventListener("progress",function(c){const u=ur[n];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onProgress&&f.onProgress(c)}},!1),l.addEventListener("error",function(c){const u=ur[n];delete ur[n];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onError&&f.onError(c)}r.manager.itemError(n),r.manager.itemEnd(n)},!1),l.addEventListener("abort",function(c){const u=ur[n];delete ur[n];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onError&&f.onError(c)}r.manager.itemError(n),r.manager.itemEnd(n)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return r.manager.itemStart(n),l},setResponseType:function(n){return this.responseType=n,this},setMimeType:function(n){return this.mimeType=n,this}});function Yg(n){Pt.call(this,n)}Yg.prototype=Object.assign(Object.create(Pt.prototype),{constructor:Yg,load:function(n,e,t,i){const r=this,s=new Ji(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(n,function(o){try{e(r.parse(JSON.parse(o)))}catch(a){i?i(a):console.error(a),r.manager.itemError(n)}},t,i)},parse:function(n){const e=[];for(let t=0;t<n.length;t++){const i=Si.parse(n[t]);e.push(i)}return e}});function Kg(n){Pt.call(this,n)}Kg.prototype=Object.assign(Object.create(Pt.prototype),{constructor:Kg,load:function(n,e,t,i){const r=this,s=[],o=new Al,a=new Ji(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(u){a.load(n[u],function(h){const d=r.parse(h,!0);s[u]={width:d.width,height:d.height,format:d.format,mipmaps:d.mipmaps},l+=1,l===6&&(d.mipmapCount===1&&(o.minFilter=Cn),o.image=s,o.format=d.format,o.needsUpdate=!0,e&&e(o))},t,i)}if(Array.isArray(n))for(let u=0,h=n.length;u<h;++u)c(u);else a.load(n,function(u){const h=r.parse(u,!0);if(h.isCubemap){const d=h.mipmaps.length/h.mipmapCount;for(let f=0;f<d;f++){s[f]={mipmaps:[]};for(let p=0;p<h.mipmapCount;p++)s[f].mipmaps.push(h.mipmaps[f*h.mipmapCount+p]),s[f].format=h.format,s[f].width=h.width,s[f].height=h.height}o.image=s}else o.image.width=h.width,o.image.height=h.height,o.mipmaps=h.mipmaps;h.mipmapCount===1&&(o.minFilter=Cn),o.format=h.format,o.needsUpdate=!0,e&&e(o)},t,i);return o}});function Nl(n){Pt.call(this,n)}Nl.prototype=Object.assign(Object.create(Pt.prototype),{constructor:Nl,load:function(n,e,t,i){this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const r=this,s=pa.get(n);if(s!==void 0)return r.manager.itemStart(n),setTimeout(function(){e&&e(s),r.manager.itemEnd(n)},0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),pa.add(n,this),e&&e(this),r.manager.itemEnd(n)}function l(c){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),i&&i(c),r.manager.itemError(n),r.manager.itemEnd(n)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),n.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(n),o.src=n,o}});function af(n){Pt.call(this,n)}af.prototype=Object.assign(Object.create(Pt.prototype),{constructor:af,load:function(n,e,t,i){const r=new Hr,s=new Nl(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(l){s.load(n[l],function(c){r.images[l]=c,o++,o===6&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let l=0;l<n.length;++l)a(l);return r}});function lf(n){Pt.call(this,n)}lf.prototype=Object.assign(Object.create(Pt.prototype),{constructor:lf,load:function(n,e,t,i){const r=this,s=new ms,o=new Ji(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(n,function(a){const l=r.parse(a);!l||(l.image!==void 0?s.image=l.image:l.data!==void 0&&(s.image.width=l.width,s.image.height=l.height,s.image.data=l.data),s.wrapS=l.wrapS!==void 0?l.wrapS:ii,s.wrapT=l.wrapT!==void 0?l.wrapT:ii,s.magFilter=l.magFilter!==void 0?l.magFilter:Cn,s.minFilter=l.minFilter!==void 0?l.minFilter:Cn,s.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(s.encoding=l.encoding),l.flipY!==void 0&&(s.flipY=l.flipY),l.format!==void 0&&(s.format=l.format),l.type!==void 0&&(s.type=l.type),l.mipmaps!==void 0&&(s.mipmaps=l.mipmaps,s.minFilter=Kl),l.mipmapCount===1&&(s.minFilter=Cn),s.needsUpdate=!0,e&&e(s,l))},t,i),s}});function cf(n){Pt.call(this,n)}cf.prototype=Object.assign(Object.create(Pt.prototype),{constructor:cf,load:function(n,e,t,i){const r=new Bt,s=new Nl(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(n,function(o){r.image=o;const a=n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0;r.format=a?js:Mi,r.needsUpdate=!0,e!==void 0&&e(r)},t,i),r}});function Ue(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(Ue.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(n,e){const t=this.getUtoTmapping(n);return this.getPoint(t,e)},getPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return e},getSpacedPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e},getLength:function(){const n=this.getLengths();return n[n.length-1]},getLengths:function(n){if(n===void 0&&(n=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let t,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=n;s++)t=this.getPoint(s/n),r+=t.distanceTo(i),e.push(r),i=t;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(n,e){const t=this.getLengths();let i=0;const r=t.length;let s;e?s=e:s=n*t[r-1];let o=0,a=r-1,l;for(;o<=a;)if(i=Math.floor(o+(a-o)/2),l=t[i]-s,l<0)o=i+1;else if(l>0)a=i-1;else{a=i;break}if(i=a,t[i]===s)return i/(r-1);const c=t[i],h=t[i+1]-c,d=(s-c)/h;return(i+d)/(r-1)},getTangent:function(n,e){let i=n-1e-4,r=n+1e-4;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=e||(s.isVector2?new fe:new k);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(n,e){const t=this.getUtoTmapping(n);return this.getTangent(t,e)},computeFrenetFrames:function(n,e){const t=new k,i=[],r=[],s=[],o=new k,a=new ut;for(let d=0;d<=n;d++){const f=d/n;i[d]=this.getTangentAt(f,new k),i[d].normalize()}r[0]=new k,s[0]=new k;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),u=Math.abs(i[0].y),h=Math.abs(i[0].z);c<=l&&(l=c,t.set(1,0,0)),u<=l&&(l=u,t.set(0,1,0)),h<=l&&t.set(0,0,1),o.crossVectors(i[0],t).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let d=1;d<=n;d++){if(r[d]=r[d-1].clone(),s[d]=s[d-1].clone(),o.crossVectors(i[d-1],i[d]),o.length()>Number.EPSILON){o.normalize();const f=Math.acos(Ze.clamp(i[d-1].dot(i[d]),-1,1));r[d].applyMatrix4(a.makeRotationAxis(o,f))}s[d].crossVectors(i[d],r[d])}if(e===!0){let d=Math.acos(Ze.clamp(r[0].dot(r[n]),-1,1));d/=n,i[0].dot(o.crossVectors(r[0],r[n]))>0&&(d=-d);for(let f=1;f<=n;f++)r[f].applyMatrix4(a.makeRotationAxis(i[f],d*f)),s[f].crossVectors(i[f],r[f])}return{tangents:i,normals:r,binormals:s}},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this},toJSON:function(){const n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n},fromJSON:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}});function Pi(n,e,t,i,r,s,o,a){Ue.call(this),this.type="EllipseCurve",this.aX=n||0,this.aY=e||0,this.xRadius=t||1,this.yRadius=i||1,this.aStartAngle=r||0,this.aEndAngle=s||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}Pi.prototype=Object.create(Ue.prototype);Pi.prototype.constructor=Pi;Pi.prototype.isEllipseCurve=!0;Pi.prototype.getPoint=function(n,e){const t=e||new fe,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(s?r=0:r=i),this.aClockwise===!0&&!s&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+n*r;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=a-this.aX,d=l-this.aY;a=h*c-d*u+this.aX,l=h*u+d*c+this.aY}return t.set(a,l)};Pi.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};Pi.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n};Pi.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};function Ll(n,e,t,i,r,s){Pi.call(this,n,e,t,t,i,r,s),this.type="ArcCurve"}Ll.prototype=Object.create(Pi.prototype);Ll.prototype.constructor=Ll;Ll.prototype.isArcCurve=!0;function mv(){let n=0,e=0,t=0,i=0;function r(s,o,a,l){n=s,e=a,t=-3*s+3*o-2*a-l,i=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){r(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,u,h){let d=(o-s)/c-(a-s)/(c+u)+(a-o)/u,f=(a-o)/u-(l-o)/(u+h)+(l-a)/h;d*=u,f*=u,r(o,a,d,f)},calc:function(s){const o=s*s,a=o*s;return n+e*s+t*o+i*a}}}const Vh=new k,tm=new mv,nm=new mv,im=new mv;function Kn(n=[],e=!1,t="centripetal",i=.5){Ue.call(this),this.type="CatmullRomCurve3",this.points=n,this.closed=e,this.curveType=t,this.tension=i}Kn.prototype=Object.create(Ue.prototype);Kn.prototype.constructor=Kn;Kn.prototype.isCatmullRomCurve3=!0;Kn.prototype.getPoint=function(n,e=new k){const t=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*n;let o=Math.floor(s),a=s-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:a===0&&o===r-1&&(o=r-2,a=1);let l,c;this.closed||o>0?l=i[(o-1)%r]:(Vh.subVectors(i[0],i[1]).add(i[0]),l=Vh);const u=i[o%r],h=i[(o+1)%r];if(this.closed||o+2<r?c=i[(o+2)%r]:(Vh.subVectors(i[r-1],i[r-2]).add(i[r-1]),c=Vh),this.curveType==="centripetal"||this.curveType==="chordal"){const d=this.curveType==="chordal"?.5:.25;let f=Math.pow(l.distanceToSquared(u),d),p=Math.pow(u.distanceToSquared(h),d),m=Math.pow(h.distanceToSquared(c),d);p<1e-4&&(p=1),f<1e-4&&(f=p),m<1e-4&&(m=p),tm.initNonuniformCatmullRom(l.x,u.x,h.x,c.x,f,p,m),nm.initNonuniformCatmullRom(l.y,u.y,h.y,c.y,f,p,m),im.initNonuniformCatmullRom(l.z,u.z,h.z,c.z,f,p,m)}else this.curveType==="catmullrom"&&(tm.initCatmullRom(l.x,u.x,h.x,c.x,this.tension),nm.initCatmullRom(l.y,u.y,h.y,c.y,this.tension),im.initCatmullRom(l.z,u.z,h.z,c.z,this.tension));return t.set(tm.calc(a),nm.calc(a),im.calc(a)),t};Kn.prototype.copy=function(n){Ue.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const i=n.points[e];this.points.push(i.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};Kn.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const i=this.points[e];n.points.push(i.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n};Kn.prototype.fromJSON=function(n){Ue.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const i=n.points[e];this.points.push(new k().fromArray(i))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};function $_(n,e,t,i,r){const s=(i-e)*.5,o=(r-t)*.5,a=n*n,l=n*a;return(2*t-2*i+s+o)*l+(-3*t+3*i-2*s-o)*a+s*n+t}function SZ(n,e){const t=1-n;return t*t*e}function TZ(n,e){return 2*(1-n)*n*e}function EZ(n,e){return n*n*e}function Lc(n,e,t,i){return SZ(n,e)+TZ(n,t)+EZ(n,i)}function CZ(n,e){const t=1-n;return t*t*t*e}function MZ(n,e){const t=1-n;return 3*t*t*n*e}function AZ(n,e){return 3*(1-n)*n*n*e}function RZ(n,e){return n*n*n*e}function Dc(n,e,t,i,r){return CZ(n,e)+MZ(n,t)+AZ(n,i)+RZ(n,r)}function Er(n=new fe,e=new fe,t=new fe,i=new fe){Ue.call(this),this.type="CubicBezierCurve",this.v0=n,this.v1=e,this.v2=t,this.v3=i}Er.prototype=Object.create(Ue.prototype);Er.prototype.constructor=Er;Er.prototype.isCubicBezierCurve=!0;Er.prototype.getPoint=function(n,e=new fe){const t=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return t.set(Dc(n,i.x,r.x,s.x,o.x),Dc(n,i.y,r.y,s.y,o.y)),t};Er.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Er.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Er.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function jr(n=new k,e=new k,t=new k,i=new k){Ue.call(this),this.type="CubicBezierCurve3",this.v0=n,this.v1=e,this.v2=t,this.v3=i}jr.prototype=Object.create(Ue.prototype);jr.prototype.constructor=jr;jr.prototype.isCubicBezierCurve3=!0;jr.prototype.getPoint=function(n,e=new k){const t=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return t.set(Dc(n,i.x,r.x,s.x,o.x),Dc(n,i.y,r.y,s.y,o.y),Dc(n,i.z,r.z,s.z,o.z)),t};jr.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};jr.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};jr.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function mi(n=new fe,e=new fe){Ue.call(this),this.type="LineCurve",this.v1=n,this.v2=e}mi.prototype=Object.create(Ue.prototype);mi.prototype.constructor=mi;mi.prototype.isLineCurve=!0;mi.prototype.getPoint=function(n,e=new fe){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};mi.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};mi.prototype.getTangent=function(n,e){const t=e||new fe;return t.copy(this.v2).sub(this.v1).normalize(),t};mi.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};mi.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};mi.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Cr(n=new k,e=new k){Ue.call(this),this.type="LineCurve3",this.v1=n,this.v2=e}Cr.prototype=Object.create(Ue.prototype);Cr.prototype.constructor=Cr;Cr.prototype.isLineCurve3=!0;Cr.prototype.getPoint=function(n,e=new k){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Cr.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Cr.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Cr.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Cr.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Mr(n=new fe,e=new fe,t=new fe){Ue.call(this),this.type="QuadraticBezierCurve",this.v0=n,this.v1=e,this.v2=t}Mr.prototype=Object.create(Ue.prototype);Mr.prototype.constructor=Mr;Mr.prototype.isQuadraticBezierCurve=!0;Mr.prototype.getPoint=function(n,e=new fe){const t=e,i=this.v0,r=this.v1,s=this.v2;return t.set(Lc(n,i.x,r.x,s.x),Lc(n,i.y,r.y,s.y)),t};Mr.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Mr.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Mr.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function qr(n=new k,e=new k,t=new k){Ue.call(this),this.type="QuadraticBezierCurve3",this.v0=n,this.v1=e,this.v2=t}qr.prototype=Object.create(Ue.prototype);qr.prototype.constructor=qr;qr.prototype.isQuadraticBezierCurve3=!0;qr.prototype.getPoint=function(n,e=new k){const t=e,i=this.v0,r=this.v1,s=this.v2;return t.set(Lc(n,i.x,r.x,s.x),Lc(n,i.y,r.y,s.y),Lc(n,i.z,r.z,s.z)),t};qr.prototype.copy=function(n){return Ue.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};qr.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};qr.prototype.fromJSON=function(n){return Ue.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Ar(n=[]){Ue.call(this),this.type="SplineCurve",this.points=n}Ar.prototype=Object.create(Ue.prototype);Ar.prototype.constructor=Ar;Ar.prototype.isSplineCurve=!0;Ar.prototype.getPoint=function(n,e=new fe){const t=e,i=this.points,r=(i.length-1)*n,s=Math.floor(r),o=r-s,a=i[s===0?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],u=i[s>i.length-3?i.length-1:s+2];return t.set($_(o,a.x,l.x,c.x,u.x),$_(o,a.y,l.y,c.y,u.y)),t};Ar.prototype.copy=function(n){Ue.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const i=n.points[e];this.points.push(i.clone())}return this};Ar.prototype.toJSON=function(){const n=Ue.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const i=this.points[e];n.points.push(i.toArray())}return n};Ar.prototype.fromJSON=function(n){Ue.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const i=n.points[e];this.points.push(new fe().fromArray(i))}return this};var Zg=Object.freeze({__proto__:null,ArcCurve:Ll,CatmullRomCurve3:Kn,CubicBezierCurve:Er,CubicBezierCurve3:jr,EllipseCurve:Pi,LineCurve:mi,LineCurve3:Cr,QuadraticBezierCurve:Mr,QuadraticBezierCurve3:qr,SplineCurve:Ar});function Gs(){Ue.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}Gs.prototype=Object.assign(Object.create(Ue.prototype),{constructor:Gs,add:function(n){this.curves.push(n)},closePath:function(){const n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new mi(e,n))},getPoint:function(n){const e=n*this.getLength(),t=this.getCurveLengths();let i=0;for(;i<t.length;){if(t[i]>=e){const r=t[i]-e,s=this.curves[i],o=s.getLength(),a=o===0?0:1-r/o;return s.getPointAt(a)}i++}return null},getLength:function(){const n=this.getCurveLengths();return n[n.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const n=[];let e=0;for(let t=0,i=this.curves.length;t<i;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n},getSpacedPoints:function(n=40){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e},getPoints:function(n=12){const e=[];let t;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s&&s.isEllipseCurve?n*2:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?n*s.points.length:n,a=s.getPoints(o);for(let l=0;l<a.length;l++){const c=a[l];t&&t.equals(c)||(e.push(c),t=c)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(n){Ue.prototype.copy.call(this,n),this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const i=n.curves[e];this.curves.push(i.clone())}return this.autoClose=n.autoClose,this},toJSON:function(){const n=Ue.prototype.toJSON.call(this);n.autoClose=this.autoClose,n.curves=[];for(let e=0,t=this.curves.length;e<t;e++){const i=this.curves[e];n.curves.push(i.toJSON())}return n},fromJSON:function(n){Ue.prototype.fromJSON.call(this,n),this.autoClose=n.autoClose,this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const i=n.curves[e];this.curves.push(new Zg[i.type]().fromJSON(i))}return this}});function _r(n){Gs.call(this),this.type="Path",this.currentPoint=new fe,n&&this.setFromPoints(n)}_r.prototype=Object.assign(Object.create(Gs.prototype),{constructor:_r,setFromPoints:function(n){this.moveTo(n[0].x,n[0].y);for(let e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this},moveTo:function(n,e){return this.currentPoint.set(n,e),this},lineTo:function(n,e){const t=new mi(this.currentPoint.clone(),new fe(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this},quadraticCurveTo:function(n,e,t,i){const r=new Mr(this.currentPoint.clone(),new fe(n,e),new fe(t,i));return this.curves.push(r),this.currentPoint.set(t,i),this},bezierCurveTo:function(n,e,t,i,r,s){const o=new Er(this.currentPoint.clone(),new fe(n,e),new fe(t,i),new fe(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this},splineThru:function(n){const e=[this.currentPoint.clone()].concat(n),t=new Ar(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this},arc:function(n,e,t,i,r,s){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(n+o,e+a,t,i,r,s),this},absarc:function(n,e,t,i,r,s){return this.absellipse(n,e,t,t,i,r,s),this},ellipse:function(n,e,t,i,r,s,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(n+l,e+c,t,i,r,s,o,a),this},absellipse:function(n,e,t,i,r,s,o,a){const l=new Pi(n,e,t,i,r,s,o,a);if(this.curves.length>0){const u=l.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(n){return Gs.prototype.copy.call(this,n),this.currentPoint.copy(n.currentPoint),this},toJSON:function(){const n=Gs.prototype.toJSON.call(this);return n.currentPoint=this.currentPoint.toArray(),n},fromJSON:function(n){return Gs.prototype.fromJSON.call(this,n),this.currentPoint.fromArray(n.currentPoint),this}});function Ys(n){_r.call(this,n),this.uuid=Ze.generateUUID(),this.type="Shape",this.holes=[]}Ys.prototype=Object.assign(Object.create(_r.prototype),{constructor:Ys,getPointsHoles:function(n){const e=[];for(let t=0,i=this.holes.length;t<i;t++)e[t]=this.holes[t].getPoints(n);return e},extractPoints:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}},copy:function(n){_r.prototype.copy.call(this,n),this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const i=n.holes[e];this.holes.push(i.clone())}return this},toJSON:function(){const n=_r.prototype.toJSON.call(this);n.uuid=this.uuid,n.holes=[];for(let e=0,t=this.holes.length;e<t;e++){const i=this.holes[e];n.holes.push(i.toJSON())}return n},fromJSON:function(n){_r.prototype.fromJSON.call(this,n),this.uuid=n.uuid,this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const i=n.holes[e];this.holes.push(new _r().fromJSON(i))}return this}});function qt(n,e=1){ze.call(this),this.type="Light",this.color=new Ne(n),this.intensity=e}qt.prototype=Object.assign(Object.create(ze.prototype),{constructor:qt,isLight:!0,copy:function(n){return ze.prototype.copy.call(this,n),this.color.copy(n.color),this.intensity=n.intensity,this},toJSON:function(n){const e=ze.prototype.toJSON.call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}});function uf(n,e,t){qt.call(this,n,t),this.type="HemisphereLight",this.position.copy(ze.DefaultUp),this.updateMatrix(),this.groundColor=new Ne(e)}uf.prototype=Object.assign(Object.create(qt.prototype),{constructor:uf,isHemisphereLight:!0,copy:function(n){return qt.prototype.copy.call(this,n),this.groundColor.copy(n.groundColor),this}});function ys(n){this.camera=n,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new fe(512,512),this.map=null,this.mapPass=null,this.matrix=new ut,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Wu,this._frameExtents=new fe(1,1),this._viewportCount=1,this._viewports=[new kt(0,0,1,1)]}Object.assign(ys.prototype,{_projScreenMatrix:new ut,_lightPositionWorld:new k,_lookTarget:new k,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(n){const e=this.camera,t=this.matrix,i=this._projScreenMatrix,r=this._lookTarget,s=this._lightPositionWorld;s.setFromMatrixPosition(n.matrixWorld),e.position.copy(s),r.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(r),e.updateMatrixWorld(),i.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(e.projectionMatrix),t.multiply(e.matrixWorldInverse)},getViewport:function(n){return this._viewports[n]},getFrameExtents:function(){return this._frameExtents},copy:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n={};return this.bias!==0&&(n.bias=this.bias),this.normalBias!==0&&(n.normalBias=this.normalBias),this.radius!==1&&(n.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}});function Jg(){ys.call(this,new fn(50,1,.5,500)),this.focus=1}Jg.prototype=Object.assign(Object.create(ys.prototype),{constructor:Jg,isSpotLightShadow:!0,updateMatrices:function(n){const e=this.camera,t=Ze.RAD2DEG*2*n.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=n.distance||e.far;(t!==e.fov||i!==e.aspect||r!==e.far)&&(e.fov=t,e.aspect=i,e.far=r,e.updateProjectionMatrix()),ys.prototype.updateMatrices.call(this,n)}});function hf(n,e,t,i,r,s){qt.call(this,n,e),this.type="SpotLight",this.position.copy(ze.DefaultUp),this.updateMatrix(),this.target=new ze,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(o){this.intensity=o/Math.PI}}),this.distance=t!==void 0?t:0,this.angle=i!==void 0?i:Math.PI/3,this.penumbra=r!==void 0?r:0,this.decay=s!==void 0?s:1,this.shadow=new Jg}hf.prototype=Object.assign(Object.create(qt.prototype),{constructor:hf,isSpotLight:!0,copy:function(n){return qt.prototype.copy.call(this,n),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function Qg(){ys.call(this,new fn(90,1,.5,500)),this._frameExtents=new fe(4,2),this._viewportCount=6,this._viewports=[new kt(2,1,1,1),new kt(0,1,1,1),new kt(3,1,1,1),new kt(1,1,1,1),new kt(3,0,1,1),new kt(1,0,1,1)],this._cubeDirections=[new k(1,0,0),new k(-1,0,0),new k(0,0,1),new k(0,0,-1),new k(0,1,0),new k(0,-1,0)],this._cubeUps=[new k(0,1,0),new k(0,1,0),new k(0,1,0),new k(0,1,0),new k(0,0,1),new k(0,0,-1)]}Qg.prototype=Object.assign(Object.create(ys.prototype),{constructor:Qg,isPointLightShadow:!0,updateMatrices:function(n,e=0){const t=this.camera,i=this.matrix,r=this._lightPositionWorld,s=this._lookTarget,o=this._projScreenMatrix;r.setFromMatrixPosition(n.matrixWorld),t.position.copy(r),s.copy(t.position),s.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(s),t.updateMatrixWorld(),i.makeTranslation(-r.x,-r.y,-r.z),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}});function df(n,e,t,i){qt.call(this,n,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(r){this.intensity=r/(4*Math.PI)}}),this.distance=t!==void 0?t:0,this.decay=i!==void 0?i:1,this.shadow=new Qg}df.prototype=Object.assign(Object.create(qt.prototype),{constructor:df,isPointLight:!0,copy:function(n){return qt.prototype.copy.call(this,n),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}});function Dl(n=-1,e=1,t=1,i=-1,r=.1,s=2e3){Gr.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=n,this.right=e,this.top=t,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}Dl.prototype=Object.assign(Object.create(Gr.prototype),{constructor:Dl,isOrthographicCamera:!0,copy:function(n,e){return Gr.prototype.copy.call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=n.view===null?null:Object.assign({},n.view),this},setViewOffset:function(n,e,t,i,r,s){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=t-n,s=t+n,o=i+e,a=i-e;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,s=r+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=ze.prototype.toJSON.call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}});function ey(){ys.call(this,new Dl(-5,5,5,-5,.5,500))}ey.prototype=Object.assign(Object.create(ys.prototype),{constructor:ey,isDirectionalLightShadow:!0,updateMatrices:function(n){ys.prototype.updateMatrices.call(this,n)}});function ff(n,e){qt.call(this,n,e),this.type="DirectionalLight",this.position.copy(ze.DefaultUp),this.updateMatrix(),this.target=new ze,this.shadow=new ey}ff.prototype=Object.assign(Object.create(qt.prototype),{constructor:ff,isDirectionalLight:!0,copy:function(n){return qt.prototype.copy.call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function pf(n,e){qt.call(this,n,e),this.type="AmbientLight"}pf.prototype=Object.assign(Object.create(qt.prototype),{constructor:pf,isAmbientLight:!0});function mf(n,e,t,i){qt.call(this,n,e),this.type="RectAreaLight",this.width=t!==void 0?t:10,this.height=i!==void 0?i:10}mf.prototype=Object.assign(Object.create(qt.prototype),{constructor:mf,isRectAreaLight:!0,copy:function(n){return qt.prototype.copy.call(this,n),this.width=n.width,this.height=n.height,this},toJSON:function(n){const e=qt.prototype.toJSON.call(this,n);return e.object.width=this.width,e.object.height=this.height,e}});class LA{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new k)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*i),t.addScaledVector(o[4],1.092548*(i*r)),t.addScaledVector(o[5],1.092548*(r*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(i*s)),t.addScaledVector(o[8],.546274*(i*i-r*r)),t}getIrradianceAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*i),t.addScaledVector(o[4],2*.429043*i*r),t.addScaledVector(o[5],2*.429043*r*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*i*s),t.addScaledVector(o[8],.429043*(i*i-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const i=e.x,r=e.y,s=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*s,t[3]=.488603*i,t[4]=1.092548*i*r,t[5]=1.092548*r*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*i*s,t[8]=.546274*(i*i-r*r)}}function Xi(n,e){qt.call(this,void 0,e),this.type="LightProbe",this.sh=n!==void 0?n:new LA}Xi.prototype=Object.assign(Object.create(qt.prototype),{constructor:Xi,isLightProbe:!0,copy:function(n){return qt.prototype.copy.call(this,n),this.sh.copy(n.sh),this},fromJSON:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this},toJSON:function(n){const e=qt.prototype.toJSON.call(this,n);return e.object.sh=this.sh.toArray(),e}});function gf(n){Pt.call(this,n),this.textures={}}gf.prototype=Object.assign(Object.create(Pt.prototype),{constructor:gf,load:function(n,e,t,i){const r=this,s=new Ji(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(n,function(o){try{e(r.parse(JSON.parse(o)))}catch(a){i?i(a):console.error(a),r.manager.itemError(n)}},t,i)},parse:function(n){const e=this.textures;function t(r){return e[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),e[r]}const i=new _Z[n.type];if(n.uuid!==void 0&&(i.uuid=n.uuid),n.name!==void 0&&(i.name=n.name),n.color!==void 0&&i.color!==void 0&&i.color.setHex(n.color),n.roughness!==void 0&&(i.roughness=n.roughness),n.metalness!==void 0&&(i.metalness=n.metalness),n.sheen!==void 0&&(i.sheen=new Ne().setHex(n.sheen)),n.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(n.emissive),n.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(n.specular),n.shininess!==void 0&&(i.shininess=n.shininess),n.clearcoat!==void 0&&(i.clearcoat=n.clearcoat),n.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=n.clearcoatRoughness),n.fog!==void 0&&(i.fog=n.fog),n.flatShading!==void 0&&(i.flatShading=n.flatShading),n.blending!==void 0&&(i.blending=n.blending),n.combine!==void 0&&(i.combine=n.combine),n.side!==void 0&&(i.side=n.side),n.opacity!==void 0&&(i.opacity=n.opacity),n.transparent!==void 0&&(i.transparent=n.transparent),n.alphaTest!==void 0&&(i.alphaTest=n.alphaTest),n.depthTest!==void 0&&(i.depthTest=n.depthTest),n.depthWrite!==void 0&&(i.depthWrite=n.depthWrite),n.colorWrite!==void 0&&(i.colorWrite=n.colorWrite),n.stencilWrite!==void 0&&(i.stencilWrite=n.stencilWrite),n.stencilWriteMask!==void 0&&(i.stencilWriteMask=n.stencilWriteMask),n.stencilFunc!==void 0&&(i.stencilFunc=n.stencilFunc),n.stencilRef!==void 0&&(i.stencilRef=n.stencilRef),n.stencilFuncMask!==void 0&&(i.stencilFuncMask=n.stencilFuncMask),n.stencilFail!==void 0&&(i.stencilFail=n.stencilFail),n.stencilZFail!==void 0&&(i.stencilZFail=n.stencilZFail),n.stencilZPass!==void 0&&(i.stencilZPass=n.stencilZPass),n.wireframe!==void 0&&(i.wireframe=n.wireframe),n.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=n.wireframeLinewidth),n.wireframeLinecap!==void 0&&(i.wireframeLinecap=n.wireframeLinecap),n.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=n.wireframeLinejoin),n.rotation!==void 0&&(i.rotation=n.rotation),n.linewidth!==1&&(i.linewidth=n.linewidth),n.dashSize!==void 0&&(i.dashSize=n.dashSize),n.gapSize!==void 0&&(i.gapSize=n.gapSize),n.scale!==void 0&&(i.scale=n.scale),n.polygonOffset!==void 0&&(i.polygonOffset=n.polygonOffset),n.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=n.polygonOffsetFactor),n.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=n.polygonOffsetUnits),n.skinning!==void 0&&(i.skinning=n.skinning),n.morphTargets!==void 0&&(i.morphTargets=n.morphTargets),n.morphNormals!==void 0&&(i.morphNormals=n.morphNormals),n.dithering!==void 0&&(i.dithering=n.dithering),n.vertexTangents!==void 0&&(i.vertexTangents=n.vertexTangents),n.visible!==void 0&&(i.visible=n.visible),n.toneMapped!==void 0&&(i.toneMapped=n.toneMapped),n.userData!==void 0&&(i.userData=n.userData),n.vertexColors!==void 0&&(typeof n.vertexColors=="number"?i.vertexColors=n.vertexColors>0:i.vertexColors=n.vertexColors),n.uniforms!==void 0)for(const r in n.uniforms){const s=n.uniforms[r];switch(i.uniforms[r]={},s.type){case"t":i.uniforms[r].value=t(s.value);break;case"c":i.uniforms[r].value=new Ne().setHex(s.value);break;case"v2":i.uniforms[r].value=new fe().fromArray(s.value);break;case"v3":i.uniforms[r].value=new k().fromArray(s.value);break;case"v4":i.uniforms[r].value=new kt().fromArray(s.value);break;case"m3":i.uniforms[r].value=new Ei().fromArray(s.value);break;case"m4":i.uniforms[r].value=new ut().fromArray(s.value);break;default:i.uniforms[r].value=s.value}}if(n.defines!==void 0&&(i.defines=n.defines),n.vertexShader!==void 0&&(i.vertexShader=n.vertexShader),n.fragmentShader!==void 0&&(i.fragmentShader=n.fragmentShader),n.extensions!==void 0)for(const r in n.extensions)i.extensions[r]=n.extensions[r];if(n.shading!==void 0&&(i.flatShading=n.shading===1),n.size!==void 0&&(i.size=n.size),n.sizeAttenuation!==void 0&&(i.sizeAttenuation=n.sizeAttenuation),n.map!==void 0&&(i.map=t(n.map)),n.matcap!==void 0&&(i.matcap=t(n.matcap)),n.alphaMap!==void 0&&(i.alphaMap=t(n.alphaMap)),n.bumpMap!==void 0&&(i.bumpMap=t(n.bumpMap)),n.bumpScale!==void 0&&(i.bumpScale=n.bumpScale),n.normalMap!==void 0&&(i.normalMap=t(n.normalMap)),n.normalMapType!==void 0&&(i.normalMapType=n.normalMapType),n.normalScale!==void 0){let r=n.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new fe().fromArray(r)}return n.displacementMap!==void 0&&(i.displacementMap=t(n.displacementMap)),n.displacementScale!==void 0&&(i.displacementScale=n.displacementScale),n.displacementBias!==void 0&&(i.displacementBias=n.displacementBias),n.roughnessMap!==void 0&&(i.roughnessMap=t(n.roughnessMap)),n.metalnessMap!==void 0&&(i.metalnessMap=t(n.metalnessMap)),n.emissiveMap!==void 0&&(i.emissiveMap=t(n.emissiveMap)),n.emissiveIntensity!==void 0&&(i.emissiveIntensity=n.emissiveIntensity),n.specularMap!==void 0&&(i.specularMap=t(n.specularMap)),n.envMap!==void 0&&(i.envMap=t(n.envMap)),n.envMapIntensity!==void 0&&(i.envMapIntensity=n.envMapIntensity),n.reflectivity!==void 0&&(i.reflectivity=n.reflectivity),n.refractionRatio!==void 0&&(i.refractionRatio=n.refractionRatio),n.lightMap!==void 0&&(i.lightMap=t(n.lightMap)),n.lightMapIntensity!==void 0&&(i.lightMapIntensity=n.lightMapIntensity),n.aoMap!==void 0&&(i.aoMap=t(n.aoMap)),n.aoMapIntensity!==void 0&&(i.aoMapIntensity=n.aoMapIntensity),n.gradientMap!==void 0&&(i.gradientMap=t(n.gradientMap)),n.clearcoatMap!==void 0&&(i.clearcoatMap=t(n.clearcoatMap)),n.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=t(n.clearcoatRoughnessMap)),n.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=t(n.clearcoatNormalMap)),n.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new fe().fromArray(n.clearcoatNormalScale)),n.transmission!==void 0&&(i.transmission=n.transmission),n.transmissionMap!==void 0&&(i.transmissionMap=t(n.transmissionMap)),i},setTextures:function(n){return this.textures=n,this}});const gv={decodeText:function(n){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(n);let e="";for(let t=0,i=n.length;t<i;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}},extractUrlBase:function(n){const e=n.lastIndexOf("/");return e===-1?"./":n.substr(0,e+1)}};function Tu(){He.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}Tu.prototype=Object.assign(Object.create(He.prototype),{constructor:Tu,isInstancedBufferGeometry:!0,copy:function(n){return He.prototype.copy.call(this,n),this.instanceCount=n.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n=He.prototype.toJSON.call(this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}});function yf(n,e,t,i){typeof t=="number"&&(i=t,t=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Xe.call(this,n,e,t),this.meshPerAttribute=i||1}yf.prototype=Object.assign(Object.create(Xe.prototype),{constructor:yf,isInstancedBufferAttribute:!0,copy:function(n){return Xe.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},toJSON:function(){const n=Xe.prototype.toJSON.call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}});function vf(n){Pt.call(this,n)}vf.prototype=Object.assign(Object.create(Pt.prototype),{constructor:vf,load:function(n,e,t,i){const r=this,s=new Ji(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(n,function(o){try{e(r.parse(JSON.parse(o)))}catch(a){i?i(a):console.error(a),r.manager.itemError(n)}},t,i)},parse:function(n){const e={},t={};function i(d,f){if(e[f]!==void 0)return e[f];const m=d.interleavedBuffers[f],y=r(d,m.buffer),g=Ec(m.type,y),v=new Ci(g,m.stride);return v.uuid=m.uuid,e[f]=v,v}function r(d,f){if(t[f]!==void 0)return t[f];const m=d.arrayBuffers[f],y=new Uint32Array(m).buffer;return t[f]=y,y}const s=n.isInstancedBufferGeometry?new Tu:new He,o=n.data.index;if(o!==void 0){const d=Ec(o.type,o.array);s.setIndex(new Xe(d,1))}const a=n.data.attributes;for(const d in a){const f=a[d];let p;if(f.isInterleavedBufferAttribute){const m=i(n.data,f.data);p=new so(m,f.itemSize,f.offset,f.normalized)}else{const m=Ec(f.type,f.array),y=f.isInstancedBufferAttribute?yf:Xe;p=new y(m,f.itemSize,f.normalized)}f.name!==void 0&&(p.name=f.name),s.setAttribute(d,p)}const l=n.data.morphAttributes;if(l)for(const d in l){const f=l[d],p=[];for(let m=0,y=f.length;m<y;m++){const g=f[m];let v;if(g.isInterleavedBufferAttribute){const _=i(n.data,g.data);v=new so(_,g.itemSize,g.offset,g.normalized)}else{const _=Ec(g.type,g.array);v=new Xe(_,g.itemSize,g.normalized)}g.name!==void 0&&(v.name=g.name),p.push(v)}s.morphAttributes[d]=p}n.data.morphTargetsRelative&&(s.morphTargetsRelative=!0);const u=n.data.groups||n.data.drawcalls||n.data.offsets;if(u!==void 0)for(let d=0,f=u.length;d!==f;++d){const p=u[d];s.addGroup(p.start,p.count,p.materialIndex)}const h=n.data.boundingSphere;if(h!==void 0){const d=new k;h.center!==void 0&&d.fromArray(h.center),s.boundingSphere=new go(d,h.radius)}return n.name&&(s.name=n.name),n.userData&&(s.userData=n.userData),s}});class IZ extends Pt{constructor(e){super(e)}load(e,t,i,r){const s=this,o=this.path===""?gv.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Ji(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){r!==void 0&&r(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(c,t)},i,r)}parse(e,t){const i=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,r),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,s,l,i),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const d in o)if(o[d]instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}parseShapes(e){const t={};if(e!==void 0)for(let i=0,r=e.length;i<r;i++){const s=new Ys().fromJSON(e[i]);t[s.uuid]=s}return t}parseSkeletons(e,t){const i={},r={};if(t.traverse(function(s){s.isBone&&(r[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new fu().fromJSON(e[s],r);i[a.uuid]=a}return i}parseGeometries(e,t){const i={};let r;if(e!==void 0){const s=new vf;for(let o=0,a=e.length;o<a;o++){let l;const c=e[o];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":l=new Jn[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":l=new Jn[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":l=new Jn[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":l=new Jn[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":l=new Jn[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":l=new Jn[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":l=new Jn[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":l=new Jn[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":l=new Jn[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":l=new Jn[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":l=new Jn[c.type](new Zg[c.path.type]().fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":l=new Jn[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":l=new Jn[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":r=[];for(let h=0,d=c.shapes.length;h<d;h++){const f=t[c.shapes[h]];r.push(f)}l=new Jn[c.type](r,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":r=[];for(let h=0,d=c.shapes.length;h<d;h++){const f=t[c.shapes[h]];r.push(f)}const u=c.options.extrudePath;u!==void 0&&(c.options.extrudePath=new Zg[u.type]().fromJSON(u)),l=new Jn[c.type](r,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":l=s.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),l.isBufferGeometry===!0&&c.userData!==void 0&&(l.userData=c.userData),i[c.uuid]=l}}return i}parseMaterials(e,t){const i={},r={};if(e!==void 0){const s=new gf;s.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];if(l.type==="MultiMaterial"){const c=[];for(let u=0;u<l.materials.length;u++){const h=l.materials[u];i[h.uuid]===void 0&&(i[h.uuid]=s.parse(h)),c.push(i[h.uuid])}r[l.uuid]=c}else i[l.uuid]===void 0&&(i[l.uuid]=s.parse(l)),r[l.uuid]=i[l.uuid]}}return r}parseAnimations(e){const t={};if(e!==void 0)for(let i=0;i<e.length;i++){const r=e[i],s=Si.parse(r);t[s.uuid]=s}return t}parseImages(e,t){const i=this,r={};let s;function o(l){return i.manager.itemStart(l),s.load(l,function(){i.manager.itemEnd(l)},void 0,function(){i.manager.itemError(l),i.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:i.resourcePath+c;return o(u)}else return l.data?{data:Ec(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new pv(t);s=new Nl(l),s.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],d=h.url;if(Array.isArray(d)){r[h.uuid]=[];for(let f=0,p=d.length;f<p;f++){const m=d[f],y=a(m);y!==null&&(y instanceof HTMLImageElement?r[h.uuid].push(y):r[h.uuid].push(new ms(y.data,y.width,y.height)))}}else{const f=a(h.url);f!==null&&(r[h.uuid]=f)}}}return r}parseTextures(e,t){function i(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const r={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let l;const c=t[a.image];Array.isArray(c)?(l=new Hr(c),c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new ms(c.data,c.width,c.height):l=new Bt(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=i(a.mapping,PZ)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=i(a.wrap[0],B_),l.wrapT=i(a.wrap[1],B_)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=i(a.minFilter,z_)),a.magFilter!==void 0&&(l.magFilter=i(a.magFilter,z_)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),r[a.uuid]=l}return r}parseObject(e,t,i,r){let s;function o(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function a(u){if(u!==void 0){if(Array.isArray(u)){const h=[];for(let d=0,f=u.length;d<f;d++){const p=u[d];i[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),h.push(i[p])}return h}return i[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),i[u]}}let l,c;switch(e.type){case"Scene":s=new hv,e.background!==void 0&&Number.isInteger(e.background)&&(s.background=new Ne(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?s.fog=new Xf(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(s.fog=new qf(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":s=new fn(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(s.focus=e.focus),e.zoom!==void 0&&(s.zoom=e.zoom),e.filmGauge!==void 0&&(s.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(s.filmOffset=e.filmOffset),e.view!==void 0&&(s.view=Object.assign({},e.view));break;case"OrthographicCamera":s=new Dl(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(s.zoom=e.zoom),e.view!==void 0&&(s.view=Object.assign({},e.view));break;case"AmbientLight":s=new pf(e.color,e.intensity);break;case"DirectionalLight":s=new ff(e.color,e.intensity);break;case"PointLight":s=new df(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":s=new mf(e.color,e.intensity,e.width,e.height);break;case"SpotLight":s=new hf(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":s=new uf(e.color,e.groundColor,e.intensity);break;case"LightProbe":s=new Xi().fromJSON(e);break;case"SkinnedMesh":l=o(e.geometry),c=a(e.material),s=new hu(l,c),e.bindMode!==void 0&&(s.bindMode=e.bindMode),e.bindMatrix!==void 0&&s.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(s.skeleton=e.skeleton);break;case"Mesh":l=o(e.geometry),c=a(e.material),s=new jt(l,c);break;case"InstancedMesh":l=o(e.geometry),c=a(e.material);const u=e.count,h=e.instanceMatrix;s=new Ud(l,c,u),s.instanceMatrix=new Xe(new Float32Array(h.array),16);break;case"LOD":s=new uu;break;case"Line":s=new Zi(o(e.geometry),a(e.material));break;case"LineLoop":s=new Vd(o(e.geometry),a(e.material));break;case"LineSegments":s=new oi(o(e.geometry),a(e.material));break;case"PointCloud":case"Points":s=new Ml(o(e.geometry),a(e.material));break;case"Sprite":s=new cu(a(e.material));break;case"Group":s=new Vs;break;case"Bone":s=new du;break;default:s=new ze}if(s.uuid=e.uuid,e.name!==void 0&&(s.name=e.name),e.matrix!==void 0?(s.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(s.matrixAutoUpdate=e.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(e.position!==void 0&&s.position.fromArray(e.position),e.rotation!==void 0&&s.rotation.fromArray(e.rotation),e.quaternion!==void 0&&s.quaternion.fromArray(e.quaternion),e.scale!==void 0&&s.scale.fromArray(e.scale)),e.castShadow!==void 0&&(s.castShadow=e.castShadow),e.receiveShadow!==void 0&&(s.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(s.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(s.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(s.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&s.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(s.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(s.visible=e.visible),e.frustumCulled!==void 0&&(s.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(s.renderOrder=e.renderOrder),e.userData!==void 0&&(s.userData=e.userData),e.layers!==void 0&&(s.layers.mask=e.layers),e.children!==void 0){const u=e.children;for(let h=0;h<u.length;h++)s.add(this.parseObject(u[h],t,i,r))}if(e.animations!==void 0){const u=e.animations;for(let h=0;h<u.length;h++){const d=u[h];s.animations.push(r[d])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(s.autoUpdate=e.autoUpdate);const u=e.levels;for(let h=0;h<u.length;h++){const d=u[h],f=s.getObjectByProperty("uuid",d.object);f!==void 0&&s.addLevel(f,d.distance)}}return s}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(i){if(i.isSkinnedMesh===!0&&i.skeleton!==void 0){const r=t[i.skeleton];r===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",i.skeleton):i.bind(r,i.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const PZ={UVMapping:Gf,CubeReflectionMapping:zu,CubeRefractionMapping:Uu,EquirectangularReflectionMapping:Od,EquirectangularRefractionMapping:Fd,CubeUVReflectionMapping:Yl,CubeUVRefractionMapping:Vu},B_={RepeatWrapping:Yc,ClampToEdgeWrapping:ii,MirroredRepeatWrapping:Kc},z_={NearestFilter:bn,NearestMipmapNearestFilter:$d,NearestMipmapLinearFilter:Bd,LinearFilter:Cn,LinearMipmapNearestFilter:iv,LinearMipmapLinearFilter:Kl};function ty(n){typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Pt.call(this,n),this.options={premultiplyAlpha:"none"}}ty.prototype=Object.assign(Object.create(Pt.prototype),{constructor:ty,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(n,e,t,i){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const r=this,s=pa.get(n);if(s!==void 0)return r.manager.itemStart(n),setTimeout(function(){e&&e(s),r.manager.itemEnd(n)},0),s;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(n,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,r.options)}).then(function(a){pa.add(n,a),e&&e(a),r.manager.itemEnd(n)}).catch(function(a){i&&i(a),r.manager.itemError(n),r.manager.itemEnd(n)}),r.manager.itemStart(n)}});function yv(){this.type="ShapePath",this.color=new Ne,this.subPaths=[],this.currentPath=null}Object.assign(yv.prototype,{moveTo:function(n,e){return this.currentPath=new _r,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this},lineTo:function(n,e){return this.currentPath.lineTo(n,e),this},quadraticCurveTo:function(n,e,t,i){return this.currentPath.quadraticCurveTo(n,e,t,i),this},bezierCurveTo:function(n,e,t,i,r,s){return this.currentPath.bezierCurveTo(n,e,t,i,r,s),this},splineThru:function(n){return this.currentPath.splineThru(n),this},toShapes:function(n,e){function t(g){const v=[];for(let _=0,b=g.length;_<b;_++){const S=g[_],w=new Ys;w.curves=S.curves,v.push(w)}return v}function i(g,v){const _=v.length;let b=!1;for(let S=_-1,w=0;w<_;S=w++){let T=v[S],R=v[w],M=R.x-T.x,P=R.y-T.y;if(Math.abs(P)>Number.EPSILON){if(P<0&&(T=v[w],M=-M,R=v[S],P=-P),g.y<T.y||g.y>R.y)continue;if(g.y===T.y){if(g.x===T.x)return!0}else{const L=P*(g.x-T.x)-M*(g.y-T.y);if(L===0)return!0;if(L<0)continue;b=!b}}else{if(g.y!==T.y)continue;if(R.x<=g.x&&g.x<=T.x||T.x<=g.x&&g.x<=R.x)return!0}}return b}const r=ds.isClockWise,s=this.subPaths;if(s.length===0)return[];if(e===!0)return t(s);let o,a,l;const c=[];if(s.length===1)return a=s[0],l=new Ys,l.curves=a.curves,c.push(l),c;let u=!r(s[0].getPoints());u=n?!u:u;const h=[],d=[];let f=[],p=0,m;d[p]=void 0,f[p]=[];for(let g=0,v=s.length;g<v;g++)a=s[g],m=a.getPoints(),o=r(m),o=n?!o:o,o?(!u&&d[p]&&p++,d[p]={s:new Ys,p:m},d[p].s.curves=a.curves,u&&p++,f[p]=[]):f[p].push({h:a,p:m[0]});if(!d[0])return t(s);if(d.length>1){let g=!1;const v=[];for(let _=0,b=d.length;_<b;_++)h[_]=[];for(let _=0,b=d.length;_<b;_++){const S=f[_];for(let w=0;w<S.length;w++){const T=S[w];let R=!0;for(let M=0;M<d.length;M++)i(T.p,d[M].p)&&(_!==M&&v.push({froms:_,tos:M,hole:w}),R?(R=!1,h[M].push(T)):g=!0);R&&h[_].push(T)}}v.length>0&&(g||(f=h))}let y;for(let g=0,v=d.length;g<v;g++){l=d[g].s,c.push(l),y=f[g];for(let _=0,b=y.length;_<b;_++)l.holes.push(y[_].h)}return c}});class DA{constructor(e){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=e}generateShapes(e,t=100){const i=[],r=NZ(e,t,this.data);for(let s=0,o=r.length;s<o;s++)Array.prototype.push.apply(i,r[s].toShapes());return i}}function NZ(n,e,t){const i=Array.from?Array.from(n):String(n).split(""),r=e/t.resolution,s=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*r,o=[];let a=0,l=0;for(let c=0;c<i.length;c++){const u=i[c];if(u===`
`)a=0,l-=s;else{const h=LZ(u,r,a,l,t);a+=h.offsetX,o.push(h.path)}}return o}function LZ(n,e,t,i,r){const s=r.glyphs[n]||r.glyphs["?"];if(!s){console.error('THREE.Font: character "'+n+'" does not exists in font family '+r.familyName+".");return}const o=new yv;let a,l,c,u,h,d,f,p;if(s.o){const m=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let y=0,g=m.length;y<g;)switch(m[y++]){case"m":a=m[y++]*e+t,l=m[y++]*e+i,o.moveTo(a,l);break;case"l":a=m[y++]*e+t,l=m[y++]*e+i,o.lineTo(a,l);break;case"q":c=m[y++]*e+t,u=m[y++]*e+i,h=m[y++]*e+t,d=m[y++]*e+i,o.quadraticCurveTo(h,d,c,u);break;case"b":c=m[y++]*e+t,u=m[y++]*e+i,h=m[y++]*e+t,d=m[y++]*e+i,f=m[y++]*e+t,p=m[y++]*e+i,o.bezierCurveTo(h,d,f,p,c,u);break}}return{offsetX:s.ha*e,path:o}}function ny(n){Pt.call(this,n)}ny.prototype=Object.assign(Object.create(Pt.prototype),{constructor:ny,load:function(n,e,t,i){const r=this,s=new Ji(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(r.withCredentials),s.load(n,function(o){let a;try{a=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(o.substring(65,o.length-2))}const l=r.parse(a);e&&e(l)},t,i)},parse:function(n){return new DA(n)}});let Gh;const vv={getContext:function(){return Gh===void 0&&(Gh=new(window.AudioContext||window.webkitAudioContext)),Gh},setContext:function(n){Gh=n}};function xf(n){Pt.call(this,n)}xf.prototype=Object.assign(Object.create(Pt.prototype),{constructor:xf,load:function(n,e,t,i){const r=this,s=new Ji(r.manager);s.setResponseType("arraybuffer"),s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(n,function(o){try{const a=o.slice(0);vv.getContext().decodeAudioData(a,function(c){e(c)})}catch(a){i?i(a):console.error(a),r.manager.itemError(n)}},t,i)}});function iy(n,e,t){Xi.call(this,void 0,t);const i=new Ne().set(n),r=new Ne().set(e),s=new k(i.r,i.g,i.b),o=new k(r.r,r.g,r.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}iy.prototype=Object.assign(Object.create(Xi.prototype),{constructor:iy,isHemisphereLightProbe:!0,copy:function(n){return Xi.prototype.copy.call(this,n),this},toJSON:function(n){return Xi.prototype.toJSON.call(this,n)}});function ry(n,e){Xi.call(this,void 0,e);const t=new Ne().set(n);this.sh.coefficients[0].set(t.r,t.g,t.b).multiplyScalar(2*Math.sqrt(Math.PI))}ry.prototype=Object.assign(Object.create(Xi.prototype),{constructor:ry,isAmbientLightProbe:!0,copy:function(n){return Xi.prototype.copy.call(this,n),this},toJSON:function(n){return Xi.prototype.toJSON.call(this,n)}});const U_=new ut,V_=new ut;function kA(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new fn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new fn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(kA.prototype,{update:function(n){const e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep;const i=n.projectionMatrix.clone(),r=e.eyeSep/2,s=r*e.near/e.focus,o=e.near*Math.tan(Ze.DEG2RAD*e.fov*.5)/e.zoom;let a,l;V_.elements[12]=-r,U_.elements[12]=r,a=-o*e.aspect+s,l=o*e.aspect+s,i.elements[0]=2*e.near/(l-a),i.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(i),a=-o*e.aspect-s,l=o*e.aspect-s,i.elements[0]=2*e.near/(l-a),i.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(i)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(V_),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(U_)}});class OA{constructor(e){this.autoStart=e!==void 0?e:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=G_(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=G_();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function G_(){return(typeof performance=="undefined"?Date:performance).now()}const So=new k,H_=new Xn,DZ=new k,To=new k;class kZ extends ze{constructor(){super(),this.type="AudioListener",this.context=vv.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new OA}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(So,H_,DZ),To.set(0,0,-1).applyQuaternion(H_),t.positionX){const r=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(So.x,r),t.positionY.linearRampToValueAtTime(So.y,r),t.positionZ.linearRampToValueAtTime(So.z,r),t.forwardX.linearRampToValueAtTime(To.x,r),t.forwardY.linearRampToValueAtTime(To.y,r),t.forwardZ.linearRampToValueAtTime(To.z,r),t.upX.linearRampToValueAtTime(i.x,r),t.upY.linearRampToValueAtTime(i.y,r),t.upZ.linearRampToValueAtTime(i.z,r)}else t.setPosition(So.x,So.y,So.z),t.setOrientation(To.x,To.y,To.z,i.x,i.y,i.z)}}class xv extends ze{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Eo=new k,W_=new Xn,OZ=new k,Co=new k;class FZ extends xv{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,i){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=i,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Eo,W_,OZ),Co.set(0,0,1).applyQuaternion(W_);const t=this.panner;if(t.positionX){const i=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Eo.x,i),t.positionY.linearRampToValueAtTime(Eo.y,i),t.positionZ.linearRampToValueAtTime(Eo.z,i),t.orientationX.linearRampToValueAtTime(Co.x,i),t.orientationY.linearRampToValueAtTime(Co.y,i),t.orientationZ.linearRampToValueAtTime(Co.z,i)}else t.setPosition(Eo.x,Eo.y,Eo.z),t.setOrientation(Co.x,Co.y,Co.z)}}class FA{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let i=0;i<t.length;i++)e+=t[i];return e/t.length}}function _v(n,e,t){this.binding=n,this.valueSize=t;let i,r,s;switch(e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(_v.prototype,{accumulate:function(n,e){const t=this.buffer,i=this.valueSize,r=n*i+i;let s=this.cumulativeWeight;if(s===0){for(let o=0;o!==i;++o)t[r+o]=t[o];s=e}else{s+=e;const o=e/s;this._mixBufferRegion(t,r,0,o,i)}this.cumulativeWeight=s},accumulateAdditive:function(n){const e=this.buffer,t=this.valueSize,i=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,n,t),this.cumulativeWeightAdditive+=n},apply:function(n){const e=this.valueSize,t=this.buffer,i=n*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const a=e*this._origIndex;this._mixBufferRegion(t,i,a,1-r,e)}s>0&&this._mixBufferRegionAdditive(t,i,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(t[a]!==t[a+e]){o.setValue(t,i);break}},saveOriginalState:function(){const n=this.binding,e=this.buffer,t=this.valueSize,i=t*this._origIndex;n.getValue(e,i);for(let r=t,s=i;r!==s;++r)e[r]=e[i+r%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const n=this.valueSize*3;this.binding.setValue(this.buffer,n)},_setAdditiveIdentityNumeric:function(){const n=this._addIndex*this.valueSize,e=n+this.valueSize;for(let t=n;t<e;t++)this.buffer[t]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]},_select:function(n,e,t,i,r){if(i>=.5)for(let s=0;s!==r;++s)n[e+s]=n[t+s]},_slerp:function(n,e,t,i){Xn.slerpFlat(n,e,n,e,n,t,i)},_slerpAdditive:function(n,e,t,i,r){const s=this._workIndex*r;Xn.multiplyQuaternionsFlat(n,s,n,e,n,t),Xn.slerpFlat(n,e,n,e,n,s,i)},_lerp:function(n,e,t,i,r){const s=1-i;for(let o=0;o!==r;++o){const a=e+o;n[a]=n[a]*s+n[t+o]*i}},_lerpAdditive:function(n,e,t,i,r){for(let s=0;s!==r;++s){const o=e+s;n[o]=n[o]+n[t+s]*i}}});const bv="\\[\\]\\.:\\/",$Z=new RegExp("["+bv+"]","g"),wv="[^"+bv+"]",BZ="[^"+bv.replace("\\.","")+"]",zZ=/((?:WC+[\/:])*)/.source.replace("WC",wv),UZ=/(WCOD+)?/.source.replace("WCOD",BZ),VZ=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",wv),GZ=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",wv),HZ=new RegExp("^"+zZ+UZ+VZ+GZ+"$"),WZ=["material","materials","bones"];function $A(n,e,t){const i=t||Yn.parseTrackName(e);this._targetGroup=n,this._bindings=n.subscribe_(e,i)}Object.assign($A.prototype,{getValue:function(n,e){this.bind();const t=this._targetGroup.nCachedObjects_,i=this._bindings[t];i!==void 0&&i.getValue(n,e)},setValue:function(n,e){const t=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=t.length;i!==r;++i)t[i].setValue(n,e)},bind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()},unbind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}});function Yn(n,e,t){this.path=e,this.parsedPath=t||Yn.parseTrackName(e),this.node=Yn.findNode(n,this.parsedPath.nodeName)||n,this.rootNode=n}Object.assign(Yn,{Composite:$A,create:function(n,e,t){return n&&n.isAnimationObjectGroup?new Yn.Composite(n,e,t):new Yn(n,e,t)},sanitizeNodeName:function(n){return n.replace(/\s/g,"_").replace($Z,"")},parseTrackName:function(n){const e=HZ.exec(n);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=t.nodeName&&t.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=t.nodeName.substring(i+1);WZ.indexOf(r)!==-1&&(t.nodeName=t.nodeName.substring(0,i),t.objectName=r)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t},findNode:function(n,e){if(!e||e===""||e==="."||e===-1||e===n.name||e===n.uuid)return n;if(n.skeleton){const t=n.skeleton.getBoneByName(e);if(t!==void 0)return t}if(n.children){const t=function(r){for(let s=0;s<r.length;s++){const o=r[s];if(o.name===e||o.uuid===e)return o;const a=t(o.children);if(a)return a}return null},i=t(n.children);if(i)return i}return null}});Object.assign(Yn.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)e[t++]=i[r]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++]},function(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let n=this.node;const e=this.parsedPath,t=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(n||(n=Yn.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=n),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(t){let l=e.objectIndex;switch(t){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}n=n.skeleton.bones;for(let c=0;c<n.length;c++)if(n[c].name===l){l=c;break}break;default:if(n[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[t]}if(l!==void 0){if(n[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[l]}}const s=n[i];if(s===void 0){const l=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+i+" but it wasn't found.",n);return}let o=this.Versioning.None;this.targetObject=n,n.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:n.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(n.geometry.isBufferGeometry){if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}n.morphTargetDictionary[r]!==void 0&&(r=n.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else s.fromArray!==void 0&&s.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(Yn.prototype,{_getValue_unbound:Yn.prototype.getValue,_setValue_unbound:Yn.prototype.setValue});function BA(){this.uuid=Ze.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const n={};this._indicesByUUID=n;for(let t=0,i=arguments.length;t!==i;++t)n[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}Object.assign(BA.prototype,{isAnimationObjectGroup:!0,add:function(){const n=this._objects,e=this._indicesByUUID,t=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,a=n.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const h=arguments[c],d=h.uuid;let f=e[d];if(f===void 0){f=a++,e[d]=f,n.push(h);for(let p=0,m=s;p!==m;++p)r[p].push(new Yn(h,t[p],i[p]))}else if(f<l){o=n[f];const p=--l,m=n[p];e[m.uuid]=f,n[f]=m,e[d]=p,n[p]=h;for(let y=0,g=s;y!==g;++y){const v=r[y],_=v[p];let b=v[f];v[f]=_,b===void 0&&(b=new Yn(h,t[y],i[y])),v[p]=b}}else n[f]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,i=t.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const a=arguments[s],l=a.uuid,c=e[l];if(c!==void 0&&c>=r){const u=r++,h=n[u];e[h.uuid]=c,n[c]=h,e[l]=u,n[u]=a;for(let d=0,f=i;d!==f;++d){const p=t[d],m=p[u],y=p[c];p[c]=m,p[u]=y}}}this.nCachedObjects_=r},uncache:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,i=t.length;let r=this.nCachedObjects_,s=n.length;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=e[c];if(u!==void 0)if(delete e[c],u<r){const h=--r,d=n[h],f=--s,p=n[f];e[d.uuid]=u,n[u]=d,e[p.uuid]=h,n[h]=p,n.pop();for(let m=0,y=i;m!==y;++m){const g=t[m],v=g[h],_=g[f];g[u]=v,g[h]=_,g.pop()}}else{const h=--s,d=n[h];h>0&&(e[d.uuid]=u),n[u]=d,n.pop();for(let f=0,p=i;f!==p;++f){const m=t[f];m[u]=m[h],m.pop()}}}this.nCachedObjects_=r},subscribe_:function(n,e){const t=this._bindingsIndicesByPath;let i=t[n];const r=this._bindings;if(i!==void 0)return r[i];const s=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,u=new Array(l);i=r.length,t[n]=i,s.push(n),o.push(e),r.push(u);for(let h=c,d=a.length;h!==d;++h){const f=a[h];u[h]=new Yn(f,n,e)}return u},unsubscribe_:function(n){const e=this._bindingsIndicesByPath,t=e[n];if(t!==void 0){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o],l=n[o];e[l]=t,s[t]=a,s.pop(),r[t]=r[o],r.pop(),i[t]=i[o],i.pop()}}});class jZ{constructor(e,t,i=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=r;const s=t.tracks,o=s.length,a=new Array(o),l={endingStart:Bo,endingEnd:Bo};for(let c=0;c!==o;++c){const u=s[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=oA,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i){if(e.fadeOut(t),this.fadeIn(t),i){const r=this._clip.duration,s=e._clip.duration,o=s/r,a=r/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,i){return e.crossFadeFrom(this,t,i)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+i,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,i,r){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*i;if(l<0||i===0)return;this._startTime=null,t=i*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case rv:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case Hf:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const i=this._weightInterpolant;if(i!==null){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const i=this._timeScaleInterpolant;i!==null&&(t*=i.evaluate(e)[0],e>i.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,i=this.loop;let r=this.time+e,s=this._loopCount;const o=i===aA;if(e===0)return s===-1?r:o&&(s&1)===1?t-r:r;if(i===sA){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return t-r}return r}_setEndings(e,t,i){const r=this._interpolantSettings;i?(r.endingStart=zo,r.endingEnd=zo):(e?r.endingStart=this.zeroSlopeAtStart?zo:Bo:r.endingStart=eu,t?r.endingEnd=this.zeroSlopeAtEnd?zo:Bo:r.endingEnd=eu)}_scheduleFading(e,t,i){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=t,a[1]=s+e,l[1]=i,this}}function sy(n){this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}sy.prototype=Object.assign(Object.create(_s.prototype),{constructor:sy,_bindAction:function(n,e){const t=n._localRoot||this._root,i=n._clip.tracks,r=i.length,s=n._propertyBindings,o=n._interpolants,a=t.uuid,l=this._bindingsByRootAndName;let c=l[a];c===void 0&&(c={},l[a]=c);for(let u=0;u!==r;++u){const h=i[u],d=h.name;let f=c[d];if(f!==void 0)s[u]=f;else{if(f=s[u],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,a,d));continue}const p=e&&e._propertyBindings[u].binding.parsedPath;f=new _v(Yn.create(t,d,p),h.ValueTypeName,h.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,a,d),s[u]=f}o[u].resultBuffer=f.buffer}},_activateAction:function(n){if(!this._isActiveAction(n)){if(n._cacheIndex===null){const t=(n._localRoot||this._root).uuid,i=n._clip.uuid,r=this._actionsByClip[i];this._bindAction(n,r&&r.knownActions[0]),this._addInactiveAction(n,i,t)}const e=n._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const r=e[t];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(n)}},_deactivateAction:function(n){if(this._isActiveAction(n)){const e=n._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const r=e[t];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(n)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}},_isActiveAction:function(n){const e=n._cacheIndex;return e!==null&&e<this._nActiveActions},_addInactiveAction:function(n,e,t){const i=this._actions,r=this._actionsByClip;let s=r[e];if(s===void 0)s={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,r[e]=s;else{const o=s.knownActions;n._byClipCacheIndex=o.length,o.push(n)}n._cacheIndex=i.length,i.push(n),s.actionByRoot[t]=n},_removeInactiveAction:function(n){const e=this._actions,t=e[e.length-1],i=n._cacheIndex;t._cacheIndex=i,e[i]=t,e.pop(),n._cacheIndex=null;const r=n._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=n._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),n._byClipCacheIndex=null;const u=o.actionByRoot,h=(n._localRoot||this._root).uuid;delete u[h],a.length===0&&delete s[r],this._removeInactiveBindingsForAction(n)},_removeInactiveBindingsForAction:function(n){const e=n._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const r=e[t];--r.referenceCount===0&&this._removeInactiveBinding(r)}},_lendAction:function(n){const e=this._actions,t=n._cacheIndex,i=this._nActiveActions++,r=e[i];n._cacheIndex=i,e[i]=n,r._cacheIndex=t,e[t]=r},_takeBackAction:function(n){const e=this._actions,t=n._cacheIndex,i=--this._nActiveActions,r=e[i];n._cacheIndex=i,e[i]=n,r._cacheIndex=t,e[t]=r},_addInactiveBinding:function(n,e,t){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];s===void 0&&(s={},i[e]=s),s[t]=n,n._cacheIndex=r.length,r.push(n)},_removeInactiveBinding:function(n){const e=this._bindings,t=n.binding,i=t.rootNode.uuid,r=t.path,s=this._bindingsByRootAndName,o=s[i],a=e[e.length-1],l=n._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[r],Object.keys(o).length===0&&delete s[i]},_lendBinding:function(n){const e=this._bindings,t=n._cacheIndex,i=this._nActiveBindings++,r=e[i];n._cacheIndex=i,e[i]=n,r._cacheIndex=t,e[t]=r},_takeBackBinding:function(n){const e=this._bindings,t=n._cacheIndex,i=--this._nActiveBindings,r=e[i];n._cacheIndex=i,e[i]=n,r._cacheIndex=t,e[t]=r},_lendControlInterpolant:function(){const n=this._controlInterpolants,e=this._nActiveControlInterpolants++;let t=n[e];return t===void 0&&(t=new wu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),t.__cacheIndex=e,n[e]=t),t},_takeBackControlInterpolant:function(n){const e=this._controlInterpolants,t=n.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];n.__cacheIndex=i,e[i]=n,r.__cacheIndex=t,e[t]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(n,e,t){const i=e||this._root,r=i.uuid;let s=typeof n=="string"?Si.findByName(i,n):n;const o=s!==null?s.uuid:n,a=this._actionsByClip[o];let l=null;if(t===void 0&&(s!==null?t=s.blendMode:t=Hf),a!==void 0){const u=a.actionByRoot[r];if(u!==void 0&&u.blendMode===t)return u;l=a.knownActions[0],s===null&&(s=l._clip)}if(s===null)return null;const c=new jZ(this,s,e,t);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c},existingAction:function(n,e){const t=e||this._root,i=t.uuid,r=typeof n=="string"?Si.findByName(t,n):n,s=r?r.uuid:n,o=this._actionsByClip[s];return o!==void 0&&o.actionByRoot[i]||null},stopAllAction:function(){const n=this._actions,e=this._nActiveActions;for(let t=e-1;t>=0;--t)n[t].stop();return this},update:function(n){n*=this.timeScale;const e=this._actions,t=this._nActiveActions,i=this.time+=n,r=Math.sign(n),s=this._accuIndex^=1;for(let l=0;l!==t;++l)e[l]._update(i,n,r,s);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(s);return this},setTime:function(n){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)},getRoot:function(){return this._root},uncacheClip:function(n){const e=this._actions,t=n.uuid,i=this._actionsByClip,r=i[t];if(r!==void 0){const s=r.knownActions;for(let o=0,a=s.length;o!==a;++o){const l=s[o];this._deactivateAction(l);const c=l._cacheIndex,u=e[e.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,u._cacheIndex=c,e[c]=u,e.pop(),this._removeInactiveBindingsForAction(l)}delete i[t]}},uncacheRoot:function(n){const e=n.uuid,t=this._actionsByClip;for(const s in t){const o=t[s].actionByRoot,a=o[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const i=this._bindingsByRootAndName,r=i[e];if(r!==void 0)for(const s in r){const o=r[s];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(n,e){const t=this.existingAction(n,e);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}});class Kf{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Kf(this.value.clone===void 0?this.value:this.value.clone())}}function oy(n,e,t){Ci.call(this,n,e),this.meshPerAttribute=t||1}oy.prototype=Object.assign(Object.create(Ci.prototype),{constructor:oy,isInstancedInterleavedBuffer:!0,copy:function(n){return Ci.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},clone:function(n){const e=Ci.prototype.clone.call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(n){const e=Ci.prototype.toJSON.call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}});function Sv(n,e,t,i,r){this.buffer=n,this.type=e,this.itemSize=t,this.elementSize=i,this.count=r,this.version=0}Object.defineProperty(Sv.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Sv.prototype,{isGLBufferAttribute:!0,setBuffer:function(n){return this.buffer=n,this},setType:function(n,e){return this.type=n,this.elementSize=e,this},setItemSize:function(n){return this.itemSize=n,this},setCount:function(n){return this.count=n,this}});function Tv(n,e,t,i){this.ray=new Jl(n,e),this.near=t||0,this.far=i||1/0,this.camera=null,this.layers=new lv,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function j_(n,e){return n.distance-e.distance}function ay(n,e,t,i){if(n.layers.test(e.layers)&&n.raycast(e,t),i===!0){const r=n.children;for(let s=0,o=r.length;s<o;s++)ay(r[s],e,t,!0)}}Object.assign(Tv.prototype,{set:function(n,e){this.ray.set(n,e)},setFromCamera:function(n,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(n,e,t){const i=t||[];return ay(n,this,i,e),i.sort(j_),i},intersectObjects:function(n,e,t){const i=t||[];if(Array.isArray(n)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let r=0,s=n.length;r<s;r++)ay(n[r],this,i,e);return i.sort(j_),i}});class qZ{constructor(e=1,t=0,i=0){return this.radius=e,this.phi=t,this.theta=i,this}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(Ze.clamp(t/this.radius,-1,1))),this}}class XZ{constructor(e,t,i){return this.radius=e!==void 0?e:1,this.theta=t!==void 0?t:0,this.y=i!==void 0?i:0,this}set(e,t,i){return this.radius=e,this.theta=t,this.y=i,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+i*i),this.theta=Math.atan2(e,i),this.y=t,this}}const q_=new fe;class zA{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=e!==void 0?e:new fe(1/0,1/0),this.max=t!==void 0?t:new fe(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=q_.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new fe),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new fe),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new fe),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new fe),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return q_.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const X_=new k,Hh=new k;class UA{constructor(e,t){this.start=e!==void 0?e:new k,this.end=t!==void 0?t:new k}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new k),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new k),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new k),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){X_.subVectors(e,this.start),Hh.subVectors(this.end,this.start);const i=Hh.dot(Hh);let s=Hh.dot(X_)/i;return t&&(s=Ze.clamp(s,0,1)),s}closestPointToPoint(e,t,i){const r=this.closestPointToPointParameter(e,t);return i===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),i=new k),this.delta(i).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function Eu(n){ze.call(this),this.material=n,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Eu.prototype=Object.create(ze.prototype);Eu.prototype.constructor=Eu;Eu.prototype.isImmediateRenderObject=!0;const Y_=new k;class YZ extends ze{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const i=new He,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;r.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}i.setAttribute("position",new Le(r,3));const s=new Zt({fog:!1,toneMapped:!1});this.cone=new oi(i,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Y_.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Y_),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Ns=new k,Wh=new ut,rm=new ut;class VA extends oi{constructor(e){const t=GA(e),i=new He,r=[],s=[],o=new Ne(0,0,1),a=new Ne(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}i.setAttribute("position",new Le(r,3)),i.setAttribute("color",new Le(s,3));const l=new Zt({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,i=this.geometry,r=i.getAttribute("position");rm.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(Wh.multiplyMatrices(rm,a.matrixWorld),Ns.setFromMatrixPosition(Wh),r.setXYZ(o,Ns.x,Ns.y,Ns.z),Wh.multiplyMatrices(rm,a.parent.matrixWorld),Ns.setFromMatrixPosition(Wh),r.setXYZ(o+1,Ns.x,Ns.y,Ns.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function GA(n){const e=[];n&&n.isBone&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,GA(n.children[t]));return e}class KZ extends jt{constructor(e,t,i){const r=new bu(t,4,2),s=new Ri({wireframe:!0,fog:!1,toneMapped:!1});super(r,s),this.light=e,this.light.updateMatrixWorld(),this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const ZZ=new k,K_=new Ne,Z_=new Ne;class JZ extends ze{constructor(e,t,i){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i;const r=new xu(t);r.rotateY(Math.PI*.5),this.material=new Ri({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=r.getAttribute("position"),o=new Float32Array(s.count*3);r.setAttribute("color",new Xe(o,3)),this.add(new jt(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");K_.copy(this.light.color),Z_.copy(this.light.groundColor);for(let i=0,r=t.count;i<r;i++){const s=i<r/2?K_:Z_;t.setXYZ(i,s.r,s.g,s.b)}t.needsUpdate=!0}e.lookAt(ZZ.setFromMatrixPosition(this.light.matrixWorld).negate())}}class HA extends oi{constructor(e=10,t=10,i=4473924,r=8947848){i=new Ne(i),r=new Ne(r);const s=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,f=0,p=-a;d<=t;d++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const m=d===s?i:r;m.toArray(c,f),f+=3,m.toArray(c,f),f+=3,m.toArray(c,f),f+=3,m.toArray(c,f),f+=3}const u=new He;u.setAttribute("position",new Le(l,3)),u.setAttribute("color",new Le(c,3));const h=new Zt({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}class QZ extends oi{constructor(e=10,t=16,i=8,r=64,s=4473924,o=8947848){s=new Ne(s),o=new Ne(o);const a=[],l=[];for(let h=0;h<=t;h++){const d=h/t*(Math.PI*2),f=Math.sin(d)*e,p=Math.cos(d)*e;a.push(0,0,0),a.push(f,0,p);const m=h&1?s:o;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=i;h++){const d=h&1?s:o,f=e-e/i*h;for(let p=0;p<r;p++){let m=p/r*(Math.PI*2),y=Math.sin(m)*f,g=Math.cos(m)*f;a.push(y,0,g),l.push(d.r,d.g,d.b),m=(p+1)/r*(Math.PI*2),y=Math.sin(m)*f,g=Math.cos(m)*f,a.push(y,0,g),l.push(d.r,d.g,d.b)}}const c=new He;c.setAttribute("position",new Le(a,3)),c.setAttribute("color",new Le(l,3));const u=new Zt({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}}const J_=new k,jh=new k,Q_=new k;class eJ extends ze{constructor(e,t,i){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,t===void 0&&(t=1);let r=new He;r.setAttribute("position",new Le([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new Zt({fog:!1,toneMapped:!1});this.lightPlane=new Zi(r,s),this.add(this.lightPlane),r=new He,r.setAttribute("position",new Le([0,0,0,0,0,1],3)),this.targetLine=new Zi(r,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){J_.setFromMatrixPosition(this.light.matrixWorld),jh.setFromMatrixPosition(this.light.target.matrixWorld),Q_.subVectors(jh,J_),this.lightPlane.lookAt(jh),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(jh),this.targetLine.scale.z=Q_.length()}}const qh=new k,nn=new Gr;class tJ extends oi{constructor(e){const t=new He,i=new Zt({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],s=[],o={},a=new Ne(16755200),l=new Ne(16711680),c=new Ne(43775),u=new Ne(16777215),h=new Ne(3355443);d("n1","n2",a),d("n2","n4",a),d("n4","n3",a),d("n3","n1",a),d("f1","f2",a),d("f2","f4",a),d("f4","f3",a),d("f3","f1",a),d("n1","f1",a),d("n2","f2",a),d("n3","f3",a),d("n4","f4",a),d("p","n1",l),d("p","n2",l),d("p","n3",l),d("p","n4",l),d("u1","u2",c),d("u2","u3",c),d("u3","u1",c),d("c","t",u),d("p","c",h),d("cn1","cn2",h),d("cn3","cn4",h),d("cf1","cf2",h),d("cf3","cf4",h);function d(p,m,y){f(p,y),f(m,y)}function f(p,m){r.push(0,0,0),s.push(m.r,m.g,m.b),o[p]===void 0&&(o[p]=[]),o[p].push(r.length/3-1)}t.setAttribute("position",new Le(r,3)),t.setAttribute("color",new Le(s,3)),super(t,i),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const e=this.geometry,t=this.pointMap,i=1,r=1;nn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),sn("c",t,e,nn,0,0,-1),sn("t",t,e,nn,0,0,1),sn("n1",t,e,nn,-i,-r,-1),sn("n2",t,e,nn,i,-r,-1),sn("n3",t,e,nn,-i,r,-1),sn("n4",t,e,nn,i,r,-1),sn("f1",t,e,nn,-i,-r,1),sn("f2",t,e,nn,i,-r,1),sn("f3",t,e,nn,-i,r,1),sn("f4",t,e,nn,i,r,1),sn("u1",t,e,nn,i*.7,r*1.1,-1),sn("u2",t,e,nn,-i*.7,r*1.1,-1),sn("u3",t,e,nn,0,r*2,-1),sn("cf1",t,e,nn,-i,0,1),sn("cf2",t,e,nn,i,0,1),sn("cf3",t,e,nn,0,-r,1),sn("cf4",t,e,nn,0,r,1),sn("cn1",t,e,nn,-i,0,-1),sn("cn2",t,e,nn,i,0,-1),sn("cn3",t,e,nn,0,-r,-1),sn("cn4",t,e,nn,0,r,-1),e.getAttribute("position").needsUpdate=!0}}function sn(n,e,t,i,r,s,o){qh.set(r,s,o).unproject(i);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],qh.x,qh.y,qh.z)}}const Xh=new bs;class WA extends oi{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),s=new He;s.setIndex(new Xe(i,1)),s.setAttribute("position",new Xe(r,3)),super(s,new Zt({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Xh.setFromObject(this.object),Xh.isEmpty())return;const t=Xh.min,i=Xh.max,r=this.geometry.attributes.position,s=r.array;s[0]=i.x,s[1]=i.y,s[2]=i.z,s[3]=t.x,s[4]=i.y,s[5]=i.z,s[6]=t.x,s[7]=t.y,s[8]=i.z,s[9]=i.x,s[10]=t.y,s[11]=i.z,s[12]=i.x,s[13]=i.y,s[14]=t.z,s[15]=t.x,s[16]=i.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=i.x,s[22]=t.y,s[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return oi.prototype.copy.call(this,e),this.object=e.object,this}}class nJ extends oi{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new He;s.setIndex(new Xe(i,1)),s.setAttribute("position",new Le(r,3)),super(s,new Zt({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class iJ extends Zi{constructor(e,t=1,i=16776960){const r=i,s=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],o=new He;o.setAttribute("position",new Le(s,3)),o.computeBoundingSphere(),super(o,new Zt({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new He;l.setAttribute("position",new Le(a,3)),l.computeBoundingSphere(),this.add(new jt(l,new Ri({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?un:Xl,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const eb=new k;let Yh,sm;class rJ extends ze{constructor(e,t,i,r,s,o){super(),this.type="ArrowHelper",e===void 0&&(e=new k(0,0,1)),t===void 0&&(t=new k(0,0,0)),i===void 0&&(i=1),r===void 0&&(r=16776960),s===void 0&&(s=.2*i),o===void 0&&(o=.2*s),Yh===void 0&&(Yh=new He,Yh.setAttribute("position",new Le([0,0,0,0,1,0],3)),sm=new Rl(0,.5,1,5,1),sm.translate(0,-.5,0)),this.position.copy(t),this.line=new Zi(Yh,new Zt({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new jt(sm,new Ri({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(i,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{eb.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(eb,t)}}setLength(e,t,i){t===void 0&&(t=.2*e),i===void 0&&(i=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(i,t,i),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class jA extends oi{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new He;r.setAttribute("position",new Le(t,3)),r.setAttribute("color",new Le(i,3));const s=new Zt({vertexColors:!0,toneMapped:!1});super(r,s),this.type="AxesHelper"}}const qA=new Float32Array(1),sJ=new Int32Array(qA.buffer),oJ={toHalfFloat:function(n){qA[0]=n;const e=sJ[0];let t=e>>16&32768,i=e>>12&2047;const r=e>>23&255;return r<103?t:r>142?(t|=31744,t|=(r==255?0:1)&&e&8388607,t):r<113?(i|=2048,t|=(i>>114-r)+(i>>113-r&1),t):(t|=r-112<<10|i>>1,t+=i&1,t)}},dl=4,Ks=8,Or=Math.pow(2,Ks),XA=[.125,.215,.35,.446,.526,.582],YA=Ks-dl+1+XA.length,ja=20,Br={[ri]:0,[Gu]:1,[jf]:2,[sv]:3,[ov]:4,[av]:5,[Wf]:6},Ro=new Ri({side:un,depthWrite:!1,depthTest:!1}),aJ=new jt(new ra,Ro),om=new Dl,{_lodPlanes:vc,_sizeLods:tb,_sigmas:Kh}=uJ(),nb=new Ne;let am=null;const Io=(1+Math.sqrt(5))/2,qa=1/Io,ib=[new k(1,1,1),new k(-1,1,1),new k(1,1,-1),new k(-1,1,-1),new k(0,Io,qa),new k(0,Io,-qa),new k(qa,0,Io),new k(-qa,0,Io),new k(Io,qa,0),new k(-Io,qa,0)];function rb(n){const e=Math.max(n.r,n.g,n.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return n.multiplyScalar(Math.pow(2,-t)),(t+128)/255}class lJ{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=hJ(ja),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100){am=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(e,i,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=ab(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=ob(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<vc.length;e++)vc[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(am),e.scissorTest=!1,Zh(e,0,0,e.width,e.height)}_fromTexture(e){am=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:bn,minFilter:bn,generateMipmaps:!1,type:Zl,format:w2,encoding:cJ(e)?e.encoding:jf,depthBuffer:!1},i=sb(t);return i.depthBuffer=!e,this._pingPongRenderTarget=sb(t),i}_compileMaterial(e){const t=new jt(vc[0],e);this._renderer.compile(t,om)}_sceneToCubeUV(e,t,i,r){const a=new fn(90,1,t,i),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.outputEncoding,f=u.toneMapping;u.getClearColor(nb),u.toneMapping=qo,u.outputEncoding=ri,u.autoClear=!1;let p=!1;const m=e.background;if(m){if(m.isColor){Ro.color.copy(m).convertSRGBToLinear(),e.background=null;const y=rb(Ro.color);Ro.opacity=y,p=!0}}else{Ro.color.copy(nb).convertSRGBToLinear();const y=rb(Ro.color);Ro.opacity=y,p=!0}for(let y=0;y<6;y++){const g=y%3;g==0?(a.up.set(0,l[y],0),a.lookAt(c[y],0,0)):g==1?(a.up.set(0,0,l[y]),a.lookAt(0,c[y],0)):(a.up.set(0,l[y],0),a.lookAt(0,0,c[y])),Zh(r,g*Or,y>2?Or:0,Or,Or),u.setRenderTarget(r),p&&u.render(aJ,a),u.render(e,a)}u.toneMapping=f,u.outputEncoding=d,u.autoClear=h}_textureToCubeUV(e,t){const i=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=ab()):this._equirectShader==null&&(this._equirectShader=ob());const r=e.isCubeTexture?this._cubemapShader:this._equirectShader,s=new jt(vc[0],r),o=r.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=Br[e.encoding],o.outputEncoding.value=Br[t.texture.encoding],Zh(t,0,0,3*Or,2*Or),i.setRenderTarget(t),i.render(s,om)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let r=1;r<YA;r++){const s=Math.sqrt(Kh[r]*Kh[r]-Kh[r-1]*Kh[r-1]),o=ib[(r-1)%ib.length];this._blur(e,r-1,r,s,o)}t.autoClear=i}_blur(e,t,i,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,r,"latitudinal",s),this._halfBlur(o,e,i,i,r,"longitudinal",s)}_halfBlur(e,t,i,r,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new jt(vc[r],c),d=c.uniforms,f=tb[i]-1,p=isFinite(s)?Math.PI/(2*f):2*Math.PI/(2*ja-1),m=s/p,y=isFinite(s)?1+Math.floor(u*m):ja;y>ja&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${ja}`);const g=[];let v=0;for(let w=0;w<ja;++w){const T=w/m,R=Math.exp(-T*T/2);g.push(R),w==0?v+=R:w<y&&(v+=2*R)}for(let w=0;w<g.length;w++)g[w]=g[w]/v;d.envMap.value=e.texture,d.samples.value=y,d.weights.value=g,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a),d.dTheta.value=p,d.mipInt.value=Ks-i,d.inputEncoding.value=Br[e.texture.encoding],d.outputEncoding.value=Br[e.texture.encoding];const _=tb[r],b=3*Math.max(0,Or-2*_),S=(r===0?0:2*Or)+2*_*(r>Ks-dl?r-Ks+dl:0);Zh(t,b,S,3*_,2*_),l.setRenderTarget(t),l.render(h,om)}}function cJ(n){return n===void 0||n.type!==Zl?!1:n.encoding===ri||n.encoding===Gu||n.encoding===Wf}function uJ(){const n=[],e=[],t=[];let i=Ks;for(let r=0;r<YA;r++){const s=Math.pow(2,i);e.push(s);let o=1/s;r>Ks-dl?o=XA[r-Ks+dl-1]:r==0&&(o=0),t.push(o);const a=1/(s-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,d=6,f=3,p=2,m=1,y=new Float32Array(f*d*h),g=new Float32Array(p*d*h),v=new Float32Array(m*d*h);for(let b=0;b<h;b++){const S=b%3*2/3-1,w=b>2?0:-1,T=[S,w,0,S+2/3,w,0,S+2/3,w+1,0,S,w,0,S+2/3,w+1,0,S,w+1,0];y.set(T,f*d*b),g.set(u,p*d*b);const R=[b,b,b,b,b,b];v.set(R,m*d*b)}const _=new He;_.setAttribute("position",new Xe(y,f)),_.setAttribute("uv",new Xe(g,p)),_.setAttribute("faceIndex",new Xe(v,m)),n.push(_),i>dl&&i--}return{_lodPlanes:n,_sizeLods:e,_sigmas:t}}function sb(n){const e=new qs(3*Or,3*Or,n);return e.texture.mapping=Yl,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function Zh(n,e,t,i,r){n.viewport.set(e,t,i,r),n.scissor.set(e,t,i,r)}function hJ(n){const e=new Float32Array(n),t=new k(0,1,0);return new gs({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Br[ri]},outputEncoding:{value:Br[ri]}},vertexShader:Ev(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Cv()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:hs,depthTest:!1,depthWrite:!1})}function ob(){const n=new fe(1,1);return new gs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:Br[ri]},outputEncoding:{value:Br[ri]}},vertexShader:Ev(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Cv()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:hs,depthTest:!1,depthWrite:!1})}function ab(){return new gs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Br[ri]},outputEncoding:{value:Br[ri]}},vertexShader:Ev(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Cv()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:hs,depthTest:!1,depthWrite:!1})}function Ev(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Cv(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function dJ(n,e,t,i,r,s,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new cv(n,e,t,r,s,o)}const fJ=0,pJ=1,mJ=0,gJ=1,yJ=2;function vJ(n){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),n}function xJ(n=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),n.isMultiMaterial=!0,n.materials=n,n.clone=function(){return n.slice()},n}function _J(n,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new Ml(n,e)}function bJ(n){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new cu(n)}function wJ(n,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new Ml(n,e)}function SJ(n){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Tr(n)}function TJ(n){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Tr(n)}function EJ(n){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Tr(n)}function CJ(n,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new k(n,e,t)}function MJ(n,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Xe(n,e).setUsage(ta)}function AJ(n,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new tu(n,e)}function RJ(n,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new nu(n,e)}function IJ(n,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new iu(n,e)}function PJ(n,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new ru(n,e)}function NJ(n,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new na(n,e)}function LJ(n,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new su(n,e)}function DJ(n,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new ia(n,e)}function kJ(n,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Le(n,e)}function OJ(n,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new au(n,e)}Ue.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(Ue.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};Object.assign(_r.prototype,{fromPoints:function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)}});function KA(n){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Kn.call(this,n),this.type="catmullrom",this.closed=!0}KA.prototype=Object.create(Kn.prototype);function ZA(n){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Kn.call(this,n),this.type="catmullrom"}ZA.prototype=Object.create(Kn.prototype);function Mv(n){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),Kn.call(this,n),this.type="catmullrom"}Mv.prototype=Object.create(Kn.prototype);Object.assign(Mv.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});function FJ(n){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new jA(n)}function $J(n,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new WA(n,e)}function BJ(n,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new oi(new dv(n.geometry),new Zt({color:e!==void 0?e:16777215}))}HA.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};VA.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function zJ(n,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new oi(new fv(n.geometry),new Zt({color:e!==void 0?e:16777215}))}Object.assign(Pt.prototype,{extractUrlBase:function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),gv.extractUrlBase(n)}});Pt.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function UJ(n){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Ji(n)}function VJ(n){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new lf(n)}Object.assign(zA.prototype,{center:function(n){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},size:function(n){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(bs.prototype,{center:function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionSphere:function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)},size:function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(go.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}});Wu.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};UA.prototype.center=function(n){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Object.assign(Ze,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(n){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),Ze.floorPowerOfTwo(n)},nextPowerOfTwo:function(n){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),Ze.ceilPowerOfTwo(n)}});Object.assign(Ei.prototype,{flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},multiplyVector3:function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});Object.assign(ut.prototype,{extractPosition:function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)},flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new k().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector4:function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)},crossVector:function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(n,e,t,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,i,t,r,s)},getInverse:function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});$r.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Object.assign(Xn.prototype,{multiplyVector3:function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}});Object.assign(Jl.prototype,{isIntersectionBox:function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionPlane:function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)},isIntersectionSphere:function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)}});Object.assign(qn.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)},midpoint:function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)},normal:function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)},plane:function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)}});Object.assign(qn,{barycoordFromPoint:function(n,e,t,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),qn.getBarycoord(n,e,t,i,r)},normal:function(n,e,t,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),qn.getNormal(n,e,t,i)}});Object.assign(Ys.prototype,{extractAllPoints:function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)},extrude:function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new oa(this,n)},makeGeometry:function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new _u(this,n)}});Object.assign(fe.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(k.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)},getScaleFromMatrix:function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)},getColumnFromMatrix:function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)},applyProjection:function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)},fromAttribute:function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(kt.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(ze.prototype,{getChildByName:function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(ze.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.assign(jt.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}});Object.defineProperties(jt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),lA},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Object.defineProperties(uu.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}});Object.defineProperty(fu.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});hu.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(Ue.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(n){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=n}});fn.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(qt.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(Xe.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===ta},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(ta)}}});Object.assign(Xe.prototype,{setDynamic:function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?ta:Hu),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(He.prototype,{addIndex:function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)},addAttribute:function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new Xe(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)},addDrawCall:function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)},applyMatrix:function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(He.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(Tu.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(n){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=n}}});Object.defineProperties(Tv.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(n){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=n}}});Object.defineProperties(Ci.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===ta},set:function(n){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(n)}}});Object.assign(Ci.prototype,{setDynamic:function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?ta:Hu),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(oa.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}});Object.assign(hv.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}});Object.defineProperties(Kf.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}});Object.defineProperties(Ye.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ne}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===ev}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}}});Object.defineProperties(uo.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(co.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(n){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=n}}});Object.defineProperties(si.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Object.assign(ju.prototype,{clearTarget:function(n,e,t,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,i)},animate:function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}});Object.defineProperties(ju.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?Gu:ri}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(EA.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function GJ(n,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new uv(n,t)}Object.defineProperties(qs.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});Object.defineProperties(xv.prototype,{load:{value:function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new xf().load(n,function(i){e.setBuffer(i)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}});FA.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};sa.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};sa.prototype.clear=function(n,e,t,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,i)};const HJ={merge:function(n,e,t){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");let i;e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),i=e.matrix,e=e.geometry),n.merge(e,i,t)},center:function(n){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),n.center()}};Sa.crossOrigin=void 0;Sa.loadTexture=function(n,e,t,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new cf;r.setCrossOrigin(this.crossOrigin);const s=r.load(n,t,void 0,i);return e&&(s.mapping=e),s};Sa.loadTextureCube=function(n,e,t,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new af;r.setCrossOrigin(this.crossOrigin);const s=r.load(n,t,void 0,i);return e&&(s.mapping=e),s};Sa.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Sa.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function WJ(){console.error("THREE.CanvasRenderer has been removed")}function jJ(){console.error("THREE.JSONLoader has been removed.")}const qJ={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function XJ(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Jy}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Jy);var YJ=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:h2,AddEquation:Lo,AddOperation:a2,AdditiveAnimationBlendMode:rv,AdditiveBlending:Mg,AlphaFormat:x2,AlwaysDepth:e2,AlwaysStencilFunc:fA,AmbientLight:pf,AmbientLightProbe:ry,AnimationClip:Si,AnimationLoader:Yg,AnimationMixer:sy,AnimationObjectGroup:BA,AnimationUtils:Kt,ArcCurve:Ll,ArrayCamera:zd,ArrowHelper:rJ,Audio:xv,AudioAnalyser:FA,AudioContext:vv,AudioListener:kZ,AudioLoader:xf,AxesHelper:jA,AxisHelper:FJ,BackSide:un,BasicDepthPacking:uA,BasicShadowMap:lX,BinaryTextureLoader:VJ,Bone:du,BooleanKeyframeTrack:nf,BoundingBoxHelper:$J,Box2:zA,Box3:bs,Box3Helper:nJ,BoxBufferGeometry:ra,BoxGeometry:ra,BoxHelper:WA,BufferAttribute:Xe,BufferGeometry:He,BufferGeometryLoader:vf,ByteType:f2,Cache:pa,Camera:Gr,CameraHelper:tJ,CanvasRenderer:WJ,CanvasTexture:pu,CatmullRomCurve3:Kn,CineonToneMapping:u2,CircleBufferGeometry:Gd,CircleGeometry:Gd,ClampToEdgeWrapping:ii,Clock:OA,ClosedSplineCurve3:KA,Color:Ne,ColorKeyframeTrack:rf,CompressedTexture:Al,CompressedTextureLoader:Kg,ConeBufferGeometry:Hd,ConeGeometry:Hd,CubeCamera:sa,CubeReflectionMapping:zu,CubeRefractionMapping:Uu,CubeTexture:Hr,CubeTextureLoader:af,CubeUVReflectionMapping:Yl,CubeUVRefractionMapping:Vu,CubicBezierCurve:Er,CubicBezierCurve3:jr,CubicInterpolant:ef,CullFaceBack:Cg,CullFaceFront:BM,CullFaceFrontBack:aX,CullFaceNone:$M,Curve:Ue,CurvePath:Gs,CustomBlending:UM,CustomToneMapping:d2,CylinderBufferGeometry:Rl,CylinderGeometry:Rl,Cylindrical:XZ,DataTexture:ms,DataTexture2DArray:El,DataTexture3D:Cl,DataTextureLoader:lf,DataUtils:oJ,DecrementStencilOp:xX,DecrementWrapStencilOp:bX,DefaultLoadingManager:NA,DepthFormat:Xo,DepthStencilFormat:Sl,DepthTexture:mu,DirectionalLight:ff,DirectionalLightHelper:eJ,DiscreteInterpolant:tf,DodecahedronBufferGeometry:Wd,DodecahedronGeometry:Wd,DoubleSide:$u,DstAlphaFactor:XM,DstColorFactor:KM,DynamicBufferAttribute:MJ,DynamicCopyUsage:kX,DynamicDrawUsage:ta,DynamicReadUsage:NX,EdgesGeometry:dv,EdgesHelper:BJ,EllipseCurve:Pi,EqualDepth:n2,EqualStencilFunc:EX,EquirectangularReflectionMapping:Od,EquirectangularRefractionMapping:Fd,Euler:Ql,EventDispatcher:_s,ExtrudeBufferGeometry:oa,ExtrudeGeometry:oa,Face3:cv,Face4:dJ,FaceColors:gJ,FileLoader:Ji,FlatShading:ev,Float16BufferAttribute:ou,Float32Attribute:kJ,Float32BufferAttribute:Le,Float64Attribute:OJ,Float64BufferAttribute:au,FloatType:ls,Fog:Xf,FogExp2:qf,Font:DA,FontLoader:ny,FrontSide:Xl,Frustum:Wu,GLBufferAttribute:Sv,GLSL1:FX,GLSL3:Vg,GammaEncoding:Wf,GeometryUtils:HJ,GreaterDepth:r2,GreaterEqualDepth:i2,GreaterEqualStencilFunc:RX,GreaterStencilFunc:MX,GridHelper:HA,Group:Vs,HalfFloatType:Jc,HemisphereLight:uf,HemisphereLightHelper:JZ,HemisphereLightProbe:iy,IcosahedronBufferGeometry:jd,IcosahedronGeometry:jd,ImageBitmapLoader:ty,ImageLoader:Nl,ImageUtils:Sa,ImmediateRenderObject:Eu,IncrementStencilOp:vX,IncrementWrapStencilOp:_X,InstancedBufferAttribute:yf,InstancedBufferGeometry:Tu,InstancedInterleavedBuffer:oy,InstancedMesh:Ud,Int16Attribute:PJ,Int16BufferAttribute:ru,Int32Attribute:LJ,Int32BufferAttribute:su,Int8Attribute:AJ,Int8BufferAttribute:tu,IntType:m2,InterleavedBuffer:Ci,InterleavedBufferAttribute:so,Interpolant:Ai,InterpolateDiscrete:Qc,InterpolateLinear:Pc,InterpolateSmooth:yd,InvertStencilOp:wX,JSONLoader:jJ,KeepStencilOp:vd,KeyframeTrack:On,LOD:uu,LatheBufferGeometry:qd,LatheGeometry:qd,Layers:lv,LensFlare:XJ,LessDepth:t2,LessEqualDepth:kd,LessEqualStencilFunc:CX,LessStencilFunc:TX,Light:qt,LightProbe:Xi,Line:Zi,Line3:UA,LineBasicMaterial:Zt,LineCurve:mi,LineCurve3:Cr,LineDashedMaterial:fa,LineLoop:Vd,LinePieces:pJ,LineSegments:oi,LineStrip:fJ,LinearEncoding:ri,LinearFilter:Cn,LinearInterpolant:wu,LinearMipMapLinearFilter:fX,LinearMipMapNearestFilter:dX,LinearMipmapLinearFilter:Kl,LinearMipmapNearestFilter:iv,LinearToneMapping:l2,Loader:Pt,LoaderUtils:gv,LoadingManager:pv,LogLuvEncoding:cA,LoopOnce:sA,LoopPingPong:aA,LoopRepeat:oA,LuminanceAlphaFormat:b2,LuminanceFormat:_2,MOUSE:sX,Material:Ye,MaterialLoader:gf,Math:Ze,MathUtils:Ze,Matrix3:Ei,Matrix4:ut,MaxEquation:Pg,Mesh:jt,MeshBasicMaterial:Ri,MeshDepthMaterial:io,MeshDistanceMaterial:ro,MeshFaceMaterial:vJ,MeshLambertMaterial:ha,MeshMatcapMaterial:da,MeshNormalMaterial:ua,MeshPhongMaterial:uo,MeshPhysicalMaterial:co,MeshStandardMaterial:Wr,MeshToonMaterial:ca,MinEquation:Ig,MirroredRepeatWrapping:Kc,MixOperation:o2,MultiMaterial:xJ,MultiplyBlending:Rg,MultiplyOperation:Bu,NearestFilter:bn,NearestMipMapLinearFilter:hX,NearestMipMapNearestFilter:uX,NearestMipmapLinearFilter:Bd,NearestMipmapNearestFilter:$d,NeverDepth:QM,NeverStencilFunc:SX,NoBlending:hs,NoColors:mJ,NoToneMapping:qo,NormalAnimationBlendMode:Hf,NormalBlending:ul,NotEqualDepth:s2,NotEqualStencilFunc:AX,NumberKeyframeTrack:Il,Object3D:ze,ObjectLoader:IZ,ObjectSpaceNormalMap:dA,OctahedronBufferGeometry:xu,OctahedronGeometry:xu,OneFactor:WM,OneMinusDstAlphaFactor:YM,OneMinusDstColorFactor:ZM,OneMinusSrcAlphaFactor:nv,OneMinusSrcColorFactor:qM,OrthographicCamera:Dl,PCFShadowMap:Qy,PCFSoftShadowMap:zM,PMREMGenerator:lJ,ParametricBufferGeometry:aa,ParametricGeometry:aa,Particle:bJ,ParticleBasicMaterial:TJ,ParticleSystem:wJ,ParticleSystemMaterial:EJ,Path:_r,PerspectiveCamera:fn,Plane:$r,PlaneBufferGeometry:lu,PlaneGeometry:lu,PlaneHelper:iJ,PointCloud:_J,PointCloudMaterial:SJ,PointLight:df,PointLightHelper:KZ,Points:Ml,PointsMaterial:Tr,PolarGridHelper:QZ,PolyhedronBufferGeometry:ao,PolyhedronGeometry:ao,PositionalAudio:FZ,PropertyBinding:Yn,PropertyMixer:_v,QuadraticBezierCurve:Mr,QuadraticBezierCurve3:qr,Quaternion:Xn,QuaternionKeyframeTrack:Su,QuaternionLinearInterpolant:sf,REVISION:Jy,RGBADepthPacking:hA,RGBAFormat:Mi,RGBAIntegerFormat:A2,RGBA_ASTC_10x10_Format:U2,RGBA_ASTC_10x5_Format:$2,RGBA_ASTC_10x6_Format:B2,RGBA_ASTC_10x8_Format:z2,RGBA_ASTC_12x10_Format:V2,RGBA_ASTC_12x12_Format:G2,RGBA_ASTC_4x4_Format:I2,RGBA_ASTC_5x4_Format:P2,RGBA_ASTC_5x5_Format:N2,RGBA_ASTC_6x5_Format:L2,RGBA_ASTC_6x6_Format:D2,RGBA_ASTC_8x5_Format:k2,RGBA_ASTC_8x6_Format:O2,RGBA_ASTC_8x8_Format:F2,RGBA_BPTC_Format:H2,RGBA_ETC2_EAC_Format:Ug,RGBA_PVRTC_2BPPV1_Format:Bg,RGBA_PVRTC_4BPPV1_Format:$g,RGBA_S3TC_DXT1_Format:Lg,RGBA_S3TC_DXT3_Format:Dg,RGBA_S3TC_DXT5_Format:kg,RGBDEncoding:av,RGBEEncoding:jf,RGBEFormat:w2,RGBFormat:js,RGBIntegerFormat:M2,RGBM16Encoding:ov,RGBM7Encoding:sv,RGB_ETC1_Format:R2,RGB_ETC2_Format:zg,RGB_PVRTC_2BPPV1_Format:Fg,RGB_PVRTC_4BPPV1_Format:Og,RGB_S3TC_DXT1_Format:Ng,RGFormat:E2,RGIntegerFormat:C2,RawShaderMaterial:gs,Ray:Jl,Raycaster:Tv,RectAreaLight:mf,RedFormat:S2,RedIntegerFormat:T2,ReinhardToneMapping:c2,RepeatWrapping:Yc,ReplaceStencilOp:yX,ReverseSubtractEquation:GM,RingBufferGeometry:Xd,RingGeometry:Xd,SRGB8_ALPHA8_ASTC_10x10_Format:nA,SRGB8_ALPHA8_ASTC_10x5_Format:Q2,SRGB8_ALPHA8_ASTC_10x6_Format:eA,SRGB8_ALPHA8_ASTC_10x8_Format:tA,SRGB8_ALPHA8_ASTC_12x10_Format:iA,SRGB8_ALPHA8_ASTC_12x12_Format:rA,SRGB8_ALPHA8_ASTC_4x4_Format:W2,SRGB8_ALPHA8_ASTC_5x4_Format:j2,SRGB8_ALPHA8_ASTC_5x5_Format:q2,SRGB8_ALPHA8_ASTC_6x5_Format:X2,SRGB8_ALPHA8_ASTC_6x6_Format:Y2,SRGB8_ALPHA8_ASTC_8x5_Format:K2,SRGB8_ALPHA8_ASTC_8x6_Format:Z2,SRGB8_ALPHA8_ASTC_8x8_Format:J2,Scene:hv,SceneUtils:qJ,ShaderChunk:dt,ShaderLib:yr,ShaderMaterial:si,ShadowMaterial:la,Shape:Ys,ShapeBufferGeometry:_u,ShapeGeometry:_u,ShapePath:yv,ShapeUtils:ds,ShortType:p2,Skeleton:fu,SkeletonHelper:VA,SkinnedMesh:hu,SmoothShading:cX,Sphere:go,SphereBufferGeometry:bu,SphereGeometry:bu,Spherical:qZ,SphericalHarmonics3:LA,Spline:Mv,SplineCurve:Ar,SplineCurve3:ZA,SpotLight:hf,SpotLightHelper:YZ,Sprite:cu,SpriteMaterial:oo,SrcAlphaFactor:tv,SrcAlphaSaturateFactor:JM,SrcColorFactor:jM,StaticCopyUsage:DX,StaticDrawUsage:Hu,StaticReadUsage:PX,StereoCamera:kA,StreamCopyUsage:OX,StreamDrawUsage:IX,StreamReadUsage:LX,StringKeyframeTrack:of,SubtractEquation:VM,SubtractiveBlending:Ag,TOUCH:oX,TangentSpaceNormalMap:wa,TetrahedronBufferGeometry:Yd,TetrahedronGeometry:Yd,TextBufferGeometry:Kd,TextGeometry:Kd,Texture:Bt,TextureLoader:cf,TorusBufferGeometry:Zd,TorusGeometry:Zd,TorusKnotBufferGeometry:Jd,TorusKnotGeometry:Jd,Triangle:qn,TriangleFanDrawMode:mX,TriangleStripDrawMode:pX,TrianglesDrawMode:lA,TubeBufferGeometry:Qd,TubeGeometry:Qd,UVMapping:Gf,Uint16Attribute:NJ,Uint16BufferAttribute:na,Uint32Attribute:DJ,Uint32BufferAttribute:ia,Uint8Attribute:RJ,Uint8BufferAttribute:nu,Uint8ClampedAttribute:IJ,Uint8ClampedBufferAttribute:iu,Uniform:Kf,UniformsLib:Ee,UniformsUtils:gA,UnsignedByteType:Zl,UnsignedInt248Type:hl,UnsignedIntType:Ic,UnsignedShort4444Type:g2,UnsignedShort5551Type:y2,UnsignedShort565Type:v2,UnsignedShortType:Zc,VSMShadowMap:rl,Vector2:fe,Vector3:k,Vector4:kt,VectorKeyframeTrack:Pl,Vertex:CJ,VertexColors:yJ,VideoTexture:jg,WebGL1Renderer:Hg,WebGLCubeRenderTarget:uv,WebGLMultisampleRenderTarget:BX,WebGLRenderTarget:qs,WebGLRenderTargetCube:GJ,WebGLRenderer:ju,WebGLUtils:CA,WireframeGeometry:fv,WireframeHelper:zJ,WrapAroundEnding:eu,XHRLoader:UJ,ZeroCurvatureEnding:Bo,ZeroFactor:HM,ZeroSlopeEnding:zo,ZeroStencilOp:gX,sRGBEncoding:Gu},Symbol.toStringTag,{value:"Module"})),Ta=Yb(YJ);/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const JA="141",ks={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Os={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},lb=0,KJ=1,cb=1,ZJ=100,JJ=204,QJ=205,eQ=3,Av=0,QA=300,tQ=301,ub=1e3,ol=1001,hb=1002,_f=1003,nQ=1006,iQ=1008,rQ=1009,sQ=1023,oQ=3e3,aQ=3200,qu=0,ss="srgb",Uo="srgb-linear",lm=7680,lQ=519;class Zf{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const r=i.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}}const Ln=[];for(let n=0;n<256;n++)Ln[n]=(n<16?"0":"")+n.toString(16);function Jf(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Ln[n&255]+Ln[n>>8&255]+Ln[n>>16&255]+Ln[n>>24&255]+"-"+Ln[e&255]+Ln[e>>8&255]+"-"+Ln[e>>16&15|64]+Ln[e>>24&255]+"-"+Ln[t&63|128]+Ln[t>>8&255]+"-"+Ln[t>>16&255]+Ln[t>>24&255]+Ln[i&255]+Ln[i>>8&255]+Ln[i>>16&255]+Ln[i>>24&255]).toLowerCase()}function ti(n,e,t){return Math.max(e,Math.min(t,n))}function cQ(n,e){return(n%e+e)%e}function cm(n,e,t){return(1-t)*n+t*e}class Qt{constructor(e=0,t=0){this.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Vo{constructor(){this.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=r,u[2]=a,u[3]=t,u[4]=s,u[5]=l,u[6]=i,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],u=i[4],h=i[7],d=i[2],f=i[5],p=i[8],m=r[0],y=r[3],g=r[6],v=r[1],_=r[4],b=r[7],S=r[2],w=r[5],T=r[8];return s[0]=o*m+a*v+l*S,s[3]=o*y+a*_+l*w,s[6]=o*g+a*b+l*T,s[1]=c*m+u*v+h*S,s[4]=c*y+u*_+h*w,s[7]=c*g+u*b+h*T,s[2]=d*m+f*v+p*S,s[5]=d*y+f*_+p*w,s[8]=d*g+f*b+p*T,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-i*s*u+i*a*l+r*s*c-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*s,f=c*s-o*l,p=t*h+i*d+r*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(r*c-u*i)*m,e[2]=(a*i-r*o)*m,e[3]=d*m,e[4]=(u*t-r*l)*m,e[5]=(r*s-a*t)*m,e[6]=f*m,e[7]=(i*l-c*t)*m,e[8]=(o*t-i*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),r=this.elements,s=r[0],o=r[3],a=r[6],l=r[1],c=r[4],u=r[7];return r[0]=t*s+i*l,r[3]=t*o+i*c,r[6]=t*a+i*u,r[1]=-i*s+t*l,r[4]=-i*o+t*c,r[7]=-i*a+t*u,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}function db(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function Yo(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function xd(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}const um={[ss]:{[Uo]:Yo},[Uo]:{[ss]:xd}},hr={legacyMode:!0,get workingColorSpace(){return Uo},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(um[e]&&um[e][t]!==void 0){const i=um[e][t];return n.r=i(n.r),n.g=i(n.g),n.b=i(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},eR={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yn={r:0,g:0,b:0},dr={h:0,s:0,l:0},Jh={h:0,s:0,l:0};function hm(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function Qh(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}class Mt{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=ss){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,hr.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=Uo){return this.r=e,this.g=t,this.b=i,hr.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=Uo){if(e=cQ(e,1),t=ti(t,0,1),i=ti(i,0,1),t===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+t):i+t-i*t,o=2*i-s;this.r=hm(o,s,e+1/3),this.g=hm(o,s,e),this.b=hm(o,s,e-1/3)}return hr.toWorkingColorSpace(this,r),this}setStyle(e,t=ss){function i(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,hr.toWorkingColorSpace(this,t),i(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,hr.toWorkingColorSpace(this,t),i(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,u=parseInt(s[3],10)/100;return i(s[4]),this.setHSL(l,c,u,t)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],o=s.length;if(o===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,hr.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,hr.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=ss){const i=eR[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Yo(e.r),this.g=Yo(e.g),this.b=Yo(e.b),this}copyLinearToSRGB(e){return this.r=xd(e.r),this.g=xd(e.g),this.b=xd(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=ss){return hr.fromWorkingColorSpace(Qh(this,yn),e),ti(yn.r*255,0,255)<<16^ti(yn.g*255,0,255)<<8^ti(yn.b*255,0,255)<<0}getHexString(e=ss){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Uo){hr.fromWorkingColorSpace(Qh(this,yn),t);const i=yn.r,r=yn.g,s=yn.b,o=Math.max(i,r,s),a=Math.min(i,r,s);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const h=o-a;switch(c=u<=.5?h/(o+a):h/(2-o-a),o){case i:l=(r-s)/h+(r<s?6:0);break;case r:l=(s-i)/h+2;break;case s:l=(i-r)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=Uo){return hr.fromWorkingColorSpace(Qh(this,yn),t),e.r=yn.r,e.g=yn.g,e.b=yn.b,e}getStyle(e=ss){return hr.fromWorkingColorSpace(Qh(this,yn),e),e!==ss?`color(${e} ${yn.r} ${yn.g} ${yn.b})`:`rgb(${yn.r*255|0},${yn.g*255|0},${yn.b*255|0})`}offsetHSL(e,t,i){return this.getHSL(dr),dr.h+=e,dr.s+=t,dr.l+=i,this.setHSL(dr.h,dr.s,dr.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(dr),e.getHSL(Jh);const i=cm(dr.h,Jh.h,t),r=cm(dr.s,Jh.s,t),s=cm(dr.l,Jh.l,t);return this.setHSL(i,r,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}Mt.NAMES=eR;let Xa;class uQ{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Xa===void 0&&(Xa=db("canvas")),Xa.width=e.width,Xa.height=e.height;const i=Xa.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Xa}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&e instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap){const t=db("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),s=r.data;for(let o=0;o<s.length;o++)s[o]=Yo(s[o]/255)*255;return i.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(Yo(t[i]/255)*255):t[i]=Yo(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class hQ{constructor(e=null){this.isSource=!0,this.uuid=Jf(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(dm(r[o].image)):s.push(dm(r[o]))}else s=dm(r);i.url=s}return t||(e.images[this.uuid]=i),i}}function dm(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?uQ.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let dQ=0;class vs extends Zf{constructor(e=vs.DEFAULT_IMAGE,t=vs.DEFAULT_MAPPING,i=ol,r=ol,s=nQ,o=iQ,a=sQ,l=rQ,c=1,u=oQ){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:dQ++}),this.uuid=Jf(),this.name="",this.source=new hQ(e),this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Qt(0,0),this.repeat=new Qt(1,1),this.center=new Qt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Vo,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==QA)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case ub:e.x=e.x-Math.floor(e.x);break;case ol:e.x=e.x<0?0:1;break;case hb:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case ub:e.y=e.y-Math.floor(e.y);break;case ol:e.y=e.y<0?0:1;break;case hb:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}vs.DEFAULT_IMAGE=null;vs.DEFAULT_MAPPING=QA;class fQ extends vs{constructor(e=null,t=1,i=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=_f,this.minFilter=_f,this.wrapR=ol,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class pQ extends vs{constructor(e=null,t=1,i=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=_f,this.minFilter=_f,this.wrapR=ol,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ma{constructor(e=0,t=0,i=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=r}static slerp(e,t,i,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(e,t,r)}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],c=i[r+1],u=i[r+2],h=i[r+3];const d=s[o+0],f=s[o+1],p=s[o+2],m=s[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=f,e[t+2]=p,e[t+3]=m;return}if(h!==m||l!==d||c!==f||u!==p){let y=1-a;const g=l*d+c*f+u*p+h*m,v=g>=0?1:-1,_=1-g*g;if(_>Number.EPSILON){const S=Math.sqrt(_),w=Math.atan2(S,g*v);y=Math.sin(y*w)/S,a=Math.sin(a*w)/S}const b=a*v;if(l=l*y+d*b,c=c*y+f*b,u=u*y+p*b,h=h*y+m*b,y===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],u=i[r+3],h=s[o],d=s[o+1],f=s[o+2],p=s[o+3];return e[t]=a*p+u*h+l*f-c*d,e[t+1]=l*p+u*d+c*h-a*f,e[t+2]=c*p+u*f+a*d-l*h,e[t+3]=u*p-a*h-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),u=a(r/2),h=a(s/2),d=l(i/2),f=l(r/2),p=l(s/2);switch(o){case"XYZ":this._x=d*u*h+c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h-d*f*p;break;case"YXZ":this._x=d*u*h+c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h+d*f*p;break;case"ZXY":this._x=d*u*h-c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h-d*f*p;break;case"ZYX":this._x=d*u*h-c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h+d*f*p;break;case"YZX":this._x=d*u*h+c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h-d*f*p;break;case"XZY":this._x=d*u*h-c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=i+a+h;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(u-l)*f,this._y=(s-c)*f,this._z=(o-r)*f}else if(i>a&&i>h){const f=2*Math.sqrt(1+i-a-h);this._w=(u-l)/f,this._x=.25*f,this._y=(r+o)/f,this._z=(s+c)/f}else if(a>h){const f=2*Math.sqrt(1+a-i-h);this._w=(s-c)/f,this._x=(r+o)/f,this._y=.25*f,this._z=(l+u)/f}else{const f=2*Math.sqrt(1+h-i-a);this._w=(o-r)/f,this._x=(s+c)/f,this._y=(l+u)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(ti(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=i*u+o*a+r*c-s*l,this._y=r*u+o*l+s*a-i*c,this._z=s*u+o*c+i*l-r*a,this._w=o*u-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-t;return this._w=f*o+t*this._w,this._x=f*i+t*this._x,this._y=f*r+t*this._y,this._z=f*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=i*h+this._x*d,this._y=r*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(r),i*Math.sin(s),i*Math.cos(s),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class et{constructor(e=0,t=0,i=0){this.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(fb.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(fb.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*r-a*i,u=l*i+a*t-s*r,h=l*r+s*i-o*t,d=-s*t-o*i-a*r;return this.x=c*l+d*-s+u*-a-h*-o,this.y=u*l+d*-o+h*-s-c*-a,this.z=h*l+d*-a+c*-o-u*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return fm.copy(this).projectOnVector(e),this.sub(fm)}reflect(e){return this.sub(fm.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(ti(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const fm=new et,fb=new ma;class Zs{constructor(){this.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c,u,h,d,f,p,m,y){const g=this.elements;return g[0]=e,g[4]=t,g[8]=i,g[12]=r,g[1]=s,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=f,g[7]=p,g[11]=m,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Zs().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/Ya.setFromMatrixColumn(e,0).length(),s=1/Ya.setFromMatrixColumn(e,1).length(),o=1/Ya.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),u=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const d=o*u,f=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=f+p*c,t[5]=d-m*c,t[9]=-a*l,t[2]=m-d*c,t[6]=p+f*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,f=l*h,p=c*u,m=c*h;t[0]=d+m*a,t[4]=p*a-f,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=f*a-p,t[6]=m+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,f=l*h,p=c*u,m=c*h;t[0]=d-m*a,t[4]=-o*h,t[8]=p+f*a,t[1]=f+p*a,t[5]=o*u,t[9]=m-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,f=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=p*c-f,t[8]=d*c+m,t[1]=l*h,t[5]=m*c+d,t[9]=f*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,f=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=m-d*h,t[8]=p*h+f,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=f*h+p,t[10]=d-m*h}else if(e.order==="XZY"){const d=o*l,f=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+m,t[5]=o*u,t[9]=f*h-p,t[2]=p*h-f,t[6]=a*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(mQ,e,gQ)}lookAt(e,t,i){const r=this.elements;return wi.subVectors(e,t),wi.lengthSq()===0&&(wi.z=1),wi.normalize(),Ls.crossVectors(i,wi),Ls.lengthSq()===0&&(Math.abs(i.z)===1?wi.x+=1e-4:wi.z+=1e-4,wi.normalize(),Ls.crossVectors(i,wi)),Ls.normalize(),ed.crossVectors(wi,Ls),r[0]=Ls.x,r[4]=ed.x,r[8]=wi.x,r[1]=Ls.y,r[5]=ed.y,r[9]=wi.y,r[2]=Ls.z,r[6]=ed.z,r[10]=wi.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],u=i[1],h=i[5],d=i[9],f=i[13],p=i[2],m=i[6],y=i[10],g=i[14],v=i[3],_=i[7],b=i[11],S=i[15],w=r[0],T=r[4],R=r[8],M=r[12],P=r[1],L=r[5],$=r[9],O=r[13],I=r[2],N=r[6],V=r[10],X=r[14],J=r[3],W=r[7],Q=r[11],re=r[15];return s[0]=o*w+a*P+l*I+c*J,s[4]=o*T+a*L+l*N+c*W,s[8]=o*R+a*$+l*V+c*Q,s[12]=o*M+a*O+l*X+c*re,s[1]=u*w+h*P+d*I+f*J,s[5]=u*T+h*L+d*N+f*W,s[9]=u*R+h*$+d*V+f*Q,s[13]=u*M+h*O+d*X+f*re,s[2]=p*w+m*P+y*I+g*J,s[6]=p*T+m*L+y*N+g*W,s[10]=p*R+m*$+y*V+g*Q,s[14]=p*M+m*O+y*X+g*re,s[3]=v*w+_*P+b*I+S*J,s[7]=v*T+_*L+b*N+S*W,s[11]=v*R+_*$+b*V+S*Q,s[15]=v*M+_*O+b*X+S*re,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],f=e[14],p=e[3],m=e[7],y=e[11],g=e[15];return p*(+s*l*h-r*c*h-s*a*d+i*c*d+r*a*f-i*l*f)+m*(+t*l*f-t*c*d+s*o*d-r*o*f+r*c*u-s*l*u)+y*(+t*c*h-t*a*f-s*o*h+i*o*f+s*a*u-i*c*u)+g*(-r*a*u-t*l*h+t*a*d+r*o*h-i*o*d+i*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],y=e[14],g=e[15],v=h*y*c-m*d*c+m*l*f-a*y*f-h*l*g+a*d*g,_=p*d*c-u*y*c-p*l*f+o*y*f+u*l*g-o*d*g,b=u*m*c-p*h*c+p*a*f-o*m*f-u*a*g+o*h*g,S=p*h*l-u*m*l-p*a*d+o*m*d+u*a*y-o*h*y,w=t*v+i*_+r*b+s*S;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/w;return e[0]=v*T,e[1]=(m*d*s-h*y*s-m*r*f+i*y*f+h*r*g-i*d*g)*T,e[2]=(a*y*s-m*l*s+m*r*c-i*y*c-a*r*g+i*l*g)*T,e[3]=(h*l*s-a*d*s-h*r*c+i*d*c+a*r*f-i*l*f)*T,e[4]=_*T,e[5]=(u*y*s-p*d*s+p*r*f-t*y*f-u*r*g+t*d*g)*T,e[6]=(p*l*s-o*y*s-p*r*c+t*y*c+o*r*g-t*l*g)*T,e[7]=(o*d*s-u*l*s+u*r*c-t*d*c-o*r*f+t*l*f)*T,e[8]=b*T,e[9]=(p*h*s-u*m*s-p*i*f+t*m*f+u*i*g-t*h*g)*T,e[10]=(o*m*s-p*a*s+p*i*c-t*m*c-o*i*g+t*a*g)*T,e[11]=(u*a*s-o*h*s-u*i*c+t*h*c+o*i*f-t*a*f)*T,e[12]=S*T,e[13]=(u*m*r-p*h*r+p*i*d-t*m*d-u*i*y+t*h*y)*T,e[14]=(p*a*r-o*m*r-p*i*l+t*m*l+o*i*y-t*a*y)*T,e[15]=(o*h*r-u*a*r+u*i*l-t*h*l-o*i*d+t*a*d)*T,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,c=s*o,u=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,u*a+i,u*l-r*o,0,c*l-r*a,u*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,s,o){return this.set(1,i,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,u=o+o,h=a+a,d=s*c,f=s*u,p=s*h,m=o*u,y=o*h,g=a*h,v=l*c,_=l*u,b=l*h,S=i.x,w=i.y,T=i.z;return r[0]=(1-(m+g))*S,r[1]=(f+b)*S,r[2]=(p-_)*S,r[3]=0,r[4]=(f-b)*w,r[5]=(1-(d+g))*w,r[6]=(y+v)*w,r[7]=0,r[8]=(p+_)*T,r[9]=(y-v)*T,r[10]=(1-(d+m))*T,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=Ya.set(r[0],r[1],r[2]).length();const o=Ya.set(r[4],r[5],r[6]).length(),a=Ya.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],fr.copy(this);const c=1/s,u=1/o,h=1/a;return fr.elements[0]*=c,fr.elements[1]*=c,fr.elements[2]*=c,fr.elements[4]*=u,fr.elements[5]*=u,fr.elements[6]*=u,fr.elements[8]*=h,fr.elements[9]*=h,fr.elements[10]*=h,t.setFromRotationMatrix(fr),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(t-e),c=2*s/(i-r),u=(t+e)/(t-e),h=(i+r)/(i-r),d=-(o+s)/(o-s),f=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,r,s,o){const a=this.elements,l=1/(t-e),c=1/(i-r),u=1/(o-s),h=(t+e)*l,d=(i+r)*c,f=(o+s)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}const Ya=new et,fr=new Zs,mQ=new et(0,0,0),gQ=new et(1,1,1),Ls=new et,ed=new et,wi=new et,pb=new Zs,mb=new ma;class Xu{constructor(e=0,t=0,i=0,r=Xu.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],f=r[10];switch(t){case"XYZ":this._y=Math.asin(ti(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,f),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-ti(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(ti(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-ti(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(ti(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-ti(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return pb.makeRotationFromQuaternion(e),this.setFromRotationMatrix(pb,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return mb.setFromEuler(this),this.setFromQuaternion(mb,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Xu.DefaultOrder="XYZ";Xu.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class yQ{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let vQ=0;const gb=new et,Ka=new ma,ts=new Zs,td=new et,xc=new et,xQ=new et,_Q=new ma,yb=new et(1,0,0),vb=new et(0,1,0),xb=new et(0,0,1),bQ={type:"added"},_b={type:"removed"};class Cu extends Zf{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:vQ++}),this.uuid=Jf(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Cu.DefaultUp.clone();const e=new et,t=new Xu,i=new ma,r=new et(1,1,1);function s(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Zs},normalMatrix:{value:new Vo}}),this.matrix=new Zs,this.matrixWorld=new Zs,this.matrixAutoUpdate=Cu.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new yQ,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Ka.setFromAxisAngle(e,t),this.quaternion.multiply(Ka),this}rotateOnWorldAxis(e,t){return Ka.setFromAxisAngle(e,t),this.quaternion.premultiply(Ka),this}rotateX(e){return this.rotateOnAxis(yb,e)}rotateY(e){return this.rotateOnAxis(vb,e)}rotateZ(e){return this.rotateOnAxis(xb,e)}translateOnAxis(e,t){return gb.copy(e).applyQuaternion(this.quaternion),this.position.add(gb.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(yb,e)}translateY(e){return this.translateOnAxis(vb,e)}translateZ(e){return this.translateOnAxis(xb,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(ts.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?td.copy(e):td.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),xc.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ts.lookAt(xc,td,this.up):ts.lookAt(td,xc,this.up),this.quaternion.setFromRotationMatrix(ts),r&&(ts.extractRotation(r.matrixWorld),Ka.setFromRotationMatrix(ts),this.quaternion.premultiply(Ka.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(bQ)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(_b)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(_b)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),ts.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ts.multiply(e.parent.matrixWorld)),e.applyMatrix4(ts),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xc,e,xQ),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xc,_Q,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];s(e.shapes,h)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),f=o(e.animations),p=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),u.length>0&&(i.images=u),h.length>0&&(i.shapes=h),d.length>0&&(i.skeletons=d),f.length>0&&(i.animations=f),p.length>0&&(i.nodes=p)}return i.object=r,i;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const r=e.children[i];this.add(r.clone())}return this}}Cu.DefaultUp=new et(0,1,0);Cu.DefaultMatrixAutoUpdate=!0;const pr=new et,ns=new et,pm=new et,is=new et,Za=new et,Ja=new et,bb=new et,mm=new et,gm=new et,ym=new et;class Do{constructor(e=new et,t=new et,i=new et){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),pr.subVectors(e,t),r.cross(pr);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){pr.subVectors(r,t),ns.subVectors(i,t),pm.subVectors(e,t);const o=pr.dot(pr),a=pr.dot(ns),l=pr.dot(pm),c=ns.dot(ns),u=ns.dot(pm),h=o*c-a*a;if(h===0)return s.set(-2,-1,-1);const d=1/h,f=(c*l-a*u)*d,p=(o*u-a*l)*d;return s.set(1-f-p,p,f)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,is),is.x>=0&&is.y>=0&&is.x+is.y<=1}static getUV(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,is),l.set(0,0),l.addScaledVector(s,is.x),l.addScaledVector(o,is.y),l.addScaledVector(a,is.z),l}static isFrontFacing(e,t,i,r){return pr.subVectors(i,t),ns.subVectors(e,t),pr.cross(ns).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return pr.subVectors(this.c,this.b),ns.subVectors(this.a,this.b),pr.cross(ns).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Do.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Do.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,r,s){return Do.getUV(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return Do.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Do.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,s=this.c;let o,a;Za.subVectors(r,i),Ja.subVectors(s,i),mm.subVectors(e,i);const l=Za.dot(mm),c=Ja.dot(mm);if(l<=0&&c<=0)return t.copy(i);gm.subVectors(e,r);const u=Za.dot(gm),h=Ja.dot(gm);if(u>=0&&h<=u)return t.copy(r);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(i).addScaledVector(Za,o);ym.subVectors(e,s);const f=Za.dot(ym),p=Ja.dot(ym);if(p>=0&&f<=p)return t.copy(s);const m=f*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(i).addScaledVector(Ja,a);const y=u*p-f*h;if(y<=0&&h-u>=0&&f-p>=0)return bb.subVectors(s,r),a=(h-u)/(h-u+(f-p)),t.copy(r).addScaledVector(bb,a);const g=1/(y+m+d);return o=m*g,a=d*g,t.copy(i).addScaledVector(Za,o).addScaledVector(Ja,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let wQ=0;class Fn extends Zf{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:wQ++}),this.uuid=Jf(),this.name="",this.type="Material",this.blending=cb,this.side=lb,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=JJ,this.blendDst=QJ,this.blendEquation=ZJ,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=eQ,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=lQ,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=lm,this.stencilZFail=lm,this.stencilZPass=lm,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===KJ;continue}const r=this[t];if(r===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==cb&&(i.blending=this.blending),this.side!==lb&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function r(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(i.textures=s),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const r=t.length;i=new Array(r);for(let s=0;s!==r;++s)i[s]=t[s].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}get vertexTangents(){return console.warn("THREE."+this.type+": .vertexTangents has been removed."),!1}set vertexTangents(e){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}Fn.fromType=function(){return null};class SQ extends Fn{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Mt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Av,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}function tR(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function ei(n){const e={};for(let t=0;t<n.length;t++){const i=tR(n[t]);for(const r in i)e[r]=i[r]}return e}var TQ=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,EQ=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class nR extends Fn{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=TQ,this.fragmentShader=EQ,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=tR(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const r in this.extensions)this.extensions[r]===!0&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}class CQ extends vs{constructor(e,t,i,r,s,o,a,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:tQ,super(e,t,i,r,s,o,a,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}var MQ=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,AQ=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,RQ=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,IQ=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,PQ=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,NQ=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,LQ="vec3 transformed = vec3( position );",DQ=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,kQ=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,OQ=`#ifdef USE_IRIDESCENCE
const mat3 XYZ_TO_REC709 = mat3(
    3.2404542, -0.9692660,  0.0556434,
   -1.5371385,  1.8760108, -0.2040259,
   -0.4985314,  0.0415560,  1.0572252
);
vec3 Fresnel0ToIor( vec3 fresnel0 ) {
   vec3 sqrtF0 = sqrt( fresnel0 );
   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
}
vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
}
float IorToFresnel0( float transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
}
vec3 evalSensitivity( float OPD, vec3 shift ) {
   float phase = 2.0 * PI * OPD * 1.0e-9;
   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );
   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );
   xyz /= 1.0685e-7;
   vec3 srgb = XYZ_TO_REC709 * xyz;
   return srgb;
}
vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
   vec3 I;
   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
   float cosTheta2Sq = 1.0 - sinTheta2Sq;
   if ( cosTheta2Sq < 0.0 ) {
       return vec3( 1.0 );
   }
   float cosTheta2 = sqrt( cosTheta2Sq );
   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
   float R12 = F_Schlick( R0, 1.0, cosTheta1 );
   float R21 = R12;
   float T121 = 1.0 - R12;
   float phi12 = 0.0;
   if ( iridescenceIOR < outsideIOR ) phi12 = PI;
   float phi21 = PI - phi12;
   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
   vec3 phi23 = vec3( 0.0 );
   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;
   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;
   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;
   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
   vec3 phi = vec3( phi21 ) + phi23;
   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
   vec3 r123 = sqrt( R123 );
   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
   vec3 C0 = R12 + Rs;
   I = C0;
   vec3 Cm = Rs - T121;
   for ( int m = 1; m <= 2; ++m ) {
       Cm *= r123;
       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
       I += Cm * Sm;
   }
   return max( I, vec3( 0.0 ) );
}
#endif`,FQ=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,$Q=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,BQ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,zQ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,UQ=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,VQ=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,GQ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,HQ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,WQ=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,jQ=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,qQ=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,XQ=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,YQ=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,KQ=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,ZQ=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,JQ=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,QQ="gl_FragColor = linearToOutputTexel( gl_FragColor );",eee=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,tee=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,nee=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,iee=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,ree=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,see=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,oee=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,aee=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,lee=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,cee=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,uee=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,hee=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,dee=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,fee=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,pee=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,mee=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,gee=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,yee=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,vee=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,xee=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,_ee=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,bee=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,wee=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
float dotNVi = saturate( dot( normal, geometry.viewDir ) );
if ( material.iridescenceThickness == 0.0 ) {
	material.iridescence = 0.0;
} else {
	material.iridescence = saturate( material.iridescence );
}
if ( material.iridescence > 0.0 ) {
	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,See=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Tee=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Eee=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Cee=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Mee=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Aee=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Ree=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Iee=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Pee=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Nee=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Lee=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Dee=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,kee=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Oee=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,Fee=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,$ee=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,Bee=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,zee=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Uee=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Vee=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Gee=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Hee=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Wee=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,jee=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,qee=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Xee=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Yee=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Kee=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Zee=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Jee=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Qee=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,ete=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,tte=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,nte=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,ite=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,rte=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,ste=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,ote=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,ate=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,lte=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,cte=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,ute=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,hte=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,dte=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,fte=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,pte=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,mte=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,gte=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,yte=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,vte=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,xte=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,_te=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,bte=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,wte=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,Ste=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Tte=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Ete=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Cte=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Mte=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Ate=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Rte=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Ite=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Pte=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Nte=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Lte=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Dte=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,kte=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Ote=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Fte=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$te=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Bte=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,zte=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Ute=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Vte=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Gte=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Hte=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Wte=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,jte=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,qte=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Xte=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Yte=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Kte=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Zte=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Jte=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Qte=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ene=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,tne=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,xt={alphamap_fragment:MQ,alphamap_pars_fragment:AQ,alphatest_fragment:RQ,alphatest_pars_fragment:IQ,aomap_fragment:PQ,aomap_pars_fragment:NQ,begin_vertex:LQ,beginnormal_vertex:DQ,bsdfs:kQ,iridescence_fragment:OQ,bumpmap_pars_fragment:FQ,clipping_planes_fragment:$Q,clipping_planes_pars_fragment:BQ,clipping_planes_pars_vertex:zQ,clipping_planes_vertex:UQ,color_fragment:VQ,color_pars_fragment:GQ,color_pars_vertex:HQ,color_vertex:WQ,common:jQ,cube_uv_reflection_fragment:qQ,defaultnormal_vertex:XQ,displacementmap_pars_vertex:YQ,displacementmap_vertex:KQ,emissivemap_fragment:ZQ,emissivemap_pars_fragment:JQ,encodings_fragment:QQ,encodings_pars_fragment:eee,envmap_fragment:tee,envmap_common_pars_fragment:nee,envmap_pars_fragment:iee,envmap_pars_vertex:ree,envmap_physical_pars_fragment:mee,envmap_vertex:see,fog_vertex:oee,fog_pars_vertex:aee,fog_fragment:lee,fog_pars_fragment:cee,gradientmap_pars_fragment:uee,lightmap_fragment:hee,lightmap_pars_fragment:dee,lights_lambert_vertex:fee,lights_pars_begin:pee,lights_toon_fragment:gee,lights_toon_pars_fragment:yee,lights_phong_fragment:vee,lights_phong_pars_fragment:xee,lights_physical_fragment:_ee,lights_physical_pars_fragment:bee,lights_fragment_begin:wee,lights_fragment_maps:See,lights_fragment_end:Tee,logdepthbuf_fragment:Eee,logdepthbuf_pars_fragment:Cee,logdepthbuf_pars_vertex:Mee,logdepthbuf_vertex:Aee,map_fragment:Ree,map_pars_fragment:Iee,map_particle_fragment:Pee,map_particle_pars_fragment:Nee,metalnessmap_fragment:Lee,metalnessmap_pars_fragment:Dee,morphcolor_vertex:kee,morphnormal_vertex:Oee,morphtarget_pars_vertex:Fee,morphtarget_vertex:$ee,normal_fragment_begin:Bee,normal_fragment_maps:zee,normal_pars_fragment:Uee,normal_pars_vertex:Vee,normal_vertex:Gee,normalmap_pars_fragment:Hee,clearcoat_normal_fragment_begin:Wee,clearcoat_normal_fragment_maps:jee,clearcoat_pars_fragment:qee,iridescence_pars_fragment:Xee,output_fragment:Yee,packing:Kee,premultiplied_alpha_fragment:Zee,project_vertex:Jee,dithering_fragment:Qee,dithering_pars_fragment:ete,roughnessmap_fragment:tte,roughnessmap_pars_fragment:nte,shadowmap_pars_fragment:ite,shadowmap_pars_vertex:rte,shadowmap_vertex:ste,shadowmask_pars_fragment:ote,skinbase_vertex:ate,skinning_pars_vertex:lte,skinning_vertex:cte,skinnormal_vertex:ute,specularmap_fragment:hte,specularmap_pars_fragment:dte,tonemapping_fragment:fte,tonemapping_pars_fragment:pte,transmission_fragment:mte,transmission_pars_fragment:gte,uv_pars_fragment:yte,uv_pars_vertex:vte,uv_vertex:xte,uv2_pars_fragment:_te,uv2_pars_vertex:bte,uv2_vertex:wte,worldpos_vertex:Ste,background_vert:Tte,background_frag:Ete,cube_vert:Cte,cube_frag:Mte,depth_vert:Ate,depth_frag:Rte,distanceRGBA_vert:Ite,distanceRGBA_frag:Pte,equirect_vert:Nte,equirect_frag:Lte,linedashed_vert:Dte,linedashed_frag:kte,meshbasic_vert:Ote,meshbasic_frag:Fte,meshlambert_vert:$te,meshlambert_frag:Bte,meshmatcap_vert:zte,meshmatcap_frag:Ute,meshnormal_vert:Vte,meshnormal_frag:Gte,meshphong_vert:Hte,meshphong_frag:Wte,meshphysical_vert:jte,meshphysical_frag:qte,meshtoon_vert:Xte,meshtoon_frag:Yte,points_vert:Kte,points_frag:Zte,shadow_vert:Jte,shadow_frag:Qte,sprite_vert:ene,sprite_frag:tne},Re={common:{diffuse:{value:new Mt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Vo},uv2Transform:{value:new Vo},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Qt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Mt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Mt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Vo}},sprite:{diffuse:{value:new Mt(16777215)},opacity:{value:1},center:{value:new Qt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Vo}}},wb={basic:{uniforms:ei([Re.common,Re.specularmap,Re.envmap,Re.aomap,Re.lightmap,Re.fog]),vertexShader:xt.meshbasic_vert,fragmentShader:xt.meshbasic_frag},lambert:{uniforms:ei([Re.common,Re.specularmap,Re.envmap,Re.aomap,Re.lightmap,Re.emissivemap,Re.fog,Re.lights,{emissive:{value:new Mt(0)}}]),vertexShader:xt.meshlambert_vert,fragmentShader:xt.meshlambert_frag},phong:{uniforms:ei([Re.common,Re.specularmap,Re.envmap,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.fog,Re.lights,{emissive:{value:new Mt(0)},specular:{value:new Mt(1118481)},shininess:{value:30}}]),vertexShader:xt.meshphong_vert,fragmentShader:xt.meshphong_frag},standard:{uniforms:ei([Re.common,Re.envmap,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.roughnessmap,Re.metalnessmap,Re.fog,Re.lights,{emissive:{value:new Mt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:xt.meshphysical_vert,fragmentShader:xt.meshphysical_frag},toon:{uniforms:ei([Re.common,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.gradientmap,Re.fog,Re.lights,{emissive:{value:new Mt(0)}}]),vertexShader:xt.meshtoon_vert,fragmentShader:xt.meshtoon_frag},matcap:{uniforms:ei([Re.common,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.fog,{matcap:{value:null}}]),vertexShader:xt.meshmatcap_vert,fragmentShader:xt.meshmatcap_frag},points:{uniforms:ei([Re.points,Re.fog]),vertexShader:xt.points_vert,fragmentShader:xt.points_frag},dashed:{uniforms:ei([Re.common,Re.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:xt.linedashed_vert,fragmentShader:xt.linedashed_frag},depth:{uniforms:ei([Re.common,Re.displacementmap]),vertexShader:xt.depth_vert,fragmentShader:xt.depth_frag},normal:{uniforms:ei([Re.common,Re.bumpmap,Re.normalmap,Re.displacementmap,{opacity:{value:1}}]),vertexShader:xt.meshnormal_vert,fragmentShader:xt.meshnormal_frag},sprite:{uniforms:ei([Re.sprite,Re.fog]),vertexShader:xt.sprite_vert,fragmentShader:xt.sprite_frag},background:{uniforms:{uvTransform:{value:new Vo},t2D:{value:null}},vertexShader:xt.background_vert,fragmentShader:xt.background_frag},cube:{uniforms:ei([Re.envmap,{opacity:{value:1}}]),vertexShader:xt.cube_vert,fragmentShader:xt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:xt.equirect_vert,fragmentShader:xt.equirect_frag},distanceRGBA:{uniforms:ei([Re.common,Re.displacementmap,{referencePosition:{value:new et},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:xt.distanceRGBA_vert,fragmentShader:xt.distanceRGBA_frag},shadow:{uniforms:ei([Re.lights,Re.fog,{color:{value:new Mt(0)},opacity:{value:1}}]),vertexShader:xt.shadow_vert,fragmentShader:xt.shadow_frag}};wb.physical={uniforms:ei([wb.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Qt(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Mt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Qt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Mt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Mt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:xt.meshphysical_vert,fragmentShader:xt.meshphysical_frag};new vs;new fQ;new pQ;new CQ;class nne extends Fn{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=aQ,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class ine extends Fn{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new et,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class rne extends Fn{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Mt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}class iR extends Fn{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Mt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}class sne extends Fn{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Mt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}new et;new et;new et;new et;new Do;class one extends Fn{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Mt(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class ane extends nR{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class rR extends Fn{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Mt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qu,this.normalScale=new Qt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class lne extends rR{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Qt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ti(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Mt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Mt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Mt(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class cne extends Fn{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Mt(16777215),this.specular=new Mt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qu,this.normalScale=new Qt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Av,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class une extends Fn{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Mt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qu,this.normalScale=new Qt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class hne extends Fn{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qu,this.normalScale=new Qt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class dne extends Fn{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Mt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Av,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class fne extends Fn{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Mt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qu,this.normalScale=new Qt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class pne extends iR{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}const mne={ShadowMaterial:one,SpriteMaterial:rne,RawShaderMaterial:ane,ShaderMaterial:nR,PointsMaterial:sne,MeshPhysicalMaterial:lne,MeshStandardMaterial:rR,MeshPhongMaterial:cne,MeshToonMaterial:une,MeshNormalMaterial:hne,MeshLambertMaterial:dne,MeshDepthMaterial:nne,MeshDistanceMaterial:ine,MeshBasicMaterial:SQ,MeshMatcapMaterial:fne,LineDashedMaterial:pne,LineBasicMaterial:iR,Material:Fn};Fn.fromType=function(n){return new mne[n]};const sR="\\[\\]\\.:\\/",Rv="[^"+sR+"]",gne="[^"+sR.replace("\\.","")+"]";/((?:WC+[\/:])*)/.source.replace("WC",Rv);/(WCOD+)?/.source.replace("WCOD",gne);/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Rv);/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Rv);class Sb{constructor(e=1,t=0,i=0){return this.radius=e,this.phi=t,this.theta=i,this}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(ti(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const Dr=new Uint32Array(512),kr=new Uint32Array(512);for(let n=0;n<256;++n){const e=n-127;e<-27?(Dr[n]=0,Dr[n|256]=32768,kr[n]=24,kr[n|256]=24):e<-14?(Dr[n]=1024>>-e-14,Dr[n|256]=1024>>-e-14|32768,kr[n]=-e-1,kr[n|256]=-e-1):e<=15?(Dr[n]=e+15<<10,Dr[n|256]=e+15<<10|32768,kr[n]=13,kr[n|256]=13):e<128?(Dr[n]=31744,Dr[n|256]=64512,kr[n]=24,kr[n|256]=24):(Dr[n]=31744,Dr[n|256]=64512,kr[n]=13,kr[n|256]=13)}const oR=new Uint32Array(2048),Yu=new Uint32Array(64),yne=new Uint32Array(64);for(let n=1;n<1024;++n){let e=n<<13,t=0;for(;(e&8388608)===0;)e<<=1,t-=8388608;e&=-8388609,t+=947912704,oR[n]=e|t}for(let n=1024;n<2048;++n)oR[n]=939524096+(n-1024<<13);for(let n=1;n<31;++n)Yu[n]=n<<23;Yu[31]=1199570944;Yu[32]=2147483648;for(let n=33;n<63;++n)Yu[n]=2147483648+(n-32<<23);Yu[63]=3347054592;for(let n=1;n<64;++n)n!==32&&(yne[n]=1024);typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:JA}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=JA);const Tb={type:"change"},vm={type:"start"},Eb={type:"end"};class aR extends Zf{constructor(e,t){super(),t===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new et,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:ks.ROTATE,MIDDLE:ks.DOLLY,RIGHT:ks.PAN},this.touches={ONE:Os.ROTATE,TWO:Os.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(H){H.addEventListener("keydown",j),this._domElementKeyEvents=H},this.saveState=function(){i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=function(){i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent(Tb),i.update(),s=r.NONE},this.update=function(){const H=new et,ue=new ma().setFromUnitVectors(e.up,new et(0,1,0)),Je=ue.clone().invert(),yt=new et,pn=new ma,sr=2*Math.PI;return function(){const yo=i.object.position;H.copy(yo).sub(i.target),H.applyQuaternion(ue),a.setFromVector3(H),i.autoRotate&&s===r.NONE&&M(T()),i.enableDamping?(a.theta+=l.theta*i.dampingFactor,a.phi+=l.phi*i.dampingFactor):(a.theta+=l.theta,a.phi+=l.phi);let Rn=i.minAzimuthAngle,In=i.maxAzimuthAngle;return isFinite(Rn)&&isFinite(In)&&(Rn<-Math.PI?Rn+=sr:Rn>Math.PI&&(Rn-=sr),In<-Math.PI?In+=sr:In>Math.PI&&(In-=sr),Rn<=In?a.theta=Math.max(Rn,Math.min(In,a.theta)):a.theta=a.theta>(Rn+In)/2?Math.max(Rn,a.theta):Math.min(In,a.theta)),a.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=c,a.radius=Math.max(i.minDistance,Math.min(i.maxDistance,a.radius)),i.enableDamping===!0?i.target.addScaledVector(u,i.dampingFactor):i.target.add(u),H.setFromSpherical(a),H.applyQuaternion(Je),yo.copy(i.target).add(H),i.object.lookAt(i.target),i.enableDamping===!0?(l.theta*=1-i.dampingFactor,l.phi*=1-i.dampingFactor,u.multiplyScalar(1-i.dampingFactor)):(l.set(0,0,0),u.set(0,0,0)),c=1,h||yt.distanceToSquared(i.object.position)>o||8*(1-pn.dot(i.object.quaternion))>o?(i.dispatchEvent(Tb),yt.copy(i.object.position),pn.copy(i.object.quaternion),h=!1,!0):!1}}(),this.dispose=function(){i.domElement.removeEventListener("contextmenu",De),i.domElement.removeEventListener("pointerdown",be),i.domElement.removeEventListener("pointercancel",z),i.domElement.removeEventListener("wheel",le),i.domElement.removeEventListener("pointermove",Oe),i.domElement.removeEventListener("pointerup",_e),i._domElementKeyEvents!==null&&i._domElementKeyEvents.removeEventListener("keydown",j)};const i=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=r.NONE;const o=1e-6,a=new Sb,l=new Sb;let c=1;const u=new et;let h=!1;const d=new Qt,f=new Qt,p=new Qt,m=new Qt,y=new Qt,g=new Qt,v=new Qt,_=new Qt,b=new Qt,S=[],w={};function T(){return 2*Math.PI/60/60*i.autoRotateSpeed}function R(){return Math.pow(.95,i.zoomSpeed)}function M(H){l.theta-=H}function P(H){l.phi-=H}const L=function(){const H=new et;return function(Je,yt){H.setFromMatrixColumn(yt,0),H.multiplyScalar(-Je),u.add(H)}}(),$=function(){const H=new et;return function(Je,yt){i.screenSpacePanning===!0?H.setFromMatrixColumn(yt,1):(H.setFromMatrixColumn(yt,0),H.crossVectors(i.object.up,H)),H.multiplyScalar(Je),u.add(H)}}(),O=function(){const H=new et;return function(Je,yt){const pn=i.domElement;if(i.object.isPerspectiveCamera){const sr=i.object.position;H.copy(sr).sub(i.target);let Di=H.length();Di*=Math.tan(i.object.fov/2*Math.PI/180),L(2*Je*Di/pn.clientHeight,i.object.matrix),$(2*yt*Di/pn.clientHeight,i.object.matrix)}else i.object.isOrthographicCamera?(L(Je*(i.object.right-i.object.left)/i.object.zoom/pn.clientWidth,i.object.matrix),$(yt*(i.object.top-i.object.bottom)/i.object.zoom/pn.clientHeight,i.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}}();function I(H){i.object.isPerspectiveCamera?c/=H:i.object.isOrthographicCamera?(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom*H)),i.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function N(H){i.object.isPerspectiveCamera?c*=H:i.object.isOrthographicCamera?(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/H)),i.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function V(H){d.set(H.clientX,H.clientY)}function X(H){v.set(H.clientX,H.clientY)}function J(H){m.set(H.clientX,H.clientY)}function W(H){f.set(H.clientX,H.clientY),p.subVectors(f,d).multiplyScalar(i.rotateSpeed);const ue=i.domElement;M(2*Math.PI*p.x/ue.clientHeight),P(2*Math.PI*p.y/ue.clientHeight),d.copy(f),i.update()}function Q(H){_.set(H.clientX,H.clientY),b.subVectors(_,v),b.y>0?I(R()):b.y<0&&N(R()),v.copy(_),i.update()}function re(H){y.set(H.clientX,H.clientY),g.subVectors(y,m).multiplyScalar(i.panSpeed),O(g.x,g.y),m.copy(y),i.update()}function xe(H){H.deltaY<0?N(R()):H.deltaY>0&&I(R()),i.update()}function Ae(H){let ue=!1;switch(H.code){case i.keys.UP:O(0,i.keyPanSpeed),ue=!0;break;case i.keys.BOTTOM:O(0,-i.keyPanSpeed),ue=!0;break;case i.keys.LEFT:O(i.keyPanSpeed,0),ue=!0;break;case i.keys.RIGHT:O(-i.keyPanSpeed,0),ue=!0;break}ue&&(H.preventDefault(),i.update())}function $e(){if(S.length===1)d.set(S[0].pageX,S[0].pageY);else{const H=.5*(S[0].pageX+S[1].pageX),ue=.5*(S[0].pageY+S[1].pageY);d.set(H,ue)}}function se(){if(S.length===1)m.set(S[0].pageX,S[0].pageY);else{const H=.5*(S[0].pageX+S[1].pageX),ue=.5*(S[0].pageY+S[1].pageY);m.set(H,ue)}}function ht(){const H=S[0].pageX-S[1].pageX,ue=S[0].pageY-S[1].pageY,Je=Math.sqrt(H*H+ue*ue);v.set(0,Je)}function Ie(){i.enableZoom&&ht(),i.enablePan&&se()}function at(){i.enableZoom&&ht(),i.enableRotate&&$e()}function je(H){if(S.length==1)f.set(H.pageX,H.pageY);else{const Je=Ke(H),yt=.5*(H.pageX+Je.x),pn=.5*(H.pageY+Je.y);f.set(yt,pn)}p.subVectors(f,d).multiplyScalar(i.rotateSpeed);const ue=i.domElement;M(2*Math.PI*p.x/ue.clientHeight),P(2*Math.PI*p.y/ue.clientHeight),d.copy(f)}function it(H){if(S.length===1)y.set(H.pageX,H.pageY);else{const ue=Ke(H),Je=.5*(H.pageX+ue.x),yt=.5*(H.pageY+ue.y);y.set(Je,yt)}g.subVectors(y,m).multiplyScalar(i.panSpeed),O(g.x,g.y),m.copy(y)}function qe(H){const ue=Ke(H),Je=H.pageX-ue.x,yt=H.pageY-ue.y,pn=Math.sqrt(Je*Je+yt*yt);_.set(0,pn),b.set(0,Math.pow(_.y/v.y,i.zoomSpeed)),I(b.y),v.copy(_)}function ce(H){i.enableZoom&&qe(H),i.enablePan&&it(H)}function ve(H){i.enableZoom&&qe(H),i.enableRotate&&je(H)}function be(H){i.enabled!==!1&&(S.length===0&&(i.domElement.setPointerCapture(H.pointerId),i.domElement.addEventListener("pointermove",Oe),i.domElement.addEventListener("pointerup",_e)),ye(H),H.pointerType==="touch"?pe(H):F(H))}function Oe(H){i.enabled!==!1&&(H.pointerType==="touch"?Se(H):me(H))}function _e(H){Pe(H),S.length===0&&(i.domElement.releasePointerCapture(H.pointerId),i.domElement.removeEventListener("pointermove",Oe),i.domElement.removeEventListener("pointerup",_e)),i.dispatchEvent(Eb),s=r.NONE}function z(H){Pe(H)}function F(H){let ue;switch(H.button){case 0:ue=i.mouseButtons.LEFT;break;case 1:ue=i.mouseButtons.MIDDLE;break;case 2:ue=i.mouseButtons.RIGHT;break;default:ue=-1}switch(ue){case ks.DOLLY:if(i.enableZoom===!1)return;X(H),s=r.DOLLY;break;case ks.ROTATE:if(H.ctrlKey||H.metaKey||H.shiftKey){if(i.enablePan===!1)return;J(H),s=r.PAN}else{if(i.enableRotate===!1)return;V(H),s=r.ROTATE}break;case ks.PAN:if(H.ctrlKey||H.metaKey||H.shiftKey){if(i.enableRotate===!1)return;V(H),s=r.ROTATE}else{if(i.enablePan===!1)return;J(H),s=r.PAN}break;default:s=r.NONE}s!==r.NONE&&i.dispatchEvent(vm)}function me(H){if(i.enabled!==!1)switch(s){case r.ROTATE:if(i.enableRotate===!1)return;W(H);break;case r.DOLLY:if(i.enableZoom===!1)return;Q(H);break;case r.PAN:if(i.enablePan===!1)return;re(H);break}}function le(H){i.enabled===!1||i.enableZoom===!1||s!==r.NONE||(H.preventDefault(),i.dispatchEvent(vm),xe(H),i.dispatchEvent(Eb))}function j(H){i.enabled===!1||i.enablePan===!1||Ae(H)}function pe(H){switch(Be(H),S.length){case 1:switch(i.touches.ONE){case Os.ROTATE:if(i.enableRotate===!1)return;$e(),s=r.TOUCH_ROTATE;break;case Os.PAN:if(i.enablePan===!1)return;se(),s=r.TOUCH_PAN;break;default:s=r.NONE}break;case 2:switch(i.touches.TWO){case Os.DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;Ie(),s=r.TOUCH_DOLLY_PAN;break;case Os.DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;at(),s=r.TOUCH_DOLLY_ROTATE;break;default:s=r.NONE}break;default:s=r.NONE}s!==r.NONE&&i.dispatchEvent(vm)}function Se(H){switch(Be(H),s){case r.TOUCH_ROTATE:if(i.enableRotate===!1)return;je(H),i.update();break;case r.TOUCH_PAN:if(i.enablePan===!1)return;it(H),i.update();break;case r.TOUCH_DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;ce(H),i.update();break;case r.TOUCH_DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;ve(H),i.update();break;default:s=r.NONE}}function De(H){i.enabled!==!1&&H.preventDefault()}function ye(H){S.push(H)}function Pe(H){delete w[H.pointerId];for(let ue=0;ue<S.length;ue++)if(S[ue].pointerId==H.pointerId){S.splice(ue,1);return}}function Be(H){let ue=w[H.pointerId];ue===void 0&&(ue=new Qt,w[H.pointerId]=ue),ue.set(H.pageX,H.pageY)}function Ke(H){const ue=H.pointerId===S[0].pointerId?S[1]:S[0];return w[ue.pointerId]}i.domElement.addEventListener("contextmenu",De),i.domElement.addEventListener("pointerdown",be),i.domElement.addEventListener("pointercancel",z),i.domElement.addEventListener("wheel",le,{passive:!1}),this.update()}}class vne extends aR{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=ks.PAN,this.mouseButtons.RIGHT=ks.ROTATE,this.touches.ONE=Os.PAN,this.touches.TWO=Os.DOLLY_ROTATE}}var xne=Object.freeze(Object.defineProperty({__proto__:null,OrbitControls:aR,MapControls:vne},Symbol.toStringTag,{value:"Module"})),_ne=Yb(xne),Ku={};(function(n){Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function i(r,s,o,a,l,c,u){this.pointIndices=r,this.labelStrings=s,this.scaleFactors=o,this.useSceneOpacityFlags=a,this.defaultFontSize=l,this.fillColors=c,this.strokeColors=u}return i}();n.LabelRenderParams=e,function(i){i[i.Perspective=0]="Perspective",i[i.Orthographic=1]="Orthographic"}(n.CameraType||(n.CameraType={}));var t=function(){function i(r,s,o,a,l,c,u,h,d,f,p,m,y,g){this.camera=r,this.cameraType=s,this.cameraTarget=o,this.screenWidth=a,this.screenHeight=l,this.nearestCameraSpacePointZ=c,this.farthestCameraSpacePointZ=u,this.backgroundColor=h,this.pointColors=d,this.pointScaleFactors=f,this.labels=p,this.polylineColors=m,this.polylineOpacities=y,this.polylineWidths=g}return i}();n.RenderContext=t})(Ku);var wn={};Object.defineProperty(wn,"__esModule",{value:!0});var br=Ta;function bne(n,e,t,i){var r=window.devicePixelRatio,s=new br.Vector3().copy(i).project(n),o=[(s.x+1)/2*e*r,-((s.y-1)/2*t)*r];return o}wn.vector3DToScreenCoords=bne;function wne(n,e){var t=e*3;return new br.Vector3(n[t],n[t+1],n[t+2])}wn.vector3FromPackedArray=wne;function Sne(n,e,t){for(var i=1/0,r=0,s=new br.Vector3().copy(t).sub(e),o=new br.Vector3().copy(s).normalize(),a=n.length/3,l=0,c=new br.Vector3,u=new br.Vector3,h=0;h<a;h++){c.x=n[l],c.y=n[l+1],c.z=n[l+2],l+=3,u.copy(c).sub(e);var d=o.dot(u);d<0||(r=d>r?d:r,i=d<i?d:i)}return[i,r]}wn.getNearFarPoints=Sne;function lR(n,e){return e===void 0&&(e=!0),n.needsUpdate=e,n.minFilter=br.LinearFilter,n.generateMipmaps=!1,n.flipY=!1,n}function Tne(n){var e=new br.Texture(n);return lR(e)}wn.createTextureFromCanvas=Tne;function Ene(n,e){var t=new br.Texture(n);return n.complete?(t.needsUpdate=!0,e()):n.onload=function(){t.needsUpdate=!0,e()},lR(t,!1)}wn.createTextureFromImage=Ene;function Cne(){try{var n=document.createElement("canvas"),e=n.getContext("webgl")||n.getContext("experimental-webgl");return e!=null}catch{return!1}}wn.hasWebGLSupport=Cne;function Mne(n){for(var e=1/0,t=-1/0,i=0;i<n.length;i++){var r=n[i];r<e&&(e=r),r>t&&(t=r)}return[e,t]}wn.extent=Mne;function Ane(n,e,t){var i=e[1]-e[0],r=t[1]-t[0],s=(n-e[0])/i;return s*r+t[0]}wn.scaleLinear=Ane;function Rne(n,e,t){var i=Math.pow(e[1],Math.E)-Math.pow(e[0],Math.E),r=t[1]-t[0],s=(Math.pow(n,Math.E)-e[0])/i;return s*r+t[0]}wn.scaleExponential=Rne;function Ine(n,e,t,i,r){n[e*3]=t,n[e*3+1]=i,n[e*3+2]=r}wn.packRgbIntoUint8Array=Ine;function Pne(n){var e=new br.Color(n);return[e.r*255|0,e.g*255|0,e.b*255|0]}wn.styleRgbFromHexColor=Pne;var Cb=function(n){return 100*n+"%"};function Nne(n,e,t,i,r,s){var o=t+(i-t)*n/e,a="hsl("+o+", "+Cb(r)+", "+Cb(s)+")";return new br.Color(a)}wn.getDefaultPointInPolylineColor=Nne;var Iv={};Object.defineProperty(Iv,"__esModule",{value:!0});var Lne=function(){function n(e,t,i){this.startCoordinates=[0,0],this.svgElement=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgElement.style.display="none",this.svgElement.style.height="100%",this.svgElement.style.width="100%",this.svgElement.style.position="absolute",e.insertAdjacentElement("afterbegin",this.svgElement),this.rectElement=document.createElementNS("http://www.w3.org/2000/svg","rect"),this.rectElement.style.stroke=i.select.stroke,this.rectElement.style.strokeDasharray=i.select.strokeDashArray,this.rectElement.style.strokeWidth=""+i.select.strokeWidth,this.rectElement.style.fill=i.select.fill,this.rectElement.style.fillOpacity=""+i.select.fillOpacity,this.svgElement.appendChild(this.rectElement),this.selectionCallback=t,this.isMouseDown=!1}return n.prototype.onMouseDown=function(e,t){this.isMouseDown=!0,this.rectElement.style.display="block",this.svgElement.style.display="block",this.startCoordinates=[e,t],this.lastBoundingBox={x:this.startCoordinates[0],y:this.startCoordinates[1],width:1,height:1}},n.prototype.onMouseMove=function(e,t){!this.isMouseDown||(this.lastBoundingBox.x=Math.min(e,this.startCoordinates[0]),this.lastBoundingBox.y=Math.max(t,this.startCoordinates[1]),this.lastBoundingBox.width=Math.max(e,this.startCoordinates[0])-this.lastBoundingBox.x,this.lastBoundingBox.height=this.lastBoundingBox.y-Math.min(t,this.startCoordinates[1]),this.rectElement.setAttribute("x",""+this.lastBoundingBox.x),this.rectElement.setAttribute("y",""+(this.lastBoundingBox.y-this.lastBoundingBox.height)),this.rectElement.setAttribute("width",""+this.lastBoundingBox.width),this.rectElement.setAttribute("height",""+this.lastBoundingBox.height))},n.prototype.onMouseUp=function(){this.isMouseDown=!1,this.svgElement.style.display="none",this.rectElement.style.display="none",this.rectElement.setAttribute("width","0"),this.rectElement.setAttribute("height","0"),this.selectionCallback(this.lastBoundingBox)},n}();Iv.ScatterPlotRectangleSelector=Lne;var bf=It&&It.__assign||function(){return bf=Object.assign||function(n){for(var e,t=1,i=arguments.length;t<i;t++){e=arguments[t];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r])}return n},bf.apply(this,arguments)},xm=It&&It.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var i=t.call(n),r,s=[],o;try{for(;(e===void 0||e-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(a){o={error:a}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return s},Mb=It&&It.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],i=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&i>=n.length&&(n=void 0),{value:n&&n[i++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Zy,"__esModule",{value:!0});var St=Ta,Dne=_ne,_m=Ku,kne=wn,One=Iv,cR=2,Fne=5*cR,$ne=.025*cR,Bne=70,zne=.01,Une=100,nd=1.2,Ab="Shift",Rb="Control",Vne=new St.Vector3(.45,.9,1.6),Gne=new St.Vector3(0,0,0),Hne=new St.Vector3(0,0,4),Wne=new St.Vector3(0,0,0),jne={mouseRotateSpeed:1,autoRotateSpeed:2,zoomSpeed:.125},qne=function(){function n(e,t){var i=this;this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.selectEnabled=!0,this.visualizers=new Map,this.onCameraMoveListeners=[],this.height=0,this.width=0,this.dimensions=3,this.interactionMode="PAN",this.pickingTexture=new St.WebGLRenderTarget(0,0),this.orbitAnimationOnNextCameraCreation=!1,this.orbitAnimationId=null,this.worldSpacePointPositions=new Float32Array(0),this.pointColors=new Float32Array(0),this.pointScaleFactors=new Float32Array(0),this.polylineColors={},this.polylineOpacities=new Float32Array(0),this.polylineWidths=new Float32Array(0),this.selecting=!1,this.nearestPoint=null,this.mouseIsDown=!1,this.isDragSequence=!1,this.lastHovered=null,this.container=e,this.styles=t.styles,this.setParameters(t),this.computeLayoutValues(),this.scene=new St.Scene,this.renderer=new St.WebGLRenderer({alpha:!0,premultipliedAlpha:!1,antialias:!1}),this.renderer.setClearColor(this.styles.backgroundColor,1),this.container.appendChild(this.renderer.domElement),this.light=new St.PointLight(16772287,1,0),this.scene.add(this.light),this.orbitControlParams=bf(bf({},jne),t.orbitControlParams),this.rectangleSelector=new One.ScatterPlotRectangleSelector(this.container,function(r){i.selectBoundingBox(r)},this.styles),this.addInteractionListeners(),this.setDimensions(3),this.makeCamera(t.camera),this.resize()}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled)},n.prototype.addInteractionListeners=function(){this.container.addEventListener("pointermove",this.onMouseMove.bind(this)),this.container.addEventListener("pointerdown",this.onMouseDown.bind(this)),this.container.addEventListener("pointerup",this.onMouseUp.bind(this)),this.container.addEventListener("click",this.onClick.bind(this)),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1)},n.prototype.addCameraControlsEventListeners=function(e){var t=this;e.addEventListener("start",function(){t.stopOrbitAnimation(),t.onCameraMoveListeners.forEach(function(i){return i(t.camera.position,e.target)})}),e.addEventListener("change",function(){t.render()}),e.addEventListener("end",function(){})},n.prototype.makeOrbitControls=function(e,t){this.orbitCameraControls!=null&&this.orbitCameraControls.dispose();var i=new Dne.OrbitControls(e,this.renderer.domElement);i.zoomSpeed=this.orbitControlParams.zoomSpeed,i.enableRotate=t,i.autoRotate=!1,i.enableKeys=!1,i.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,t?(i.mouseButtons.LEFT=St.MOUSE.LEFT,i.mouseButtons.RIGHT=St.MOUSE.RIGHT):(i.mouseButtons.LEFT=St.MOUSE.RIGHT,i.mouseButtons.RIGHT=St.MOUSE.LEFT),i.reset(),this.camera=e,this.orbitCameraControls=i,this.addCameraControlsEventListeners(this.orbitCameraControls)},n.prototype.makeCamera=function(e){e===void 0&&(e={});var t=this.makeDefaultCameraDef(this.dimensions,e);this.recreateCamera(t),this.dimensions===3&&this.styles.axesVisible?this.add3dAxes():this.remove3dAxesFromScene()},n.prototype.makeCamera3D=function(e,t,i){var r;{var s=t/i;r=new St.PerspectiveCamera(Bne,s,zne,Une),r.position.set(e.position[0],e.position[1],e.position[2]);var o=new St.Vector3(e.target[0],e.target[1],e.target[2]);r.lookAt(o),r.zoom=e.zoom,r.updateProjectionMatrix()}this.camera=r,this.makeOrbitControls(r,!0)},n.prototype.makeCamera2D=function(e,t,i){var r,s=new St.Vector3(e.target[0],e.target[1],e.target[2]);{var o=t/i,a=-nd,l=nd,c=-nd,u=nd;o>1?(a*=o,l*=o):(u/=o,c/=o),r=new St.OrthographicCamera(a,l,u,c,-1e3,1e3),r.position.set(e.position[0],e.position[1],e.position[2]),r.up=new St.Vector3(0,0,1),r.lookAt(s),r.zoom=e.zoom,r.updateProjectionMatrix()}this.camera=r,this.makeOrbitControls(r,!1)},n.prototype.makeDefaultCameraDef=function(e,t){t===void 0&&(t={});var i=e===2,r=i?Hne:Vne,s=i?Wne:Gne,o={orthographic:i,zoom:1,position:[r.x,r.y,r.z],target:[s.x,s.y,s.z]};return t.zoom&&(o.zoom=t.zoom),t.position&&(o.position=t.position),t.target&&(o.target=t.target),o},n.prototype.recreateCamera=function(e){e.orthographic?this.makeCamera2D(e,this.width,this.height):this.makeCamera3D(e,this.width,this.height),this.orbitCameraControls.minDistance=$ne,this.orbitCameraControls.maxDistance=Fne,this.orbitCameraControls.update(),this.orbitAnimationOnNextCameraCreation&&this.startOrbitAnimation()},n.prototype.setInteractionMode=function(e){this.interactionMode=e,e==="SELECT"?(this.selecting=!0,this.container.style.cursor="crosshair",this.orbitCameraControls.enabled=!1):(this.selecting=!1,this.container.style.cursor="default",this.orbitCameraControls.enabled=!0)},n.prototype.onClick=function(e,t){if(t===void 0&&(t=!0),!(e&&this.selecting)){if(!this.isDragSequence&&t){if(this.selectEnabled){var i=this.nearestPoint!=null?[this.nearestPoint]:[];this.selectCallback(i)}this.clickCallback(this.nearestPoint)}this.isDragSequence=!1,this.render()}},n.prototype.onMouseDown=function(e){this.isDragSequence=!1,this.mouseIsDown=!0,this.selecting?(this.rectangleSelector.onMouseDown(e.offsetX,e.offsetY),this.setNearestPointToMouse(e)):!e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===St.MOUSE.RIGHT?(this.orbitCameraControls.mouseButtons.ORBIT=St.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=St.MOUSE.RIGHT):e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===St.MOUSE.LEFT&&(this.orbitCameraControls.mouseButtons.ORBIT=St.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=St.MOUSE.LEFT)},n.prototype.onMouseUp=function(e){this.selecting&&(this.rectangleSelector.onMouseUp(),this.render()),this.mouseIsDown=!1},n.prototype.onMouseMove=function(e){this.isDragSequence=this.mouseIsDown,this.selecting&&this.mouseIsDown?(this.rectangleSelector.onMouseMove(e.offsetX,e.offsetY),this.render()):this.mouseIsDown||(this.setNearestPointToMouse(e),this.nearestPoint!=this.lastHovered&&(this.lastHovered=this.nearestPoint,this.hoverCallback(this.nearestPoint)))},n.prototype.onKeyDown=function(e){e.key===Rb&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=St.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=St.MOUSE.LEFT),e.key===Ab&&this.selectEnabled&&(this.selecting=!0,this.orbitCameraControls.enabled=!1,this.container.style.cursor="crosshair")},n.prototype.onKeyUp=function(e){e.key===Rb&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=St.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=St.MOUSE.RIGHT),e.key===Ab&&this.selectEnabled&&(this.selecting=!1,this.orbitCameraControls.enabled=!0,this.container.style.cursor="default",this.render())},n.prototype.getPointIndicesFromBoundingBox=function(e){if(this.worldSpacePointPositions==null)return[];this.camera.updateMatrixWorld();var t=window.devicePixelRatio||1,i=Math.floor(e.x*t),r=Math.floor(e.y*t),s=Math.max(Math.floor(e.width*t),1),o=Math.max(Math.floor(e.height*t),1);if(s<=2&&o<=2)return this.getPointIndicesFromBoundingBoxPickingTexture(e);for(var a=this.renderer.domElement,l=a.width,c=a.height,u=[],h=new St.Vector3,d=0;d<this.worldSpacePointPositions.length;d++){var f=d*3,p=xm(this.worldSpacePointPositions.slice(f,f+3),3),m=p[0],y=p[1],g=p[2];h.x=m,h.y=y,h.z=g;var v=h.project(this.camera),_=(v.x+1)*l/2,b=-(v.y-1)*c/2;_>=i&&_<=i+s&&b<=r&&b>=r-o&&u.push(d)}return u},n.prototype.getPointIndicesFromBoundingBoxPickingTexture=function(e){if(this.worldSpacePointPositions==null)return[];var t=this.worldSpacePointPositions.length/3,i=window.devicePixelRatio||1,r=Math.floor(e.x*i),s=Math.floor(e.y*i),o=Math.max(Math.floor(e.width*i),1),a=Math.max(Math.floor(e.height*i),1),l=new Uint8Array(o*a*4);this.renderer.readRenderTargetPixels(this.pickingTexture,r,this.pickingTexture.height-s,o,a,l);for(var c=new Uint8Array(this.worldSpacePointPositions.length),u=0;u<o*a;u++){var h=l[u*4]<<16|l[u*4+1]<<8|l[u*4+2];h!==16777215&&h<t&&(c[h]=1)}for(var d=[],u=0;u<c.length;u++)c[u]===1&&d.push(u);return d},n.prototype.selectBoundingBox=function(e){var t=this.getPointIndicesFromBoundingBox(e);this.selectCallback(t)},n.prototype.setNearestPointToMouse=function(e){if(this.pickingTexture==null){this.nearestPoint=null;return}var t={x:e.offsetX,y:e.offsetY,width:1,height:1},i=this.getPointIndicesFromBoundingBoxPickingTexture(t);this.nearestPoint=i.length?i[0]:null},n.prototype.computeLayoutValues=function(){return this.width=this.container.offsetWidth,this.height=Math.max(1,this.container.offsetHeight),[this.width,this.height]},n.prototype.sceneIs3D=function(){return this.dimensions===3},n.prototype.remove3dAxesFromScene=function(){var e=this.scene.getObjectByName("axes");return e!=null&&this.scene.remove(e),e},n.prototype.add3dAxes=function(){var e=new St.AxesHelper;e.name="axes",this.scene.add(e)},n.prototype.setDimensions=function(e){if(e!==2&&e!==3)throw new RangeError("dimensions must be 2 or 3");this.dimensions!==e&&(this.dimensions=e,this.makeCamera())},n.prototype.getCameraPosition=function(){var e=this.camera.position;return[e.x,e.y,e.z]},n.prototype.getCameraTarget=function(){var e=this.orbitCameraControls.target;return[e.x,e.y,e.z]},n.prototype.setCameraPositionAndTarget=function(e,t){this.stopOrbitAnimation(),this.camera.position.set(e[0],e[1],e[2]),this.orbitCameraControls.target.set(t[0],t[1],t[2]),this.orbitCameraControls.update(),this.render()},n.prototype.startOrbitAnimation=function(){!this.sceneIs3D()||(this.orbitAnimationId!=null&&this.stopOrbitAnimation(),this.orbitCameraControls.autoRotate=!0,this.orbitCameraControls.autoRotateSpeed=this.orbitControlParams.autoRotateSpeed,this.updateOrbitAnimation())},n.prototype.orbitIsAnimating=function(){return this.orbitAnimationId!=null},n.prototype.updateOrbitAnimation=function(){var e=this;this.orbitCameraControls.update(),this.orbitAnimationId=requestAnimationFrame(function(){return e.updateOrbitAnimation()})},n.prototype.stopOrbitAnimation=function(){this.orbitCameraControls.autoRotate=!1,this.orbitCameraControls.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,this.orbitAnimationId!=null&&(cancelAnimationFrame(this.orbitAnimationId),this.orbitAnimationId=null)},n.prototype.setActiveVisualizers=function(e){var t,i,r,s,o=new Set(e.map(function(d){return d.id}));try{for(var a=Mb(this.visualizers.values()),l=a.next();!l.done;l=a.next()){var c=l.value;o.has(c.id)||(c.dispose(),this.visualizers.delete(c.id))}}catch(d){t={error:d}}finally{try{l&&!l.done&&(i=a.return)&&i.call(a)}finally{if(t)throw t.error}}try{for(var u=Mb(e),h=u.next();!h.done;h=u.next()){var c=h.value;this.visualizers.set(c.id,c),c.setScene(this.scene),c.onResize(this.width,this.height),this.worldSpacePointPositions&&c.onPointPositionsChanged(this.worldSpacePointPositions)}}catch(d){r={error:d}}finally{try{h&&!h.done&&(s=u.return)&&s.call(u)}finally{if(r)throw r.error}}},n.prototype.disposeAllVisualizers=function(){this.visualizers.forEach(function(e){return e.dispose()}),this.visualizers.clear()},n.prototype.setPointPositions=function(e){this.worldSpacePointPositions=e,this.visualizers.forEach(function(t){return t.onPointPositionsChanged(e)})},n.prototype.render=function(){{var e=this.camera.position.clone();e.x+=1,e.y+=1,this.light.position.set(e.x,e.y,e.z)}var t=this.camera instanceof St.PerspectiveCamera?_m.CameraType.Perspective:_m.CameraType.Orthographic,i=[0,0];this.worldSpacePointPositions!=null&&(i=kne.getNearFarPoints(this.worldSpacePointPositions,this.camera.position,this.orbitCameraControls.target));var r=new _m.RenderContext(this.camera,t,this.orbitCameraControls.target,this.width,this.height,i[0],i[1],this.styles.backgroundColor,this.pointColors,this.pointScaleFactors,this.labels,this.polylineColors,this.polylineOpacities,this.polylineWidths);this.visualizers.forEach(function(o){return o.onPickingRender(r)});{var s=this.remove3dAxesFromScene();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.render(this.scene,this.camera),s!=null&&this.scene.add(s)}this.visualizers.forEach(function(o){return o.onRender(r)}),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)},n.prototype.setPointColors=function(e){this.pointColors=e},n.prototype.setPointScaleFactors=function(e){this.pointScaleFactors=e},n.prototype.setLabels=function(e){this.labels=e},n.prototype.setPolylineColors=function(e){this.polylineColors=e},n.prototype.setPolylineOpacities=function(e){this.polylineOpacities=e},n.prototype.setPolylineWidths=function(e){this.polylineWidths=e},n.prototype.resetZoom=function(){this.recreateCamera(this.makeDefaultCameraDef(this.dimensions)),this.render()},n.prototype.setDayNightMode=function(e){for(var t=this.container.querySelectorAll("canvas"),i=e?"invert(100%)":"",r=0;r<t.length;r++)t[r].style.filter=i},n.prototype.resize=function(e){e===void 0&&(e=!0);var t=xm([this.width,this.height],2),i=t[0],r=t[1],s=xm(this.computeLayoutValues(),2),o=s[0],a=s[1];if(this.dimensions===3){var l=this.camera;l.aspect=o/a,l.updateProjectionMatrix()}else{var l=this.camera,c=o/i,u=a/r,h=(l.right-l.left)*c/2,d=(l.top-l.bottom)*u/2;l.top=d,l.bottom=-d,l.left=-h,l.right=h,l.updateProjectionMatrix()}var f=window.devicePixelRatio||1;this.renderer.setPixelRatio(f),this.renderer.setSize(o,a);{var p=new St.Vector2;this.renderer.getSize(p);var m=this.renderer.getPixelRatio();this.pickingTexture=new St.WebGLRenderTarget(p.width*m,p.height*m),this.pickingTexture.texture.minFilter=St.LinearFilter}this.visualizers.forEach(function(y){return y.onResize(o,a)}),e&&this.render()},n.prototype.onCameraMove=function(e){this.onCameraMoveListeners.push(e)},n.prototype.clickOnPoint=function(e){this.nearestPoint=e,this.onClick(null,!1)},n}();Zy.ScatterPlot=qne;var Pv={},Xne=It&&It.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var i=t.call(n),r,s=[],o;try{for(;(e===void 0||e-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(a){o={error:a}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return s};Object.defineProperty(Pv,"__esModule",{value:!0});var Yne=Ta,bm=new Map,Kne=/^(rgba|hsla)\((\d+),\s*(\d+%?),\s*(\d+%?)(?:,\s*(\d+(?:\.\d+)?))?\)$/;function Zne(n){var e=Kne.exec(n);if(e){var t=Xne(e,6);t[0];var i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=i.replace("a","")+"("+r+","+s+","+o+")";return{colorString:l,opacity:parseFloat(a)}}return{colorString:n,opacity:1}}function Jne(n){if(bm.has(n))return bm.get(n);var e=Zne(n),t=e.colorString,i=e.opacity,r=new Yne.Color(t),s=r.r,o=r.g,a=r.b,l={r:s,g:o,b:a,opacity:i};return bm.set(n,l),l}Pv.parseColor=Jne;var Qf={},Qne=It&&It.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],i=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&i>=n.length&&(n=void 0),{value:n&&n[i++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Qf,"__esModule",{value:!0});var Ib="Points must be an array of either 2 or 3 dimensional number arrays",eie=function(){function n(e,t){var i,r;t===void 0&&(t=[]),this.points=e,this.metadata=t;var s=e[0].length;if(!(s===2||s===3))throw new Error(Ib);try{for(var o=Qne(e),a=o.next();!a.done;a=o.next()){var l=a.value;if(s!==l.length)throw new Error(Ib)}}catch(c){i={error:c}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}this.dimensions=s}return n.prototype.setSpriteMetadata=function(e){this.spriteMetadata=e},n}();Qf.Dataset=eie;var Nv={};Object.defineProperty(Nv,"__esModule",{value:!0});var tie=function(){var n={backgroundColor:"#ffffff",axesVisible:!0,fog:{color:"#ffffff",enabled:!0,threshold:5e3},label:{fontSize:10,scaleDefault:1,scaleLarge:2,fillColorSelected:"#000000",fillColorHover:"#000000",strokeColorSelected:"#ffffff",strokeColorHover:"#ffffff",strokeWidth:3,fillWidth:6},label3D:{fontSize:80,scale:2.2,color:"black",backgroundColor:"#ffffff",colorUnselected:"#ffffff",colorNoSelection:"#ffffff"},point:{colorUnselected:"rgba(227, 227, 227, 0.7)",colorNoSelection:"rgba(117, 117, 217, 0.7)",colorSelected:"rgba(250, 102, 102, 0.7)",colorHover:"rgba(118, 11, 79, 0.7)",scaleDefault:1,scaleSelected:1.2,scaleHover:1.2},polyline:{startHue:60,endHue:360,saturation:1,lightness:.3,defaultOpacity:.2,defaultLineWidth:2,selectedOpacity:.9,selectedLineWidth:3,deselectedOpacity:.05},select:{fill:"#dddddd",fillOpacity:.2,stroke:"#aaaaaa",strokeWidth:2,strokeDashArray:"10 5"},sprites:{minPointSize:5,imageSize:30,colorUnselected:"#ffffff",colorNoSelection:"#ffffff"}};return n};function nie(n){var e=tie();if(n===void 0)return e;for(var t in e){var i=t;typeof e[i]=="object"&&typeof n[i]=="object"?e[i]=Object.assign(e[i],n[i]):n[i]!==void 0&&(e[i]=n[i])}return e}Nv.makeStyles=nie;var Nr={};Object.defineProperty(Nr,"__esModule",{value:!0});Nr.RGB_NUM_ELEMENTS=3;Nr.RGBA_NUM_ELEMENTS=4;Nr.XYZ_NUM_ELEMENTS=3;Nr.UV_NUM_ELEMENTS=2;Nr.INDEX_NUM_ELEMENTS=1;Nr.SCATTER_PLOT_CUBE_LENGTH=2;var Lv={};Object.defineProperty(Lv,"__esModule",{value:!0});var rs=Ta,Pb=wn,Tn=Nr,wm=8192,Sm=256,Qn=2*3,iie=function(n,e){return`
      attribute vec2 posObj;
      attribute vec4 color;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        vUv = uv;
        vColor = color;

        // Rotate label to face camera.

        vec4 vRight = vec4(
          modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);

        vec4 vUp = vec4(
          modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);

        vec4 vAt = -vec4(
          modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);

        mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));

        vec2 scaledPos = posObj * `+1/n+" * "+e+`;

        vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);
        vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);
        gl_Position = projectionMatrix * mvPosition;
      }`},rie=`
      uniform sampler2D glyphTexture;
      uniform bool picking;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        if (picking) {
          gl_FragColor = vColor;
        } else {
          vec4 fromTexture = texture(glyphTexture, vUv);
          gl_FragColor = vColor * fromTexture;
        }
      }`,sie=function(){function n(e){this.styles=e,this.id="3D_LABELS",this.labelStrings=[],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.uniforms={},this.totalVertexCount=0,this.labelVertexMap=[]}return n.prototype.createGlyphTexture=function(){var e=this.styles.label3D,t=e.fontSize,i=e.backgroundColor,r=e.color,s=document.createElement("canvas");s.width=wm,s.height=t;var o=s.getContext("2d");o.font="bold "+t+"px roboto",o.textBaseline="top",o.fillStyle=i,o.rect(0,0,s.width,s.height),o.fill(),o.fillStyle=r;for(var a=o.measureText(" ").width,l=new Float32Array(Sm),c=new Float32Array(Sm),u=0,h=0;h<Sm;h++){var d=" "+String.fromCharCode(h),f=o.measureText(d).width;l[h]=f-a,c[h]=u,o.fillText(d,u-a,0),u+=f}var p=Pb.createTextureFromCanvas(s);return{texture:p,lengths:l,offsets:c}},n.prototype.processLabelVerts=function(e){var t=0;this.labelVertexMap=[];for(var i=0;i<e;i++){for(var r=this.labelStrings[i],s=[],o=0;o<r.length;o++){for(var a=0;a<Qn;a++)s.push(t*Qn+a);t++}this.labelVertexMap.push(s)}this.totalVertexCount=t*Qn},n.prototype.createColorBuffers=function(e){var t=this;this.pickingColors=new Float32Array(this.totalVertexCount*Tn.RGB_NUM_ELEMENTS),this.renderColors=new Float32Array(this.totalVertexCount*Tn.RGB_NUM_ELEMENTS);for(var i=function(o){var a=new rs.Color(o);r.labelVertexMap[o].forEach(function(l){t.pickingColors[Tn.RGB_NUM_ELEMENTS*l]=a.r,t.pickingColors[Tn.RGB_NUM_ELEMENTS*l+1]=a.g,t.pickingColors[Tn.RGB_NUM_ELEMENTS*l+2]=a.b,t.renderColors[Tn.RGB_NUM_ELEMENTS*l]=1,t.renderColors[Tn.RGB_NUM_ELEMENTS*l+1]=1,t.renderColors[Tn.RGB_NUM_ELEMENTS*l+2]=1})},r=this,s=0;s<e;s++)i(s)},n.prototype.createLabels=function(){var e=this,t=this.styles.label3D,i=t.fontSize,r=t.scale;if(!(this.labelStrings==null||this.worldSpacePointPositions==null)){var s=this.worldSpacePointPositions.length/Tn.XYZ_NUM_ELEMENTS;if(s===this.labelStrings.length){this.glyphTexture=this.createGlyphTexture(),this.uniforms={glyphTexture:{value:null},picking:{value:!1}},this.material=new rs.ShaderMaterial({uniforms:this.uniforms,transparent:!0,vertexShader:iie(i,r),fragmentShader:rie}),this.processLabelVerts(s),this.createColorBuffers(s);var o=new Float32Array(this.totalVertexCount*Tn.XYZ_NUM_ELEMENTS);this.positions=new rs.BufferAttribute(o,Tn.XYZ_NUM_ELEMENTS);var a=new Float32Array(this.totalVertexCount*Tn.XYZ_NUM_ELEMENTS),l=new Float32Array(this.totalVertexCount*Tn.UV_NUM_ELEMENTS),c=new Float32Array(this.totalVertexCount*Tn.RGB_NUM_ELEMENTS),u=new rs.BufferAttribute(a,2),h=new rs.BufferAttribute(l,Tn.UV_NUM_ELEMENTS),d=new rs.BufferAttribute(c,Tn.RGB_NUM_ELEMENTS);this.geometry=new rs.BufferGeometry,this.geometry.setAttribute("posObj",u),this.geometry.setAttribute("position",this.positions),this.geometry.setAttribute("uv",h),this.geometry.setAttribute("color",d);for(var f=0,p=0;p<s;p++){for(var m=this.labelStrings[p],y=0,g=0;g<m.length;g++){var v=m.charCodeAt(g);y+=this.glyphTexture.lengths[v]}y/=-2;for(var g=0;g<m.length;g++){var v=m.charCodeAt(g),_=this.glyphTexture.lengths[v],b=i,S=(y+_)/b,w=y/b,T=i/b;u.setXY(f*Qn+0,w,0),u.setXY(f*Qn+1,S,0),u.setXY(f*Qn+2,w,T),u.setXY(f*Qn+3,w,T),u.setXY(f*Qn+4,S,0),u.setXY(f*Qn+5,S,T);var R=this.glyphTexture.offsets[v],M=this.glyphTexture.offsets[v]+_;R/=wm,M/=wm;var P=1,L=0;h.setXY(f*Qn+0,R,P),h.setXY(f*Qn+1,M,P),h.setXY(f*Qn+2,R,L),h.setXY(f*Qn+3,R,L),h.setXY(f*Qn+4,M,P),h.setXY(f*Qn+5,M,L),f++,y+=_}}for(var $=function(I){var N=Pb.vector3FromPackedArray(O.worldSpacePointPositions,I);O.labelVertexMap[I].forEach(function(V){e.positions.setXYZ(V,N.x,N.y,N.z)})},O=this,p=0;p<s;p++)$(p);this.labelsMesh=new rs.Mesh(this.geometry,this.material),this.labelsMesh.frustumCulled=!1,this.scene.add(this.labelsMesh)}}},n.prototype.colorLabels=function(e){if(!(this.labelStrings==null||this.geometry==null||e==null)){var t=this.geometry.getAttribute("color");t.array=this.renderColors;for(var i=e.length/Tn.RGBA_NUM_ELEMENTS,r=0,s=0;s<i;++s){for(var o=new rs.Color(e[r],e[r+1],e[r+2]),a=this.labelVertexMap[s].length,l=0;l<a;++l)t.setXYZ(this.labelVertexMap[s][l],o.r,o.g,o.b);r+=Tn.RGBA_NUM_ELEMENTS}t.needsUpdate=!0}},n.prototype.setScene=function(e){this.scene=e},n.prototype.dispose=function(){this.labelsMesh&&(this.scene&&this.scene.remove(this.labelsMesh),this.labelsMesh=null),this.geometry&&(this.geometry.dispose(),this.geometry=null),this.glyphTexture!=null&&this.glyphTexture.texture!=null&&(this.glyphTexture.texture.dispose(),this.glyphTexture.texture=null)},n.prototype.onPickingRender=function(e){if(this.geometry==null){this.createLabels();return}this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!0;var t=this.geometry.getAttribute("color");t.array=this.pickingColors,t.needsUpdate=!0},n.prototype.onRender=function(e){if(this.geometry==null){this.createLabels();return}this.colorLabels(e.pointColors),this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!1;var t=this.geometry.getAttribute("color");t.array=this.renderColors,t.needsUpdate=!0},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.dispose()},n.prototype.setLabelStrings=function(e){this.labelStrings=e,this.dispose()},n.prototype.onResize=function(e,t){},n}();Lv.ScatterPlotVisualizer3DLabels=sie;var Dv={};Object.defineProperty(Dv,"__esModule",{value:!0});var Un=Ta,oie=Ku,Nb=wn,Fi=Nr,Lb=function(n){return`
    // Index of the specific vertex (passed in as bufferAttribute), and the
    // variable that will be used to pass it to the fragment shader.
    attribute float spriteIndex;
    attribute vec4 color;
    attribute float scaleFactor;

    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform bool sizeAttenuation;
    uniform float pointSize;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;

    varying float fogDepth;

    void main() {
      // Pass index and color values to fragment shader.
      vColor = color;
      xyIndex = vec2(mod(spriteIndex, spritesPerRow),
                floor(spriteIndex / spritesPerColumn));

      // Transform current vertex by modelViewMatrix (model world position and
      // camera world position matrix).
      vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);

      // Project vertex in camera-space to screen coordinates using the camera's
      // projection matrix.
      gl_Position = projectionMatrix * cameraSpacePos;

      // Create size attenuation (if we're in 3D mode) by making the size of
      // each point inversly proportional to its distance to the camera.
      float outputPointSize = pointSize;
      if (sizeAttenuation) {
        outputPointSize = -pointSize / cameraSpacePos.z;
        fogDepth = pointSize / outputPointSize * 1.2;
      } else {  // Create size attenuation (if we're in 2D mode)
        const float PI = 3.1415926535897932384626433832795;
        const float minScale = 0.1;  // minimum scaling factor
        const float outSpeed = 2.0;  // shrink speed when zooming out
        const float outNorm = (1. - minScale) / atan(outSpeed);
        const float maxScale = 15.0;  // maximum scaling factor
        const float inSpeed = 0.02;  // enlarge speed when zooming in
        const float zoomOffset = 0.3;  // offset zoom pivot
        float zoom = projectionMatrix[0][0] + zoomOffset;  // zoom pivot
        float scale = zoom < 1. ? 1. + outNorm * atan(outSpeed * (zoom - 1.)) :
                      1. + 2. / PI * (maxScale - 1.) * atan(inSpeed * (zoom - 1.));
        outputPointSize = pointSize * scale;
      }

      gl_PointSize =
        max(outputPointSize * scaleFactor, `+n.toFixed(1)+`);
    }`},uR=`
    bool point_in_unit_circle(vec2 spriteCoord) {
      vec2 centerToP = spriteCoord - vec2(0.5, 0.5);
      return dot(centerToP, centerToP) < (0.5 * 0.5);
    }

    bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {
      vec3 v0 = vec3(0, 1, 0);
      vec3 v1 = vec3(0.5, 0, 0);
      vec3 v2 = vec3(1, 1, 0);
      vec3 p = vec3(spriteCoord, 0);
      float p_in_v0_v1 = cross(v1 - v0, p - v0).z;
      float p_in_v1_v2 = cross(v2 - v1, p - v1).z;
      return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);
    }

    bool point_in_unit_square(vec2 spriteCoord) {
      return true;
    }
  `,aie=`
    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform sampler2D spriteTexture;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;
    uniform bool isImage;

    `+Un.ShaderChunk.common+`
    `+uR+`
    uniform vec3 fogColor;
    varying float fogDepth;
		uniform float fogNear;
    uniform float fogFar;

    void main() {
      if (isImage) {
        // Coordinates of the vertex within the entire sprite image.
        vec2 coords =
          (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);
        gl_FragColor = vColor * texture(spriteTexture, coords);
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
      float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    }`,lie=`
    varying vec2 xyIndex;
    varying vec4 vColor;
    uniform bool isImage;

    `+uR+`

    varying float fogDepth;

    void main() {
      xyIndex; // Silence 'unused variable' warning.
      fogDepth; // Silence 'unused variable' warning.
      if (isImage) {
        gl_FragColor = vColor;
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
    }`,cie=function(){function n(e,t){this.styles=e,this.id="SPRITES",this.isSpriteSheetMode=!1,this.spritesPerRow=0,this.spritesPerColumn=0,this.spriteDimensions=[0,0],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.standinTextureForPoints=Nb.createTextureFromCanvas(document.createElement("canvas")),t&&(this.spriteSheetParams=t,this.setSpriteSheet(t),this.isSpriteSheetMode=!0),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial()}return n.prototype.createUniforms=function(){return{spriteTexture:{type:"t"},spritesPerRow:{type:"f"},spritesPerColumn:{type:"f"},fogColor:{type:"c"},fogNear:{type:"f"},fogFar:{type:"f"},isImage:{type:"bool"},sizeAttenuation:{type:"bool"},pointSize:{type:"f"}}},n.prototype.createRenderMaterial=function(){this.isSpriteSheetMode;var e=this.createUniforms();return new Un.ShaderMaterial({uniforms:e,vertexShader:Lb(this.styles.sprites.minPointSize),fragmentShader:aie,transparent:!0,depthFunc:Un.LessDepth,fog:this.styles.fog.enabled,blending:Un.NormalBlending})},n.prototype.createPickingMaterial=function(){var e=this.createUniforms();return new Un.ShaderMaterial({uniforms:e,vertexShader:Lb(this.styles.sprites.minPointSize),fragmentShader:lie,transparent:!0,depthTest:!0,depthWrite:!0,fog:!1,blending:Un.NormalBlending})},n.prototype.createPointSprites=function(e,t){var i=t!=null?t.length/Fi.XYZ_NUM_ELEMENTS:0,r=this.createGeometry(i);this.fog=new Un.Fog(16777215),this.points=new Un.Points(r,this.renderMaterial),this.points.frustumCulled=!1,this.spriteIndexBufferAttribute!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute),e.add(this.points)},n.prototype.calculatePointSize=function(e){var t=this.styles.sprites.imageSize;if(this.texture)return e?t:this.spriteDimensions[0];var i=this.worldSpacePointPositions!=null?this.worldSpacePointPositions.length/Fi.XYZ_NUM_ELEMENTS:1,r=200,s=8,o=1.5,a=r/Math.log(i)/Math.log(s);return e?a:a/o},n.prototype.createGeometry=function(e){var t=e;this.pickingColors=new Float32Array(t*Fi.RGBA_NUM_ELEMENTS);for(var i=0,r=0;r<t;r++){var s=new Un.Color(r);this.pickingColors[i++]=s.r,this.pickingColors[i++]=s.g,this.pickingColors[i++]=s.b,this.pickingColors[i++]=1}var o=new Un.BufferGeometry;return o.setAttribute("position",new Un.BufferAttribute(new Float32Array([]),Fi.XYZ_NUM_ELEMENTS)),o.setAttribute("color",new Un.BufferAttribute(new Float32Array([]),Fi.RGBA_NUM_ELEMENTS)),o.setAttribute("scaleFactor",new Un.BufferAttribute(new Float32Array([]),Fi.INDEX_NUM_ELEMENTS)),o.computeVertexNormals(),o},n.prototype.setFogDistances=function(e,t,i){var r=this.styles.fog,s=r.threshold,o=r.enabled;if(e&&o){this.fog.near=t;var a=t-i;this.fog.far=t-s*a}else this.fog.near=1/0,this.fog.far=1/0},n.prototype.dispose=function(){this.disposeGeometry(),this.disposeSpriteSheet()},n.prototype.disposeGeometry=function(){this.points!=null&&(this.scene.remove(this.points),this.points.geometry.dispose(),this.points=null,this.worldSpacePointPositions=null)},n.prototype.disposeSpriteSheet=function(){this.texture&&this.texture.dispose(),this.texture=null,this.renderMaterial=null,this.pickingMaterial=null,this.spriteSheetImage=null},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSpriteSheet=function(e){var t=this,i=e.spriteDimensions,r=e.onImageLoad,s=e.spritesheetImage;if(typeof s=="string"){var o=s;s=new Image,s.src=o}this.spriteSheetImage=s,this.texture=Nb.createTextureFromImage(this.spriteSheetImage,function(){t.spritesPerRow=t.spriteSheetImage.width/i[0],t.spritesPerColumn=t.spriteSheetImage.height/i[1],r()}),this.spriteDimensions=i,this.setSpriteIndexBuffer()},n.prototype.setSpriteIndexBuffer=function(){var e=this.spriteSheetParams.spriteIndices;this.spriteIndexBufferAttribute=new Un.BufferAttribute(e,Fi.INDEX_NUM_ELEMENTS),this.points!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute)},n.prototype.onPointPositionsChanged=function(e){this.points!=null&&this.worldSpacePointPositions.length!==e.length&&this.disposeGeometry(),this.worldSpacePointPositions=e,this.points==null&&this.createPointSprites(this.scene,e),this.spriteSheetParams&&this.setSpriteIndexBuffer(),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial();var t=this.points.geometry.getAttribute("position");t.array=e,t.count=e.length/Fi.XYZ_NUM_ELEMENTS,t.needsUpdate=!0},n.prototype.onPickingRender=function(e){var t=e.cameraType===oie.CameraType.Perspective;this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerColumn,this.pickingMaterial.uniforms.sizeAttenuation.value=t,this.pickingMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.pickingMaterial;var i=this.points.geometry.getAttribute("color");i.array=this.pickingColors,i.count=this.pickingColors.length/Fi.RGBA_NUM_ELEMENTS,i.needsUpdate=!0;var r=this.points.geometry.getAttribute("scaleFactor");r.array=e.pointScaleFactors,r.count=e.pointScaleFactors.length,r.count=e.pointScaleFactors.length/Fi.INDEX_NUM_ELEMENTS,r.needsUpdate=!0},n.prototype.onRender=function(e){var t=e.camera instanceof Un.PerspectiveCamera;this.setFogDistances(t,e.nearestCameraSpacePointZ,e.farthestCameraSpacePointZ),this.scene.fog=this.fog,this.scene.fog.color=new Un.Color(e.backgroundColor),this.renderMaterial.uniforms.fogColor.value=this.scene.fog.color,this.renderMaterial.uniforms.fogNear.value=this.fog.near,this.renderMaterial.uniforms.fogFar.value=this.fog.far,this.renderMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.renderMaterial.uniforms.spritesPerColumn.value=this.spritesPerColumn,this.renderMaterial.uniforms.isImage.value=this.texture!=null,this.renderMaterial.uniforms.spriteTexture.value=this.texture!=null?this.texture:this.standinTextureForPoints,this.renderMaterial.uniforms.sizeAttenuation.value=t,this.renderMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.renderMaterial;var i=this.points.geometry.getAttribute("color");this.renderColors=e.pointColors,i.array=this.renderColors,i.count=this.renderColors.length/Fi.RGBA_NUM_ELEMENTS,i.needsUpdate=!0;var r=this.points.geometry.getAttribute("scaleFactor");r.array=e.pointScaleFactors,r.count=e.pointScaleFactors.length/Fi.INDEX_NUM_ELEMENTS,r.needsUpdate=!0},n.prototype.onResize=function(e,t){},n}();Dv.ScatterPlotVisualizerSprites=cie;var kv={},Ov={};Object.defineProperty(Ov,"__esModule",{value:!0});var uie=function(){function n(e,t,i){this.bound=e,this.cellWidth=t,this.cellHeight=i,this.numHorizCells=Math.ceil(this.boundWidth(e)/t),this.numVertCells=Math.ceil(this.boundHeight(e)/i),this.grid=new Array(this.numHorizCells*this.numVertCells)}return n.prototype.boundWidth=function(e){return e.hiX-e.loX},n.prototype.boundHeight=function(e){return e.hiY-e.loY},n.prototype.boundsIntersect=function(e,t){return!(e.loX>t.hiX||e.loY>t.hiY||e.hiX<t.loX||e.hiY<t.loY)},n.prototype.insert=function(e,t){if(t===void 0&&(t=!1),e.hiX<this.bound.loX||e.loX>this.bound.hiX||e.hiY<this.bound.loY||e.loY>this.bound.hiY)return!1;for(var i=this.getCellX(e.loX),r=this.getCellX(e.hiX),s=this.getCellY(e.loY),o=this.getCellY(e.hiY),a=s*this.numHorizCells+i,l=a,c=s;c<=o;c++){for(var u=i;u<=r;u++){var h=this.grid[l++];if(h){for(var d=0;d<h.length;d++)if(this.boundsIntersect(e,h[d]))return!1}}l+=this.numHorizCells-(r-i+1)}if(t)return!0;l=a;for(var c=s;c<=o;c++){for(var u=i;u<=r;u++)this.grid[l]?this.grid[l].push(e):this.grid[l]=[e],l++;l+=this.numHorizCells-(r-i+1)}return!0},n.prototype.getCellX=function(e){return Math.floor((e-this.bound.loX)/this.cellWidth)},n.prototype.getCellY=function(e){return Math.floor((e-this.bound.loY)/this.cellHeight)},n}();Ov.CollisionGrid=uie;var hie=It&&It.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var i=t.call(n),r,s=[],o;try{for(;(e===void 0||e-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(a){o={error:a}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return s};Object.defineProperty(kv,"__esModule",{value:!0});var die=Ta,fie=Ku,pie=Ov,Tm=wn,mie=1e4,gie=function(){function n(e,t){this.styles=t,this.id="CANVAS_LABELS",this.worldSpacePointPositions=new Float32Array(0),this.labelsActive=!0,this.canvas=document.createElement("canvas"),e.appendChild(this.canvas),this.gc=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0",this.canvas.style.pointerEvents="none"}return n.prototype.removeAllLabels=function(){var e=this.canvas.width*window.devicePixelRatio,t=this.canvas.height*window.devicePixelRatio;this.gc.clearRect(0,0,e,t)},n.prototype.makeLabels=function(e){if(!(e.labels==null||e.labels.pointIndices.length===0)&&this.worldSpacePointPositions!=null){var t=e.labels,i=e.cameraType===fie.CameraType.Perspective,r=parseInt(this.gc.font,10),s=window.devicePixelRatio,o;{var a=this.canvas.width*s,l=this.canvas.height*s,c={loX:0,hiX:a,loY:0,hiY:l};o=new pie.CollisionGrid(c,a/25,l/50)}var u=[e.farthestCameraSpacePointZ,e.nearestCameraSpacePointZ],h=function($){return Tm.scaleExponential($,u,[.1,1])},d=e.camera.position,f=d.clone().sub(e.cameraTarget),p=new die.Vector3;this.gc.textBaseline="middle",this.gc.miterLimit=2;for(var m=2,y=4,g=Math.min(mie,t.pointIndices.length),v=0;v<g;++v){var _=void 0;{var b=t.pointIndices[v];_=Tm.vector3FromPackedArray(this.worldSpacePointPositions,b)}if(p.copy(d).sub(_),!(f.dot(p)<0)){var S=hie(Tm.vector3DToScreenCoords(e.camera,e.screenWidth,e.screenHeight,_),2),w=S[0],T=S[1];w+=y;var R={loX:w-m,hiX:w+1+m,loY:T-r/2-m,hiY:T+r/2+m};if(o.insert(R,!0)){var M=t.labelStrings[v],P=t.defaultFontSize*t.scaleFactors[v]*s;if(this.gc.font=P+"px roboto",R.hiX+=this.gc.measureText(M).width-1,o.insert(R)){var L=1;i&&t.useSceneOpacityFlags[v]===1&&(L=h(p.length())),this.gc.fillStyle=this.styleStringFromPackedRgba(t.fillColors,v,L),this.gc.strokeStyle=this.styleStringFromPackedRgba(t.strokeColors,v,L),this.gc.lineWidth=this.styles.label.strokeWidth,this.gc.strokeText(M,w,T),this.gc.lineWidth=this.styles.label.fillWidth,this.gc.fillText(M,w,T)}}}}}},n.prototype.styleStringFromPackedRgba=function(e,t,i){var r=t*3,s=e[r],o=e[r+1],a=e[r+2];return"rgba("+s+","+o+","+a+","+i+")"},n.prototype.onResize=function(e,t){var i=window.devicePixelRatio;this.canvas.width=e*i,this.canvas.height=t*i,this.canvas.style.width=e+"px",this.canvas.style.height=t+"px"},n.prototype.dispose=function(){this.removeAllLabels()},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.removeAllLabels()},n.prototype.onRender=function(e){!this.labelsActive||(this.removeAllLabels(),this.makeLabels(e))},n.prototype.setScene=function(e){},n.prototype.onPickingRender=function(e){},n}();kv.ScatterPlotVisualizerCanvasLabels=gie;var Fv={},Db=It&&It.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],i=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&i>=n.length&&(n=void 0),{value:n&&n[i++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Fv,"__esModule",{value:!0});var _c=Ta,kb=wn,id=Nr,yie=function(){function n(){this.id="POLYLINES",this.sequences=[],this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={},this.pointSequenceIndices=new Map}return n.prototype.getPointSequenceIndex=function(e){return this.pointSequenceIndices.get(e)},n.prototype.updateSequenceIndices=function(){for(var e=0;e<this.sequences.length;e++)for(var t=this.sequences[e],i=0;i<t.indices.length-1;i++){var r=t.indices[i];this.pointSequenceIndices.set(r,e),this.pointSequenceIndices.set(r+1,e)}},n.prototype.createPolylines=function(){var e,t;this.updateSequenceIndices();try{for(var i=Db(this.polylines),r=i.next();!r.done;r=i.next()){var s=r.value;this.scene.remove(s),s.geometry.dispose()}}catch(c){e={error:c}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}this.polylines=[];for(var o=0;o<this.sequences.length;o++){var a=new _c.BufferGeometry;a.addAttribute("position",this.polylinePositionBuffer[o]),a.addAttribute("color",this.polylineColorBuffer[o]);var l=new _c.LineBasicMaterial({linewidth:1,opacity:1,transparent:!0,vertexColors:!0}),s=new _c.LineSegments(a,l);s.frustumCulled=!1,this.polylines.push(s),this.scene.add(s)}},n.prototype.dispose=function(){var e,t;try{for(var i=Db(this.polylines),r=i.next();!r.done;r=i.next()){var s=r.value;this.scene.remove(s),s.geometry.dispose()}}catch(o){e={error:o}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={}},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSequences=function(e){this.sequences=e},n.prototype.onPointPositionsChanged=function(e){if(e==null&&this.dispose(),!(e==null||this.sequences.length===0)){for(var t=0;t<this.sequences.length;t++){var i=this.sequences[t],r=2*(i.indices.length-1),s=new Float32Array(r*id.XYZ_NUM_ELEMENTS);this.polylinePositionBuffer[t]=new _c.BufferAttribute(s,id.XYZ_NUM_ELEMENTS);var o=new Float32Array(r*id.RGBA_NUM_ELEMENTS);this.polylineColorBuffer[t]=new _c.BufferAttribute(o,id.RGBA_NUM_ELEMENTS)}for(var t=0;t<this.sequences.length;t++){for(var i=this.sequences[t],a=0,l=0;l<i.indices.length-1;l++){var c=i.indices[l],u=i.indices[l+1],h=kb.vector3FromPackedArray(e,c),d=kb.vector3FromPackedArray(e,u);this.polylinePositionBuffer[t].setXYZ(a,h.x,h.y,h.z),this.polylinePositionBuffer[t].setXYZ(a+1,d.x,d.y,d.z),a+=2}this.polylinePositionBuffer[t].needsUpdate=!0}this.createPolylines()}},n.prototype.onRender=function(e){for(var t=0;t<this.polylines.length;t++){var i=this.polylines[t].material;i.opacity=e.polylineOpacities[t],i.linewidth=e.polylineWidths[t],this.polylineColorBuffer[t].array=e.polylineColors[t],this.polylineColorBuffer[t].needsUpdate=!0}},n.prototype.onPickingRender=function(e){},n.prototype.onResize=function(e,t){},n}();Fv.ScatterPlotVisualizerPolylines=yie;var vie=It&&It.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var i=t.call(n),r,s=[],o;try{for(;(e===void 0||e-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(a){o={error:a}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return s},Em=It&&It.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(vie(arguments[e]));return n},Ob=It&&It.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],i=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&i>=n.length&&(n=void 0),{value:n&&n[i++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Ky,"__esModule",{value:!0});var xie=Zy,Mo=Pv,_ie=Qf,bie=Ku,wie=Nv,zn=wn,rd=Nr,Sie=Lv,Fb=Dv,Tie=kv,Eie=Fv,Cie=function(){function n(e,t){var i=this;t===void 0&&(t={}),this.pointColorer=null,this.sequences=[],this.renderMode="POINT",this.rotateOnStart=!0,this.selectEnabled=!0,this.showLabelsOnHover=!0,this.hoverPointIndex=null,this.selectedPointIndices=new Set,this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.cameraMoveCallback=function(){},this.onHover=function(r){i.hoverCallback(r),i.hoverPointIndex=r,i.updateScatterPlotAttributes(),i.renderScatterPlot()},this.onClick=function(r){i.clickCallback(r)},this.select=function(r){!i.selectEnabled||(i.selectedPointIndices=new Set(r),i.updateScatterPlotAttributes(),i.renderScatterPlot())},this.onSelect=function(r){!i.selectEnabled||(i.selectCallback(r),i.select(r))},this.containerElement=e,this.styles=wie.makeStyles(t.styles),this.setParameters(t),this.scatterPlot=new xie.ScatterPlot(e,{camera:t.camera,onClick:this.onClick,onHover:this.onHover,onSelect:this.onSelect,selectEnabled:this.selectEnabled,styles:this.styles,orbitControlParams:t.orbitControls}),this.scatterPlot.onCameraMove(this.cameraMoveCallback)}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.onCameraMove!==void 0&&(this.cameraMoveCallback=e.onCameraMove),e.pointColorer!==void 0&&(this.pointColorer=e.pointColorer),e.renderMode!==void 0&&(this.renderMode=e.renderMode),e.rotateOnStart!==void 0&&(this.rotateOnStart=e.rotateOnStart),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled),e.showLabelsOnHover!==void 0&&(this.showLabelsOnHover=e.showLabelsOnHover)},n.prototype.render=function(e){this.updateDataset(e),this.clearVisualizers(),this.setVisualizers(),this.rotateOnStart&&this.scatterPlot.startOrbitAnimation()},n.prototype.clearVisualizers=function(){this.canvasLabelsVisualizer=void 0,this.labels3DVisualizer=void 0,this.pointVisualizer=void 0,this.polylineVisualizer=void 0,this.spritesheetVisualizer=void 0,this.scatterPlot.disposeAllVisualizers()},n.prototype.renderScatterPlot=function(){this.dataset&&this.scatterPlot.render()},n.prototype.resetZoom=function(){this.scatterPlot.resetZoom()},n.prototype.setRenderMode=function(e){this.renderMode=e,this.setVisualizers(),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions()},n.prototype.setTextRenderMode=function(){this.setRenderMode("TEXT"),this.renderScatterPlot()},n.prototype.setPointRenderMode=function(){this.setRenderMode("POINT"),this.renderScatterPlot()},n.prototype.setSpriteRenderMode=function(){this.dataset&&this.dataset.spriteMetadata&&(this.setRenderMode("SPRITE"),this.renderScatterPlot())},n.prototype.setSequences=function(e){this.sequences=e,this.updatePolylineAttributes(),this.setVisualizers(),this.renderScatterPlot()},n.prototype.setPanMode=function(){this.scatterPlot.setInteractionMode("PAN")},n.prototype.setSelectMode=function(){this.scatterPlot.setInteractionMode("SELECT")},n.prototype.setDimensions=function(e){var t=e<2||e>3,i=this.dataset&&e>this.dataset.dimensions;if(t||i)throw new RangeError("Setting invalid dimensionality");this.scatterPlot.setDimensions(e),this.renderScatterPlot()},n.prototype.setPointColorer=function(e){this.pointColorer=e,this.updateScatterPlotAttributes(),this.renderScatterPlot()},n.prototype.callPointColorer=function(e,t){return e(t,this.selectedPointIndices,this.hoverPointIndex)},n.prototype.setHoverPointIndex=function(e){this.hoverPointIndex=e,this.updateScatterPlotAttributes(),!this.scatterPlot.orbitIsAnimating()&&this.renderScatterPlot()},n.prototype.resize=function(){this.scatterPlot.resize()},n.prototype.updateDataset=function(e){this.setDataset(e),this.scatterPlot.setDimensions(e.dimensions),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions(),this.renderScatterPlot()},n.prototype.isOrbiting=function(){return this.scatterPlot.orbitIsAnimating()},n.prototype.startOrbitAnimation=function(){this.scatterPlot.startOrbitAnimation()},n.prototype.stopOrbitAnimation=function(){this.scatterPlot.stopOrbitAnimation()},n.prototype.setDataset=function(e){this.dataset=e,this.labels3DVisualizer&&this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray())},n.prototype.updateScatterPlotPositions=function(){var e=this.dataset;if(!!e){var t=this.generatePointPositionArray(e);this.scatterPlot.setPointPositions(t)}},n.prototype.updateScatterPlotAttributes=function(){var e=this.dataset;if(!!e){var t=this.generatePointColorArray(e),i=this.generatePointScaleFactorArray(e),r=this.generateVisibleLabelRenderParams();this.scatterPlot.setPointColors(t),this.scatterPlot.setPointScaleFactors(i),this.scatterPlot.setLabels(r)}},n.prototype.updatePolylineAttributes=function(){var e=this.dataset;if(!!e){var t=this.generateLineSegmentColorMap(e),i=this.generateLineSegmentOpacityArray(e),r=this.generateLineSegmentWidthArray(e);this.scatterPlot.setPolylineColors(t),this.scatterPlot.setPolylineOpacities(i),this.scatterPlot.setPolylineWidths(r)}},n.prototype.generatePointPositionArray=function(e){var t=[0,0],i=[0,0],r=[0,0];t=zn.extent(e.points.map(function(g){return g[0]})),i=zn.extent(e.points.map(function(g){return g[1]})),e.dimensions===3&&(r=zn.extent(e.points.map(function(g){return g[2]})));var s=function(g){return Math.abs(g[1]-g[0])},o=s(t),a=s(i),l=s(r),c=Math.max(o,a,l),u=rd.SCATTER_PLOT_CUBE_LENGTH/2,h=function(g,v){return[-v*(g/c),v*(g/c)]},d=h(o,u),f=h(a,u),p=h(l,u),m=new Float32Array(e.points.length*3),y=0;return e.points.forEach(function(g,v){var _=e.points[v];m[y++]=zn.scaleLinear(_[0],t,d),m[y++]=zn.scaleLinear(_[1],i,f),e.dimensions===3?m[y++]=zn.scaleLinear(_[2],r,p):m[y++]=0}),m},n.prototype.generateVisibleLabelRenderParams=function(){var e=this,t=e.hoverPointIndex,i=e.selectedPointIndices,r=e.styles,s=t!==null?1:0,o=new Uint32Array(s),a=new Float32Array(s),l=new Int8Array(s),c=new Uint8Array(s*3),u=new Uint8Array(s*3),h=[];a.fill(r.label.scaleDefault),l.fill(1);var d=0;if(t!==null){h.push(this.getLabelText(t)),o[d]=t,a[d]=r.label.scaleLarge,l[d]=0;var f=zn.styleRgbFromHexColor(r.label.fillColorHover);zn.packRgbIntoUint8Array(c,d,f[0],f[1],f[2]);var p=zn.styleRgbFromHexColor(r.label.strokeColorHover);zn.packRgbIntoUint8Array(u,d,p[0],p[1],p[1]),++d}{var f=zn.styleRgbFromHexColor(r.label.fillColorSelected),p=zn.styleRgbFromHexColor(r.label.strokeColorSelected);if(i.size===1){var m=Em(i)[0];h.push(this.getLabelText(m)),o[d]=m,a[d]=r.label.scaleLarge,l[d]=0,zn.packRgbIntoUint8Array(c,d,f[0],f[1],f[2]),zn.packRgbIntoUint8Array(u,d,p[0],p[1],p[2])}}return new bie.LabelRenderParams(new Float32Array(o),h,a,l,r.label.fontSize,c,u)},n.prototype.generatePointScaleFactorArray=function(e){var t,i,r=this,s=r.hoverPointIndex,o=r.selectedPointIndices,a=r.styles,l=a.point,c=l.scaleDefault,u=l.scaleSelected,h=l.scaleHover,d=new Float32Array(e.points.length);d.fill(c),o.size;try{for(var f=Ob(o.values()),p=f.next();!p.done;p=f.next()){var m=p.value;d[m]=u}}catch(y){t={error:y}}finally{try{p&&!p.done&&(i=f.return)&&i.call(f)}finally{if(t)throw t.error}}return s!=null&&(d[s]=h),d},n.prototype.generatePointColorArray=function(e){var t,i,r=this,s=r.hoverPointIndex,o=r.pointColorer,a=r.selectedPointIndices,l=r.styles,c=l.point,u=c.colorHover,h=c.colorNoSelection,d=c.colorSelected,f=c.colorUnselected,p=new Float32Array(e.points.length*rd.RGBA_NUM_ELEMENTS),m=f,y=h;this.renderMode==="TEXT"&&(m=this.styles.label3D.colorUnselected,y=this.styles.label3D.colorNoSelection),this.renderMode==="SPRITE"&&(m=this.styles.sprites.colorUnselected,y=this.styles.sprites.colorNoSelection);var g=e.points.length,v=this.selectedPointIndices.size;if(o)for(var _=0,b=0;b<g;++b){var S=Mo.parseColor(this.callPointColorer(o,b)||y);p[_++]=S.r,p[_++]=S.g,p[_++]=S.b,p[_++]=S.opacity}else{for(var _=0,S=v>0?Mo.parseColor(m):Mo.parseColor(y),b=0;b<g;++b)p[_++]=S.r,p[_++]=S.g,p[_++]=S.b,p[_++]=S.opacity;S=Mo.parseColor(d);try{for(var w=Ob(a.values()),T=w.next();!T.done;T=w.next()){var R=T.value,M=R*rd.RGBA_NUM_ELEMENTS;p[M++]=S.r,p[M++]=S.g,p[M++]=S.b,p[M++]=S.opacity}}catch(I){t={error:I}}finally{try{T&&!T.done&&(i=w.return)&&i.call(w)}finally{if(t)throw t.error}}if(s!=null){var P=Mo.parseColor(u),L=s*rd.RGBA_NUM_ELEMENTS;p[L++]=P.r,p[L++]=P.g,p[L++]=P.b,p[L++]=P.opacity}}return p},n.prototype.generate3DLabelsArray=function(){var e=this.dataset;if(!e)return[];for(var t=[],i=e.points.length,r=0;r<i;++r)t.push(this.getLabelText(r));return t},n.prototype.generateLineSegmentColorMap=function(e){for(var t=this,i=t.pointColorer,r=t.styles,s={},o=0;o<this.sequences.length;o++){var a=this.sequences[o],l=new Float32Array(2*(a.indices.length-1)*3),c=0;if(i)for(var u=0;u<a.indices.length-1;u++){var h=Mo.parseColor(this.callPointColorer(i,a.indices[u])),d=Mo.parseColor(this.callPointColorer(i,a.indices[u+1]));l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=d.r,l[c++]=d.g,l[c++]=d.b}else for(var u=0;u<a.indices.length-1;u++){var h=zn.getDefaultPointInPolylineColor(u,a.indices.length,r.polyline.startHue,r.polyline.endHue,r.polyline.saturation,r.polyline.lightness),d=zn.getDefaultPointInPolylineColor(u+1,a.indices.length,r.polyline.startHue,r.polyline.endHue,r.polyline.saturation,r.polyline.lightness);l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=d.r,l[c++]=d.g,l[c++]=d.b}s[o]=l}return s},n.prototype.generateLineSegmentOpacityArray=function(e){var t=this,i=t.selectedPointIndices,r=t.styles,s=new Float32Array(this.sequences.length),o=i.size;if(o>0){s.fill(r.polyline.deselectedOpacity);var a=this.polylineVisualizer.getPointSequenceIndex(Em(i)[0]);a!==void 0&&(s[a]=r.polyline.selectedOpacity)}else s.fill(r.polyline.defaultOpacity);return s},n.prototype.generateLineSegmentWidthArray=function(e){var t=this,i=t.selectedPointIndices,r=t.styles,s=new Float32Array(this.sequences.length);s.fill(r.polyline.defaultLineWidth);var o=i.size;if(o>0){var a=this.polylineVisualizer.getPointSequenceIndex(Em(i)[0]);a!==void 0&&(s[a]=r.polyline.selectedLineWidth)}return s},n.prototype.getLabelText=function(e){var t=this.dataset;if(!t)return"";var i=t.metadata[e];return i&&i.label!=null?""+i.label:""},n.prototype.initializeCanvasLabelsVisualizer=function(){return this.canvasLabelsVisualizer||(this.canvasLabelsVisualizer=new Tie.ScatterPlotVisualizerCanvasLabels(this.containerElement,this.styles)),this.canvasLabelsVisualizer},n.prototype.initialize3DLabelsVisualizer=function(){return this.labels3DVisualizer||(this.labels3DVisualizer=new Sie.ScatterPlotVisualizer3DLabels(this.styles)),this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray()),this.labels3DVisualizer},n.prototype.initializePointVisualizer=function(){return this.pointVisualizer||(this.pointVisualizer=new Fb.ScatterPlotVisualizerSprites(this.styles)),this.pointVisualizer},n.prototype.initializeSpritesheetVisualizer=function(){var e=this,t=this.styles,i=this.dataset,r=i.spriteMetadata;if(!this.spritesheetVisualizer&&r){if(!r.spriteImage||!r.singleSpriteSize)return;var s=i.points.length,o=void 0;if(r.spriteIndices)o=new Float32Array(r.spriteIndices);else{o=new Float32Array(s);for(var a=0;a<s;++a)o[a]=a}var l=function(){return e.renderScatterPlot()},c=new Fb.ScatterPlotVisualizerSprites(t,{spritesheetImage:r.spriteImage,spriteDimensions:r.singleSpriteSize,spriteIndices:o,onImageLoad:l});c.id="SPRITE_SHEET_VISUALIZER",this.spritesheetVisualizer=c}return this.spritesheetVisualizer},n.prototype.initializePolylineVisualizer=function(){return this.polylineVisualizer||(this.polylineVisualizer=new Eie.ScatterPlotVisualizerPolylines),this.polylineVisualizer.setSequences(this.sequences),this.polylineVisualizer},n.prototype.setVisualizers=function(){var e=this,t=e.dataset,i=e.renderMode,r=[];if(i==="TEXT"){var s=this.initialize3DLabelsVisualizer();r.push(s)}else if(i==="POINT"){var s=this.initializePointVisualizer();r.push(s)}else if(i==="SPRITE"&&t.spriteMetadata){var s=this.initializeSpritesheetVisualizer();s&&r.push(s)}if(this.sequences.length>0){var s=this.initializePolylineVisualizer();r.push(s)}var o=i==="POINT"||i==="SPRITE";if(o&&this.showLabelsOnHover){var s=this.initializeCanvasLabelsVisualizer();r.push(s)}this.scatterPlot.setActiveVisualizers(r)},n.Dataset=_ie.Dataset,n}();Ky.ScatterGL=Cie;Object.defineProperty(Yy,"__esModule",{value:!0});var Mie=Ky,$b=Yy.ScatterGL=Mie.ScatterGL,Aie=Qf;Yy.Dataset=Aie.Dataset;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rie(){return/iPhone|iPad|iPod/i.test(navigator.userAgent)}function Iie(){return/Android/i.test(navigator.userAgent)}function Bb(){return Iie()||Rie()}async function Pie(n){const e=Ds();if(!(n in e.registryFactory))throw new Error(`${n} backend is not registed.`);if(n in e.registry){const t=lN(n);aN(n),oT(n,t)}await oN(n)}async function Nie(n,e){if(n==null)return;if(typeof n!="object")throw new Error(`An object is expected, while a(n) ${typeof n} is found.`);for(const r in n){if(!(r in TUNABLE_FLAG_VALUE_RANGE_MAP))throw new Error(`${r} is not a tunable or valid environment flag.`);if(TUNABLE_FLAG_VALUE_RANGE_MAP[r].indexOf(n[r])===-1)throw new Error(`${r} value is expected to be in the range [${TUNABLE_FLAG_VALUE_RANGE_MAP[r]}], while ${n[r]} is found.`)}ne().setFlags(n);const[t,i]=e.split("-");t==="tfjs"&&await Pie(i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zb=2,Lie=4,Cm={"640 X 480":{width:640,height:480},"640 X 360":{width:640,height:360},"360 X 270":{width:360,height:270}},hR={maxPoses:1,type:"full",scoreThreshold:.65,render3D:!1},Die={maxPoses:1,scoreThreshold:.5},kie={maxPoses:1,type:"lightning",scoreThreshold:.3,customModel:"",enableTracking:!1},on={camera:{targetFPS:60,sizeOption:"640 X 480",scale:1.5},backend:"tfjs-webgl",flags:{},modelConfig:vi({},hR),model:rn.BlazePose};rn.PoseNet+"",rn.MoveNet+"",rn.BlazePose+"";var Oie="/assets/Orbitron-Bold.4962bd96.woff";/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fie=[[0,0,0],[0,1,0],[-1,0,0],[-1,-1,0]],$ie=["#ffffff","#800000","#469990","#e6194b","#42d4f4","#fabed4","#aaffc3","#9a6324","#000075","#f58231","#4363d8","#ffd8b1","#dcbeff","#808000","#ffe119","#911eb4","#bfef45","#f032e6","#3cb44b","#a9a9a9"];class $v{constructor(e=1){this.video=document.getElementById("video"),this.canvas=document.getElementById("output"),this.ctx=this.canvas.getContext("2d"),this.scatterGLEl=document.querySelector("#scatter-gl-container"),this.scatterGL=new $b(this.scatterGLEl,{rotateOnStart:!1,selectEnabled:!1,styles:{polyline:{defaultOpacity:1,deselectedOpacity:1}}}),this.scatterGLHasInitialized=!1,this.scale=e,this.font=new FontFace("Orbitron","url("+Oie+")")}static async setupCamera(e){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");const{targetFPS:t,sizeOption:i,scale:r}=e,s=Cm[i],o={audio:!1,video:{facingMode:"user",width:Bb()?Cm["360 X 270"].width:s.width,height:Bb()?Cm["360 X 270"].height:s.height,frameRate:{ideal:t}}},a=await navigator.mediaDevices.getUserMedia(o),l=new $v(r);l.video.srcObject=a,await new Promise(h=>{l.video.onloadedmetadata=()=>{h(video)}}),l.video.play();const c=l.video.videoWidth*l.scale,u=l.video.videoHeight*l.scale;return l.video.width=c,l.video.height=u,this.ratio=c/u,l.canvas.width=c,l.canvas.height=u,document.querySelector(".canvas-wrapper"),document.querySelector(".container").style=`width: ${c}px; height: ${u}px`,l.ctx.translate(c,0),l.ctx.scale(-1,1),l.scatterGLEl.style=`width: ${c/3}px; height: ${u/3}px;`,l.scatterGL.resize(),l.scatterGLEl.style.display=on.modelConfig.render3D?"inline-block":"none",l}drawCtx(){this.ctx.drawImage(this.video,0,0,this.video.videoWidth*this.scale,this.video.videoHeight*this.scale)}clearCtx(){this.ctx.clearRect(0,0,this.video.videoWidth,this.video.videoHeight)}drawResults(e){for(const t of e)this.drawResult(t)}drawResult(e){e.keypoints!=null&&(this.drawKeypoints(e.keypoints),this.drawSkeleton(e.keypoints,e.id)),e.keypoints3D!=null&&on.modelConfig.render3D&&this.drawKeypoints3D(e.keypoints3D)}drawKeypoints(e){const t=rh.getKeypointIndexBySide(on.model);this.ctx.fillStyle="Red",this.ctx.strokeStyle="White",this.ctx.lineWidth=zb;for(const i of t.middle)this.drawKeypoint(e[i]);this.ctx.fillStyle="Green";for(const i of t.left)this.drawKeypoint(e[i]);this.ctx.fillStyle="Orange";for(const i of t.right)this.drawKeypoint(e[i])}drawKeypoint(e){const t=e.score!=null?e.score:1,i=on.modelConfig.scoreThreshold||0;if(t>=i){const r=new Path2D;r.arc(e.x,e.y,Lie,0,2*Math.PI),this.ctx.fill(r),this.ctx.stroke(r)}}drawSkeleton(e,t){const i=on.modelConfig.enableTracking&&t!=null?$ie[t%20]:"White";this.ctx.fillStyle=i,this.ctx.strokeStyle=i,this.ctx.lineWidth=zb,rh.getAdjacentPairs(on.model).forEach(([r,s])=>{const o=e[r],a=e[s],l=o.score!=null?o.score:1,c=a.score!=null?a.score:1,u=on.modelConfig.scoreThreshold||0;l>=u&&c>=u&&(this.ctx.beginPath(),this.ctx.moveTo(o.x,o.y),this.ctx.lineTo(a.x,a.y),this.ctx.stroke())})}drawKeypoints3D(e){const t=on.modelConfig.scoreThreshold||0,i=e.map(l=>[-l.x,-l.y,-l.z]),r=new $b.Dataset([...i,...Fie]),s=rh.getKeypointIndexBySide(on.model);this.scatterGL.setPointColorer(l=>{if(e[l]==null||e[l].score<t)return"#ffffff";if(l===0)return"#ff0000";if(s.left.indexOf(l)>-1)return"#00ff00";if(s.right.indexOf(l)>-1)return"#ffa500"}),this.scatterGLHasInitialized?this.scatterGL.updateDataset(r):this.scatterGL.render(r);const a=rh.getAdjacentPairs(on.model).map(l=>({indices:l}));this.scatterGL.setSequences(a),this.scatterGLHasInitialized=!0}drawText(e,t,i,r="#0095DD",s="16px"){this.font.load().then(()=>{this.ctx.save(),this.ctx.translate(this.canvas.width,0),this.ctx.scale(-1,1),this.ctx.font=s+" Orbitron",this.ctx.fillStyle=r,this.ctx.fillText(e,t,i),this.ctx.restore()})}resize(e,t,i=!0){var r=this.canvas;document.querySelector(".container").style=`width: ${e}px; height: ${t}px`;var s=r.width,o=r.height;e=Math.round(e),t=Math.round(t);for(var a=s/e,l=o/t,c=Math.ceil(a/2),u=Math.ceil(l/2),h=r.getContext("2d"),d=h.getImageData(0,0,s,o),f=h.createImageData(e,t),p=d.data,m=f.data,y=0;y<t;y++)for(var g=0;g<e;g++){for(var v=(g+y*e)*4,_=0,b=0,S=0,w=0,T=0,R=0,M=0,P=(y+.5)*l,L=Math.floor(y*l),$=Math.ceil((y+1)*l),O=L;O<$;O++)for(var I=Math.abs(P-(O+.5))/u,N=(g+.5)*a,V=I*I,X=Math.floor(g*a),J=Math.ceil((g+1)*a),W=X;W<J;W++){var Q=Math.abs(N-(W+.5))/c,re=Math.sqrt(V+Q*Q);if(!(re>=1)){_=2*re*re*re-3*re*re+1;var xe=4*(W+O*s);M+=_*p[xe+3],S+=_,p[xe+3]<255&&(_=_*p[xe+3]/250),w+=_*p[xe],T+=_*p[xe+1],R+=_*p[xe+2],b+=_}}m[v]=w/b,m[v+1]=T/b,m[v+2]=R/b,m[v+3]=M/S}i===!0?(r.width=e,r.height=t):h.clearRect(0,0,s,o),h.putImageData(f,0,0)}}var Bv={};(function n(e,t,i,r){var s=!!(e.Worker&&e.Blob&&e.Promise&&e.OffscreenCanvas&&e.OffscreenCanvasRenderingContext2D&&e.HTMLCanvasElement&&e.HTMLCanvasElement.prototype.transferControlToOffscreen&&e.URL&&e.URL.createObjectURL);function o(){}function a(I){var N=t.exports.Promise,V=N!==void 0?N:e.Promise;return typeof V=="function"?new V(I):(I(o,o),null)}var l=function(){var I=Math.floor(16.666666666666668),N,V,X={},J=0;return typeof requestAnimationFrame=="function"&&typeof cancelAnimationFrame=="function"?(N=function(W){var Q=Math.random();return X[Q]=requestAnimationFrame(function re(xe){J===xe||J+I-1<xe?(J=xe,delete X[Q],W()):X[Q]=requestAnimationFrame(re)}),Q},V=function(W){X[W]&&cancelAnimationFrame(X[W])}):(N=function(W){return setTimeout(W,I)},V=function(W){return clearTimeout(W)}),{frame:N,cancel:V}}(),c=function(){var I,N,V={};function X(J){function W(Q,re){J.postMessage({options:Q||{},callback:re})}J.init=function(re){var xe=re.transferControlToOffscreen();J.postMessage({canvas:xe},[xe])},J.fire=function(re,xe,Ae){if(N)return W(re,null),N;var $e=Math.random().toString(36).slice(2);return N=a(function(se){function ht(Ie){Ie.data.callback===$e&&(delete V[$e],J.removeEventListener("message",ht),N=null,Ae(),se())}J.addEventListener("message",ht),W(re,$e),V[$e]=ht.bind(null,{data:{callback:$e}})}),N},J.reset=function(){J.postMessage({reset:!0});for(var re in V)V[re](),delete V[re]}}return function(){if(I)return I;if(!i&&s){var J=["var CONFETTI, SIZE = {}, module = {};","("+n.toString()+")(this, module, true, SIZE);","onmessage = function(msg) {","  if (msg.data.options) {","    CONFETTI(msg.data.options).then(function () {","      if (msg.data.callback) {","        postMessage({ callback: msg.data.callback });","      }","    });","  } else if (msg.data.reset) {","    CONFETTI.reset();","  } else if (msg.data.resize) {","    SIZE.width = msg.data.resize.width;","    SIZE.height = msg.data.resize.height;","  } else if (msg.data.canvas) {","    SIZE.width = msg.data.canvas.width;","    SIZE.height = msg.data.canvas.height;","    CONFETTI = module.exports.create(msg.data.canvas);","  }","}"].join(`
`);try{I=new Worker(URL.createObjectURL(new Blob([J])))}catch(W){return typeof console!==void 0&&typeof console.warn=="function"&&console.warn("\u{1F38A} Could not load worker",W),null}X(I)}return I}}(),u={particleCount:50,angle:90,spread:45,startVelocity:45,decay:.9,gravity:1,drift:0,ticks:200,x:.5,y:.5,shapes:["square","circle"],zIndex:100,colors:["#26ccff","#a25afd","#ff5e7e","#88ff5a","#fcff42","#ffa62d","#ff36ff"],disableForReducedMotion:!1,scalar:1};function h(I,N){return N?N(I):I}function d(I){return I!=null}function f(I,N,V){return h(I&&d(I[N])?I[N]:u[N],V)}function p(I){return I<0?0:Math.floor(I)}function m(I,N){return Math.floor(Math.random()*(N-I))+I}function y(I){return parseInt(I,16)}function g(I){return I.map(v)}function v(I){var N=String(I).replace(/[^0-9a-f]/gi,"");return N.length<6&&(N=N[0]+N[0]+N[1]+N[1]+N[2]+N[2]),{r:y(N.substring(0,2)),g:y(N.substring(2,4)),b:y(N.substring(4,6))}}function _(I){var N=f(I,"origin",Object);return N.x=f(N,"x",Number),N.y=f(N,"y",Number),N}function b(I){I.width=document.documentElement.clientWidth,I.height=document.documentElement.clientHeight}function S(I){var N=I.getBoundingClientRect();I.width=N.width,I.height=N.height}function w(I){var N=document.createElement("canvas");return N.style.position="fixed",N.style.top="0px",N.style.left="0px",N.style.pointerEvents="none",N.style.zIndex=I,N}function T(I,N,V,X,J,W,Q,re,xe){I.save(),I.translate(N,V),I.rotate(W),I.scale(X,J),I.arc(0,0,1,Q,re,xe),I.restore()}function R(I){var N=I.angle*(Math.PI/180),V=I.spread*(Math.PI/180);return{x:I.x,y:I.y,wobble:Math.random()*10,wobbleSpeed:Math.min(.11,Math.random()*.1+.05),velocity:I.startVelocity*.5+Math.random()*I.startVelocity,angle2D:-N+(.5*V-Math.random()*V),tiltAngle:(Math.random()*(.75-.25)+.25)*Math.PI,color:I.color,shape:I.shape,tick:0,totalTicks:I.ticks,decay:I.decay,drift:I.drift,random:Math.random()+2,tiltSin:0,tiltCos:0,wobbleX:0,wobbleY:0,gravity:I.gravity*3,ovalScalar:.6,scalar:I.scalar}}function M(I,N){N.x+=Math.cos(N.angle2D)*N.velocity+N.drift,N.y+=Math.sin(N.angle2D)*N.velocity+N.gravity,N.wobble+=N.wobbleSpeed,N.velocity*=N.decay,N.tiltAngle+=.1,N.tiltSin=Math.sin(N.tiltAngle),N.tiltCos=Math.cos(N.tiltAngle),N.random=Math.random()+2,N.wobbleX=N.x+10*N.scalar*Math.cos(N.wobble),N.wobbleY=N.y+10*N.scalar*Math.sin(N.wobble);var V=N.tick++/N.totalTicks,X=N.x+N.random*N.tiltCos,J=N.y+N.random*N.tiltSin,W=N.wobbleX+N.random*N.tiltCos,Q=N.wobbleY+N.random*N.tiltSin;return I.fillStyle="rgba("+N.color.r+", "+N.color.g+", "+N.color.b+", "+(1-V)+")",I.beginPath(),N.shape==="circle"?I.ellipse?I.ellipse(N.x,N.y,Math.abs(W-X)*N.ovalScalar,Math.abs(Q-J)*N.ovalScalar,Math.PI/10*N.wobble,0,2*Math.PI):T(I,N.x,N.y,Math.abs(W-X)*N.ovalScalar,Math.abs(Q-J)*N.ovalScalar,Math.PI/10*N.wobble,0,2*Math.PI):(I.moveTo(Math.floor(N.x),Math.floor(N.y)),I.lineTo(Math.floor(N.wobbleX),Math.floor(J)),I.lineTo(Math.floor(W),Math.floor(Q)),I.lineTo(Math.floor(X),Math.floor(N.wobbleY))),I.closePath(),I.fill(),N.tick<N.totalTicks}function P(I,N,V,X,J){var W=N.slice(),Q=I.getContext("2d"),re,xe,Ae=a(function($e){function se(){re=xe=null,Q.clearRect(0,0,X.width,X.height),J(),$e()}function ht(){i&&!(X.width===r.width&&X.height===r.height)&&(X.width=I.width=r.width,X.height=I.height=r.height),!X.width&&!X.height&&(V(I),X.width=I.width,X.height=I.height),Q.clearRect(0,0,X.width,X.height),W=W.filter(function(Ie){return M(Q,Ie)}),W.length?re=l.frame(ht):se()}re=l.frame(ht),xe=se});return{addFettis:function($e){return W=W.concat($e),Ae},canvas:I,promise:Ae,reset:function(){re&&l.cancel(re),xe&&xe()}}}function L(I,N){var V=!I,X=!!f(N||{},"resize"),J=f(N,"disableForReducedMotion",Boolean),W=s&&!!f(N||{},"useWorker"),Q=W?c():null,re=V?b:S,xe=I&&Q?!!I.__confetti_initialized:!1,Ae=typeof matchMedia=="function"&&matchMedia("(prefers-reduced-motion)").matches,$e;function se(Ie,at,je){for(var it=f(Ie,"particleCount",p),qe=f(Ie,"angle",Number),ce=f(Ie,"spread",Number),ve=f(Ie,"startVelocity",Number),be=f(Ie,"decay",Number),Oe=f(Ie,"gravity",Number),_e=f(Ie,"drift",Number),z=f(Ie,"colors",g),F=f(Ie,"ticks",Number),me=f(Ie,"shapes"),le=f(Ie,"scalar"),j=_(Ie),pe=it,Se=[],De=I.width*j.x,ye=I.height*j.y;pe--;)Se.push(R({x:De,y:ye,angle:qe,spread:ce,startVelocity:ve,color:z[pe%z.length],shape:me[m(0,me.length)],ticks:F,decay:be,gravity:Oe,drift:_e,scalar:le}));return $e?$e.addFettis(Se):($e=P(I,Se,re,at,je),$e.promise)}function ht(Ie){var at=J||f(Ie,"disableForReducedMotion",Boolean),je=f(Ie,"zIndex",Number);if(at&&Ae)return a(function(ve){ve()});V&&$e?I=$e.canvas:V&&!I&&(I=w(je),document.body.appendChild(I)),X&&!xe&&re(I);var it={width:I.width,height:I.height};Q&&!xe&&Q.init(I),xe=!0,Q&&(I.__confetti_initialized=!0);function qe(){if(Q){var ve={getBoundingClientRect:function(){if(!V)return I.getBoundingClientRect()}};re(ve),Q.postMessage({resize:{width:ve.width,height:ve.height}});return}it.width=it.height=null}function ce(){$e=null,X&&e.removeEventListener("resize",qe),V&&I&&(document.body.removeChild(I),I=null,xe=!1)}return X&&e.addEventListener("resize",qe,!1),Q?Q.fire(Ie,it,ce):se(Ie,it,ce)}return ht.reset=function(){Q&&Q.reset(),$e&&$e.reset()},ht}var $;function O(){return $||($=L(null,{useWorker:!0,resize:!0})),$}t.exports=function(){return O().apply(this,arguments)},t.exports.reset=function(){O().reset()},t.exports.create=L})(function(){return typeof window!="undefined"?window:typeof self!="undefined"?self:this||{}}(),Bv,!1);var Bie=Bv.exports;Bv.exports.create;function Ub(n,e){return Math.random()*(e-n)+n}class zie{constructor(){const e=document.querySelector(".confetti-wrapper");this.canvas=document.createElement("canvas"),e.appendChild(this.canvas),this.ctx=this.canvas.getContext("2d"),this.canvas.style.width="100%",this.canvas.style.height="100%",this.myConfetti=Bie.create(this.canvas,{resize:!0}),this.duration=5*1e3,this.animationEnd=Date.now()+this.duration,this.defaults={startVelocity:30,spread:360,ticks:60,zIndex:0},this.firing=!1,this.interval=null}reset(){this.firing=!1}fireOnce(){var e=this.animationEnd-Date.now();if(e<=0)return this.firing=!1,clearInterval(this.interval);var t=200*(e/this.duration);this.myConfetti(Object.assign({},this.defaults,{particleCount:t,origin:{x:Ub(.1,.3),y:Math.random()-.2}})),this.myConfetti(Object.assign({},this.defaults,{particleCount:t,origin:{x:Ub(.7,.9),y:Math.random()-.2}}))}fire(){this.firing||(this.firing=!0,this.animationEnd=Date.now()+this.duration,this.interval=setInterval(this.fireOnce.bind(this),250))}}var dR={exports:{}};(function(n,e){(function(t,i){n.exports=i()})(It,function(){var t=function(){function i(f){return o.appendChild(f.dom),f}function r(f){for(var p=0;p<o.children.length;p++)o.children[p].style.display=p===f?"block":"none";s=f}var s=0,o=document.createElement("div");o.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",o.addEventListener("click",function(f){f.preventDefault(),r(++s%o.children.length)},!1);var a=(performance||Date).now(),l=a,c=0,u=i(new t.Panel("FPS","#0ff","#002")),h=i(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=i(new t.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:o,addPanel:i,showPanel:r,begin:function(){a=(performance||Date).now()},end:function(){c++;var f=(performance||Date).now();if(h.update(f-a,200),f>l+1e3&&(u.update(1e3*c/(f-l),100),l=f,c=0,d)){var p=performance.memory;d.update(p.usedJSHeapSize/1048576,p.jsHeapSizeLimit/1048576)}return f},update:function(){a=this.end()},domElement:o,setMode:r}};return t.Panel=function(i,r,s){var o=1/0,a=0,l=Math.round,c=l(window.devicePixelRatio||1),u=80*c,h=48*c,d=3*c,f=2*c,p=3*c,m=15*c,y=74*c,g=30*c,v=document.createElement("canvas");v.width=u,v.height=h,v.style.cssText="width:80px;height:48px";var _=v.getContext("2d");return _.font="bold "+9*c+"px Helvetica,Arial,sans-serif",_.textBaseline="top",_.fillStyle=s,_.fillRect(0,0,u,h),_.fillStyle=r,_.fillText(i,d,f),_.fillRect(p,m,y,g),_.fillStyle=s,_.globalAlpha=.9,_.fillRect(p,m,y,g),{dom:v,update:function(b,S){o=Math.min(o,b),a=Math.max(a,b),_.fillStyle=s,_.globalAlpha=1,_.fillRect(0,0,u,m),_.fillStyle=r,_.fillText(l(b)+" "+i+" ("+l(o)+"-"+l(a)+")",d,f),_.drawImage(v,p+c,m,y-c,g,p,m,y-c,g),_.fillRect(p+y-c,m,c,g),_.fillStyle=s,_.globalAlpha=.9,_.fillRect(p+y-c,m,c,l((1-b/S)*g))}}},t})})(dR);var Uie=dR.exports;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vie(){const n=new Uie;n.dom.style.cssText="opacity:0.9;z-index:10000;height:80px",document.querySelector(".overlay-wrapper").prepend(n.dom);const t=n.dom.querySelectorAll("canvas");for(let i=0;i<t.length;++i)t[i].style.width="140px",t[i].style.height="80px";return n}const Vb={date:"####/##/##",datetime:"####/##/## ##:##",time:"##:##",fulltime:"##:##:##",phone:"(###) ### - ####",card:"#### #### #### ####"},wf={"#":{pattern:"[\\d]",negate:"[^\\d]"},S:{pattern:"[a-zA-Z]",negate:"[^a-zA-Z]"},N:{pattern:"[0-9a-zA-Z]",negate:"[^0-9a-zA-Z]"},A:{pattern:"[a-zA-Z]",negate:"[^a-zA-Z]",transform:n=>n.toLocaleUpperCase()},a:{pattern:"[a-zA-Z]",negate:"[^a-zA-Z]",transform:n=>n.toLocaleLowerCase()},X:{pattern:"[0-9a-zA-Z]",negate:"[^0-9a-zA-Z]",transform:n=>n.toLocaleUpperCase()},x:{pattern:"[0-9a-zA-Z]",negate:"[^0-9a-zA-Z]",transform:n=>n.toLocaleLowerCase()}},fR=Object.keys(wf);fR.forEach(n=>{wf[n].regex=new RegExp(wf[n].pattern)});const Gie=new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|(["+fR.join("")+"])|(.)","g"),Gb=/[.*+?^${}()|[\]\\]/g,vn=String.fromCharCode(1),Hie={mask:String,reverseFillMask:Boolean,fillMask:[Boolean,String],unmaskedValue:Boolean};function Wie(n,e,t,i){let r,s,o,a;const l=vr(null),c=vr(h());function u(){return n.autogrow===!0||["textarea","text","search","url","tel","password"].includes(n.type)}cs(()=>n.type+n.autogrow,f),cs(()=>n.mask,w=>{if(w!==void 0)p(c.value,!0);else{const T=b(c.value);f(),n.modelValue!==T&&e("update:modelValue",T)}}),cs(()=>n.fillMask+n.reverseFillMask,()=>{l.value===!0&&p(c.value,!0)}),cs(()=>n.unmaskedValue,()=>{l.value===!0&&p(c.value)});function h(){if(f(),l.value===!0){const w=v(b(n.modelValue));return n.fillMask!==!1?S(w):w}return n.modelValue}function d(w){if(w<r.length)return r.slice(-w);let T="",R=r;const M=R.indexOf(vn);if(M>-1){for(let P=w-R.length;P>0;P--)T+=vn;R=R.slice(0,M)+T+R.slice(M)}return R}function f(){if(l.value=n.mask!==void 0&&n.mask.length>0&&u(),l.value===!1){a=void 0,r="",s="";return}const w=Vb[n.mask]===void 0?n.mask:Vb[n.mask],T=typeof n.fillMask=="string"&&n.fillMask.length>0?n.fillMask.slice(0,1):"_",R=T.replace(Gb,"\\$&"),M=[],P=[],L=[];let $=n.reverseFillMask===!0,O="",I="";w.replace(Gie,(J,W,Q,re,xe)=>{if(re!==void 0){const Ae=wf[re];L.push(Ae),I=Ae.negate,$===!0&&(P.push("(?:"+I+"+)?("+Ae.pattern+"+)?(?:"+I+"+)?("+Ae.pattern+"+)?"),$=!1),P.push("(?:"+I+"+)?("+Ae.pattern+")?")}else if(Q!==void 0)O="\\"+(Q==="\\"?"":Q),L.push(Q),M.push("([^"+O+"]+)?"+O+"?");else{const Ae=W!==void 0?W:xe;O=Ae==="\\"?"\\\\\\\\":Ae.replace(Gb,"\\\\$&"),L.push(Ae),M.push("([^"+O+"]+)?"+O+"?")}});const N=new RegExp("^"+M.join("")+"("+(O===""?".":"[^"+O+"]")+"+)?$"),V=P.length-1,X=P.map((J,W)=>W===0&&n.reverseFillMask===!0?new RegExp("^"+R+"*"+J):W===V?new RegExp("^"+J+"("+(I===""?".":I)+"+)?"+(n.reverseFillMask===!0?"$":R+"*")):new RegExp("^"+J));o=L,a=J=>{const W=N.exec(J);W!==null&&(J=W.slice(1).join(""));const Q=[],re=X.length;for(let xe=0,Ae=J;xe<re;xe++){const $e=X[xe].exec(Ae);if($e===null)break;Ae=Ae.slice($e.shift().length),Q.push(...$e)}return Q.length>0?Q.join(""):J},r=L.map(J=>typeof J=="string"?J:vn).join(""),s=r.split(vn).join(T)}function p(w,T,R){const M=i.value,P=M.selectionEnd,L=M.value.length-P,$=b(w);T===!0&&f();const O=v($),I=n.fillMask!==!1?S(O):O,N=c.value!==I;M.value!==I&&(M.value=I),N===!0&&(c.value=I),document.activeElement===M&&Qa(()=>{if(I===s){const X=n.reverseFillMask===!0?s.length:0;M.setSelectionRange(X,X,"forward");return}if(R==="insertFromPaste"&&n.reverseFillMask!==!0){const X=P-1;y.right(M,X,X);return}if(["deleteContentBackward","deleteContentForward"].indexOf(R)>-1){const X=n.reverseFillMask===!0?P===0?I.length>O.length?1:0:Math.max(0,I.length-(I===s?0:Math.min(O.length,L)+1))+1:P;M.setSelectionRange(X,X,"forward");return}if(n.reverseFillMask===!0)if(N===!0){const X=Math.max(0,I.length-(I===s?0:Math.min(O.length,L+1)));X===1&&P===1?M.setSelectionRange(X,X,"forward"):y.rightReverse(M,X,X)}else{const X=I.length-L;M.setSelectionRange(X,X,"backward")}else if(N===!0){const X=Math.max(0,r.indexOf(vn),Math.min(O.length,P)-1);y.right(M,X,X)}else{const X=P-1;y.right(M,X,X)}});const V=n.unmaskedValue===!0?b(I):I;String(n.modelValue)!==V&&t(V,!0)}function m(w,T,R){const M=v(b(w.value));T=Math.max(0,r.indexOf(vn),Math.min(M.length,T)),w.setSelectionRange(T,R,"forward")}const y={left(w,T,R,M){const P=r.slice(T-1).indexOf(vn)===-1;let L=Math.max(0,T-1);for(;L>=0;L--)if(r[L]===vn){T=L,P===!0&&T++;break}if(L<0&&r[T]!==void 0&&r[T]!==vn)return y.right(w,0,0);T>=0&&w.setSelectionRange(T,M===!0?R:T,"backward")},right(w,T,R,M){const P=w.value.length;let L=Math.min(P,R+1);for(;L<=P;L++)if(r[L]===vn){R=L;break}else r[L-1]===vn&&(R=L);if(L>P&&r[R-1]!==void 0&&r[R-1]!==vn)return y.left(w,P,P);w.setSelectionRange(M?T:R,R,"forward")},leftReverse(w,T,R,M){const P=d(w.value.length);let L=Math.max(0,T-1);for(;L>=0;L--)if(P[L-1]===vn){T=L;break}else if(P[L]===vn&&(T=L,L===0))break;if(L<0&&P[T]!==void 0&&P[T]!==vn)return y.rightReverse(w,0,0);T>=0&&w.setSelectionRange(T,M===!0?R:T,"backward")},rightReverse(w,T,R,M){const P=w.value.length,L=d(P),$=L.slice(0,R+1).indexOf(vn)===-1;let O=Math.min(P,R+1);for(;O<=P;O++)if(L[O-1]===vn){R=O,R>0&&$===!0&&R--;break}if(O>P&&L[R-1]!==void 0&&L[R-1]!==vn)return y.leftReverse(w,P,P);w.setSelectionRange(M===!0?T:R,R,"forward")}};function g(w){if(qR(w)===!0)return;const T=i.value,R=T.selectionStart,M=T.selectionEnd;if(w.keyCode===37||w.keyCode===39){const P=y[(w.keyCode===39?"right":"left")+(n.reverseFillMask===!0?"Reverse":"")];w.preventDefault(),P(T,R,M,w.shiftKey)}else w.keyCode===8&&n.reverseFillMask!==!0&&R===M?y.left(T,R,M,!0):w.keyCode===46&&n.reverseFillMask===!0&&R===M&&y.rightReverse(T,R,M,!0)}function v(w){if(w==null||w==="")return"";if(n.reverseFillMask===!0)return _(w);const T=o;let R=0,M="";for(let P=0;P<T.length;P++){const L=w[R],$=T[P];if(typeof $=="string")M+=$,L===$&&R++;else if(L!==void 0&&$.regex.test(L))M+=$.transform!==void 0?$.transform(L):L,R++;else return M}return M}function _(w){const T=o,R=r.indexOf(vn);let M=w.length-1,P="";for(let L=T.length-1;L>=0&&M>-1;L--){const $=T[L];let O=w[M];if(typeof $=="string")P=$+P,O===$&&M--;else if(O!==void 0&&$.regex.test(O))do P=($.transform!==void 0?$.transform(O):O)+P,M--,O=w[M];while(R===L&&O!==void 0&&$.regex.test(O));else return P}return P}function b(w){return typeof w!="string"||a===void 0?typeof w=="number"?a(""+w):w:a(w)}function S(w){return s.length-w.length<=0?w:n.reverseFillMask===!0&&w.length>0?s.slice(0,-w.length)+w:w+s.slice(w.length)}return{innerValue:c,hasMask:l,moveCursorForPaste:m,updateMaskValue:p,onMaskedKeydown:g}}function jie(n,e){function t(){const i=n.modelValue;try{const r="DataTransfer"in window?new DataTransfer:"ClipboardEvent"in window?new ClipboardEvent("").clipboardData:void 0;return Object(i)===i&&("length"in i?Array.from(i):[i]).forEach(s=>{r.items.add(s)}),{files:r.files}}catch{return{files:void 0}}}return e===!0?Bi(()=>{if(n.type==="file")return t()}):Bi(t)}var qie=Hb({name:"QInput",inheritAttrs:!1,props:eh(vi(vi(vi({},tI),Hie),nI),{modelValue:{required:!1},shadowText:String,type:{type:String,default:"text"},debounce:[String,Number],autogrow:Boolean,inputClass:[Array,String,Object],inputStyle:[Array,String,Object]}),emits:[...iI,"paste","change"],setup(n,{emit:e,attrs:t}){const i={};let r=NaN,s,o,a,l;const c=vr(null),u=rI(n),{innerValue:h,hasMask:d,moveCursorForPaste:f,updateMaskValue:p,onMaskedKeydown:m}=Wie(n,e,$,c),y=jie(n,!0),g=Bi(()=>t0(h.value)),v=aI(L),_=sI(),b=Bi(()=>n.type==="textarea"||n.autogrow===!0),S=Bi(()=>b.value===!0||["text","search","url","tel","password"].includes(n.type)),w=Bi(()=>{const W=eh(vi({},_.splitAttrs.listeners.value),{onInput:L,onPaste:P,onChange:I,onBlur:N,onFocus:Qv});return W.onCompositionstart=W.onCompositionupdate=W.onCompositionend=v,d.value===!0&&(W.onKeydown=m),n.autogrow===!0&&(W.onAnimationend=O),W}),T=Bi(()=>{const W=eh(vi({tabindex:0,"data-autofocus":n.autofocus===!0||void 0,rows:n.type==="textarea"?6:void 0,"aria-label":n.label,name:u.value},_.splitAttrs.attributes.value),{id:_.targetUid.value,maxlength:n.maxlength,disabled:n.disable===!0,readonly:n.readonly===!0});return b.value===!1&&(W.type=n.type),n.autogrow===!0&&(W.rows=1),W});cs(()=>n.type,()=>{c.value&&(c.value.value=n.modelValue)}),cs(()=>n.modelValue,W=>{if(d.value===!0){if(o===!0&&(o=!1,String(W)===r))return;p(W)}else h.value!==W&&(h.value=W,n.type==="number"&&i.hasOwnProperty("value")===!0&&(s===!0?s=!1:delete i.value));n.autogrow===!0&&Qa(O)}),cs(()=>n.autogrow,W=>{W===!0?Qa(O):c.value!==null&&t.rows>0&&(c.value.style.height="auto")}),cs(()=>n.dense,()=>{n.autogrow===!0&&Qa(O)});function R(){lI(()=>{const W=document.activeElement;c.value!==null&&c.value!==W&&(W===null||W.id!==_.targetUid.value)&&c.value.focus({preventScroll:!0})})}function M(){c.value!==null&&c.value.select()}function P(W){if(d.value===!0&&n.reverseFillMask!==!0){const Q=W.target;f(Q,Q.selectionStart,Q.selectionEnd)}e("paste",W)}function L(W){if(!W||!W.target||W.target.qComposing===!0)return;if(n.type==="file"){e("update:modelValue",W.target.files);return}const Q=W.target.value;if(d.value===!0)p(Q,!1,W.inputType);else if($(Q),S.value===!0&&W.target===document.activeElement){const{selectionStart:re,selectionEnd:xe}=W.target;re!==void 0&&xe!==void 0&&Qa(()=>{W.target===document.activeElement&&Q.indexOf(W.target.value)===0&&W.target.setSelectionRange(re,xe)})}n.autogrow===!0&&O()}function $(W,Q){l=()=>{n.type!=="number"&&i.hasOwnProperty("value")===!0&&delete i.value,n.modelValue!==W&&r!==W&&(r=W,Q===!0&&(o=!0),e("update:modelValue",W),Qa(()=>{r===W&&(r=NaN)})),l=void 0},n.type==="number"&&(s=!0,i.value=W),n.debounce!==void 0?(clearTimeout(a),i.value=W,a=setTimeout(l,n.debounce)):l()}function O(){const W=c.value;if(W!==null){const Q=W.parentNode.style,{overflow:re}=W.style;Q.marginBottom=W.scrollHeight-1+"px",W.style.height="1px",W.style.overflow="hidden",W.style.height=W.scrollHeight+"px",W.style.overflow=re,Q.marginBottom=""}}function I(W){v(W),clearTimeout(a),l!==void 0&&l(),e("change",W.target.value)}function N(W){W!==void 0&&Qv(W),clearTimeout(a),l!==void 0&&l(),s=!1,o=!1,delete i.value,n.type!=="file"&&setTimeout(()=>{c.value!==null&&(c.value.value=h.value!==void 0?h.value:"")})}function V(){return i.hasOwnProperty("value")===!0?i.value:h.value!==void 0?h.value:""}XR(()=>{N()}),jb(()=>{n.autogrow===!0&&O()}),Object.assign(_,{innerValue:h,fieldClass:Bi(()=>`q-${b.value===!0?"textarea":"input"}`+(n.autogrow===!0?" q-textarea--autogrow":"")),hasShadow:Bi(()=>n.type!=="file"&&typeof n.shadowText=="string"&&n.shadowText.length>0),inputRef:c,emitValue:$,hasValue:g,floatingLabel:Bi(()=>g.value===!0||t0(n.displayValue)),getControl:()=>bc(b.value===!0?"textarea":"input",vi(vi(vi({ref:c,class:["q-field__native q-placeholder",n.inputClass],style:n.inputStyle},T.value),w.value),n.type!=="file"?{value:V()}:y.value)),getShadowControl:()=>bc("div",{class:"q-field__native q-field__shadow absolute-bottom no-pointer-events"+(b.value===!0?"":" text-no-wrap")},[bc("span",{class:"invisible"},V()),bc("span",n.shadowText)])});const X=oI(_),J=Wb();return Object.assign(J.proxy,{focus:R,select:M,getNativeElement:()=>c.value}),X}});const Xie={__name:"WebSocketConnection",setup(n){let e;const t=vr("ws://localhost:65432"),i=vr(!1),r=vr(!1),s=kc("ws-message"),o=kc("ws-return-message"),a=()=>{r.value=!0};function l(){r.value=!1,e=new WebSocket(t.value),e.onopen=function(y){u()},e.onclose=function(y){h()},e.onmessage=function(y){f(y)},e.onerror=function(y){d(y)}}function c(){e.close()}function u(y){i.value=!0,console.log("Socket connected.")}function h(y){i.value=!1,console.log("Socket closed.")}function d(y){alert("error: "+y.data+`
`)}function f(y){let g=JSON.parse(y.data);o.value=g,g.reset&&(console.log("Reset successful."),r.value=!1)}function p(y){e.send(y)}function m(){if(i.value){let y={timestamp:Date.now(),reset:r.value,data:s.value};p(JSON.stringify(y))}}return setInterval(m,100),(y,g)=>(Mc(),sd(qie,{standout:"",color:"primary",modelValue:t.value,"onUpdate:modelValue":g[0]||(g[0]=v=>t.value=v),label:"WS Connection",style:{"min-width":"250px"}},{append:qb(()=>[_d(sp,{class:"cursor-pointer",onClick:a,round:"",dense:"",flat:"",color:"positive",icon:"restart_alt"}),i.value?(Mc(),sd(sp,{key:0,class:"cursor-pointer",onClick:c,round:"",dense:"",flat:"",color:"positive",icon:"link"})):(Mc(),sd(sp,{key:1,class:"cursor-pointer",onClick:l,round:"",dense:"",flat:"",color:"red",icon:"link_off"}))]),_:1},8,["modelValue"]))}};const pR=n=>(JR("data-v-ab20489c"),n=n(),QR(),n),Yie={class:"column items-center"},Kie={class:"row q-py-md"},Zie={class:"container"},Jie={class:"canvas-wrapper"},Qie=pR(()=>Fs("div",{class:"overlay-wrapper row justify-between"},[Fs("div",{id:"scatter-gl-container"})],-1)),ere=pR(()=>Fs("div",{class:"confetti-wrapper"},null,-1)),tre={__name:"PoseDetectionTF",setup(n){const e=hI();let t,i,r,s;const o=KR({isModelChanged:!1}),a=vr(null),l=["BlazePose","MoveNet","PoseNet"],c=vr(null),u=vr(null),h=vr("{}");e0("ws-message",h);const d=vr(null);e0("ws-return-message",d);const f=on;async function p(v){switch(v){case"BlazePose":return on.model=rn.BlazePose,on.modelConfig=vi({},hR),wp(on.model,{runtime:"tfjs",modelType:on.modelConfig.type,detectorModelUrl:"https://raw.githubusercontent.com/TensorHealth/Assets/main/blazepose-models/tfjs-model_blazepose_3d_detector_1/model.json",landmarkModelUrl:"https://raw.githubusercontent.com/TensorHealth/Assets/main/blazepose-models/tfjs-model_blazepose_3d_landmark_full_2/model.json"});case"MoveNet":return on.model=rn.MoveNet,on.modelConfig=vi({},kie),wp(on.model,{modelType:OB.modelType.SINGLEPOSE_THUNDER});case"PoseNet":return on.model=rn.PoseNet,on.modelConfig=vi({},Die),wp(on.model,{quantBytes:4,architecture:"MobileNetV1",outputStride:16,inputResolution:{width:500,height:500},multiplier:.75})}}async function m(){i.video.readyState<2&&await new Promise(_=>{i.video.onloadeddata=()=>{_(video)}});let v=null;if(t!=null&&!o.isModelChanged){try{v=await t.estimatePoses(i.video,{maxPoses:1,flipHorizontal:!1})}catch(_){t.dispose(),t=null,console.error(_)}h.value=v[0]}i.drawCtx(),v&&v.length>0&&!o.isModelChanged&&i.drawResults(v),g(),y()}function y(){d.value!=null&&d.value.guide==="Done!"&&s.fire()}function g(){const v={"Prepare your position":"#EBCB8B","(1)Turn left, (2)lean your body, (3)squat":"#8FBCBB","lower your hands":"#BF616A","Good, now repeat":"#8FBCBB","Good, now lower your hands":"#8FBCBB","Done!":"#A3BE8C"};let _=0,b="Keep going!",S="#8FBCBB",w=0;d.value!=null&&(_=d.value.score,b=d.value.guide,w=d.value.repeat,b in v?S=v[b]:S="#8FBCBB");let T="Score: "+_.toFixed(2).toString()+"/100",R="Progress: "+w.toString()+"/6";i.ctx.font="30px Orbitron";let M=i.ctx.measureText(R).width;i.ctx.font="21px Orbitron";let P=i.ctx.measureText(b).width,L=Math.max(M,P);const $=i.canvas.width/2,O=100,I=L+40,N=120;i.ctx.globalAlpha=.4,i.ctx.fillStyle="#4C566A",i.ctx.fillRect($-I/2,O-N/2,I,N),i.ctx.globalAlpha=.8,i.ctx.textAlign="center",b=="Done!"?i.drawText(T,$,O+25,"#ECEFF4","30px"):i.drawText(R,$,O+25,"#ECEFF4","30px"),i.drawText(b,$,O-25,S,"24px"),i.ctx.globalAlpha=1}return Nie(f.flags,f.backend),cs(a,async(v,_)=>{o.isModelChanged=!0,e.loading.show(),t!=null&&t.dispose();try{console.log(`Model:${v}`),t=await p(v)}catch(b){t=null,console.error(b)}e.loading.hide(),o.isModelChanged=!1}),jb(async()=>{r=Vie(),i=await $v.setupCamera(f.camera),s=new zie,a.value="BlazePose",new rX(30).start(async()=>{r.begin(),o.isModelChanged||await m(),r.end()})}),(v,_)=>(Mc(),ZR("div",Yie,[Fs("div",Kie,[_d(cI,{class:"col q-px-md",standout:"",modelValue:a.value,"onUpdate:modelValue":_[0]||(_[0]=b=>a.value=b),options:l,label:"Model",style:{"min-width":"150px"}},null,8,["modelValue"]),_d(Xie,{class:"col q-px-md"})]),Fs("div",Zie,[Fs("video",{id:"video",ref_key:"inputVideo",ref:c,playsinline:""},null,512),Fs("div",Jie,[Fs("canvas",{id:"output",ref_key:"outputCanvas",ref:u},null,512)]),Qie,ere])]))}};var nre=YR(tre,[["__scopeId","data-v-ab20489c"]]);const _re={__name:"MainPage",setup(n){return(e,t)=>(Mc(),sd(uI,{padding:""},{default:qb(()=>[_d(nre)]),_:1}))}};export{_re as default};
